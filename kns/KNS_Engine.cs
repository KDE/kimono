//Auto-generated by kalyptus. DO NOT EDIT.
namespace KNS {
    using Kimono;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  @brief The KNewStuff2 engine is the top-level class to handle GHNS and DXS workflows.
    ///  An engine implements GHNS workflows, which consist of discrete steps
    ///  performed by the inherited engine. Depending on the provider, traditional
    ///  GHNS or DXS are used transparently.
    ///  This class is the one which applications should use.
    ///  In most cases, either \ref upload() or \ref download() will be called by the
    ///  application to upload or download data.
    ///  </remarks>        <short>    @brief The KNewStuff2 engine is the top-level class to handle GHNS and DXS workflows.</short>
    [SmokeClass("KNS::Engine")]
    public class Engine : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected Engine(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Engine), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static Engine() {
            staticInterceptor = new SmokeInvocation(typeof(Engine), null);
        }
        /// <remarks>
        ///  @brief Engine constructor.
        ///  As many engines as needed can be instantiated, although one should use
        ///  the static methods \ref download() and \ref upload() instead.
        ///      </remarks>        <short>    @brief Engine constructor.</short>
        public Engine(QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Engine#", "Engine(QWidget*)", typeof(void), typeof(QWidget), parent);
        }
        public Engine() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Engine", "Engine()", typeof(void));
        }
        /// <remarks>
        ///  @brief Synchronous way of starting the download workflow.
        ///  Starts the download workflow. This workflow will turn up a dialog
        ///  where the user can select entries for installation and uninstallation.
        ///  This method is a modal one. It will return all affected entries as
        ///  a list.
        ///  NOTE: this list must be queried to see which ones were installed and which were uninstalled
        ///  since both are in the one list. i.e. (entry.Status() == KNS.Entry.Installed)
        /// </remarks>        <return> List of installed or deinstalled entries
        ///      </return>
        ///         <short>    @brief Synchronous way of starting the download workflow.</short>
        public List<KNS.Entry> DownloadDialogModal(QWidget parent) {
            return (List<KNS.Entry>) interceptor.Invoke("downloadDialogModal#", "downloadDialogModal(QWidget*)", typeof(List<KNS.Entry>), typeof(QWidget), parent);
        }
        public List<KNS.Entry> DownloadDialogModal() {
            return (List<KNS.Entry>) interceptor.Invoke("downloadDialogModal", "downloadDialogModal()", typeof(List<KNS.Entry>));
        }
        /// <remarks>
        ///  @brief Synchronous way of starting the upload workflow.
        ///  Starts the upload workflow. This workflow will offer provider
        ///  selection and afterwards upload all files associated with an entry.
        ///  This method is a modal one. It will return the uploaded entry.
        /// </remarks>        <return> Uploaded entry, or <b></b>ull in case of failures
        ///      </return>
        ///         <short>    @brief Synchronous way of starting the upload workflow.</short>
        public KNS.Entry UploadDialogModal(string file) {
            return (KNS.Entry) interceptor.Invoke("uploadDialogModal$", "uploadDialogModal(const QString&)", typeof(KNS.Entry), typeof(string), file);
        }
        /// <remarks>
        ///  @brief Asynchronous way of starting the download workflow.
        ///  This method should be used whenever a blocking application with a
        ///  non-blocking GUI during GHNS operations is not suitable.
        ///  Affected entries will be reported by signals.
        /// </remarks>        <short>    @brief Asynchronous way of starting the download workflow.</short>
        ///         <see> downloadDialogModal</see>
        public void DownloadDialog() {
            interceptor.Invoke("downloadDialog", "downloadDialog()", typeof(void));
        }
        /// <remarks>
        ///  @brief Asynchronous way of starting the upload workflow.
        ///  This method should be used whenever a blocking application with a
        ///  non-blocking GUI during GHNS operations is not suitable.
        ///  The affected entry will be reported by signals.
        /// </remarks>        <short>    @brief Asynchronous way of starting the upload workflow.</short>
        ///         <see> uploadDialogModal</see>
        public void UploadDialog(string file) {
            interceptor.Invoke("uploadDialog$", "uploadDialog(const QString&)", typeof(void), typeof(string), file);
        }
        public bool Init(string config) {
            return (bool) interceptor.Invoke("init$", "init(const QString&)", typeof(bool), typeof(string), config);
        }
        ~Engine() {
            interceptor.Invoke("~Engine", "~Engine()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~Engine", "~Engine()", typeof(void));
        }
        /// <remarks>
        ///  @brief Recommended download workflow entry point.
        ///  This method is a static convenience wrapper around \ref downloadDialogModal()
        ///  which does not require the manual construction of an engine object.
        ///  The engine will be configured to load appname.knsrc.
        ///  The resulting entry list must not be freed, as the engine will continue
        ///  to keep track of it.
        /// </remarks>        <return> List of installed or deinstalled entries
        ///  NOTE: this is a copy of each entry because this call deletes its own
        ///  engine which deletes the original entries, so you need to delete the entries
        ///  returned in the list
        /// </return>
        ///         <short>    @brief Recommended download workflow entry point.</short>
        ///         <see> downloadDialogModal</see>
        public static List<KNS.Entry> Download() {
            return (List<KNS.Entry>) staticInterceptor.Invoke("download", "download()", typeof(List<KNS.Entry>));
        }
        /// <remarks>
        ///  @brief Recommended upload workflow entry point.
        ///  This method is a static convenience wrapper around \ref uploadDialogModal()
        ///  which does not require the manual construction of an engine object.
        ///  The engine will be configured to load appname.knsrc.
        ///  The resulting entry must not be freed, as the engine will continue
        ///  to keep track of it.
        /// </remarks>        <return> Uploaded entry, or <b></b>ull in case of failures
        /// </return>
        ///         <short>    @brief Recommended upload workflow entry point.</short>
        ///         <see> uploadDialogModal</see>
        public static KNS.Entry Upload(string file) {
            return (KNS.Entry) staticInterceptor.Invoke("upload$", "upload(const QString&)", typeof(KNS.Entry), typeof(string), file);
        }
    }
}
