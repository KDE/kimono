//Auto-generated by kalyptus. DO NOT EDIT.
namespace Nepomuk {
    using Kimono;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  \class ResourceManager resourcemanager.h Nepomuk/ResourceManager
    ///  \brief The ResourceManager is the central \a %KMetaData configuration point.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///      </remarks>        <short>    \class ResourceManager resourcemanager.</short>
    [SmokeClass("Nepomuk::ResourceManager")]
    public class ResourceManager : QObject {
        protected ResourceManager(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(ResourceManager), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static ResourceManager() {
            staticInterceptor = new SmokeInvocation(typeof(ResourceManager), null);
        }
        /// <remarks>
        ///  Initialize the Nepomuk framework. This method will initialize the communication with
        ///  the local Nepomuk-KDE services, ie. the data repository.
        ///  When using multiple threads make sure to call this method in the main thread
        ///  before doing anything else.
        ///  \return 0 if all necessary components could be found and -1 otherwise.
        ///  FIXME: introduce error codes and human readable translated error messages.
        ///          </remarks>        <short>    Initialize the Nepomuk framework.</short>
        public int Init() {
            return (int) interceptor.Invoke("init", "init()", typeof(int));
        }
        /// <remarks>
        ///  \return true if init() has been called successfully, ie. the KMetaData system is connected
        ///  to the local RDF repository service and ready to work.
        ///          </remarks>        <short>    \return true if init() has been called successfully, ie.</short>
        public bool Initialized() {
            return (bool) interceptor.Invoke("initialized", "initialized() const", typeof(bool));
        }
        /// <remarks>
        ///  Retrieve the main data storage model.
        ///          </remarks>        <short>    Retrieve the main data storage model.</short>
        public Soprano.Model MainModel() {
            return (Soprano.Model) interceptor.Invoke("mainModel", "mainModel()", typeof(Soprano.Model));
        }
        /// <remarks>
        ///  Override the main model used for all storage. By default the main model
        ///  used is the Nepomuk server main model.
        ///  \param The model to use instead of the Nepomuk server or 0 to reset.
        ///  \since 4.1
        ///          </remarks>        <short>    Override the main model used for all storage.</short>
        public void SetOverrideMainModel(Soprano.Model model) {
            interceptor.Invoke("setOverrideMainModel#", "setOverrideMainModel(Soprano::Model*)", typeof(void), typeof(Soprano.Model), model);
        }
        /// <remarks>
        ///  Remove the resource denoted by \a uri completely.
        ///  This method is just a wrapper around Resource.Remove. The result
        ///  is the same.
        ///          </remarks>        <short>    Remove the resource denoted by \a uri completely.</short>
        public void RemoveResource(string uri) {
            interceptor.Invoke("removeResource$", "removeResource(const QString&)", typeof(void), typeof(string), uri);
        }
        /// <remarks>
        ///  Retrieve a list of all resources of the specified \a type.
        ///  This includes Resources that are not synced yet so it might
        ///  not represent exactly the state as in the RDF store.
        ///          </remarks>        <short>    Retrieve a list of all resources of the specified \a type.</short>
        public List<Nepomuk.Resource> AllResourcesOfType(QUrl type) {
            return (List<Nepomuk.Resource>) interceptor.Invoke("allResourcesOfType#", "allResourcesOfType(const QUrl&)", typeof(List<Nepomuk.Resource>), typeof(QUrl), type);
        }
        /// <remarks>
        ///  Retrieve a list of all resources that have property \a uri defined with a value of \a v.
        ///  This includes Resources that are not synced yet so it might
        ///  not represent exactly the state as in the RDF store.
        ///  \param uri The URI identifying the property. If this URI does
        ///             not include a namespace the default namespace is
        ///             prepended.
        ///  \param v The value all returned resources should have set as properts \a uri.
        ///          </remarks>        <short>    Retrieve a list of all resources that have property \a uri defined with a value of \a v.</short>
        public List<Nepomuk.Resource> AllResourcesWithProperty(QUrl uri, Nepomuk.Variant v) {
            return (List<Nepomuk.Resource>) interceptor.Invoke("allResourcesWithProperty##", "allResourcesWithProperty(const QUrl&, const Nepomuk::Variant&)", typeof(List<Nepomuk.Resource>), typeof(QUrl), uri, typeof(Nepomuk.Variant), v);
        }
        /// <remarks>
        ///  Generates a unique URI that is not used in the store yet. This method ca be used to 
        ///  generate URIs for types such as Tag.
        ///          </remarks>        <short>    Generates a unique URI that is not used in the store yet.</short>
        public string GenerateUniqueUri() {
            return (string) interceptor.Invoke("generateUniqueUri", "generateUniqueUri()", typeof(string));
        }
        /// <remarks>
        ///  \internal Non-public API. Used by Resource to signalize errors.
        ///          </remarks>        <short>    \internal Non-public API.</short>
        public void NotifyError(string uri, int errorCode) {
            interceptor.Invoke("notifyError$$", "notifyError(const QString&, int)", typeof(void), typeof(string), uri, typeof(int), errorCode);
        }
        public static Nepomuk.ResourceManager Instance() {
            return (Nepomuk.ResourceManager) staticInterceptor.Invoke("instance", "instance()", typeof(Nepomuk.ResourceManager));
        }
        protected new IResourceManagerSignals Emit {
            get { return (IResourceManagerSignals) Q_EMIT; }
        }
    }

    public interface IResourceManagerSignals : IQObjectSignals {
    }
}
