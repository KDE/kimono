//Auto-generated by kalyptus. DO NOT EDIT.
namespace Nepomuk {
    using Kimono;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  \class Tag tag.h Nepomuk/Tag
    ///  A Tag can be assigned to any Thing. This allows simple grouping 
    ///  of resources. Each Tag is identifed by its label which should 
    ///  be unique. 
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///      </remarks>        <short>    \class Tag tag.</short>
    [SmokeClass("Nepomuk::Tag")]
    public class Tag : Nepomuk.Resource, IDisposable {
        protected Tag(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Tag), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static Tag() {
            staticInterceptor = new SmokeInvocation(typeof(Tag), null);
        }
        /// <remarks>
        ///  Create a new empty and invalid Tag instance
        ///          </remarks>        <short>    Create a new empty and invalid Tag instance          </short>
        public Tag() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Tag", "Tag()", typeof(void));
        }
        /// <remarks>
        ///  Default copy constructor
        ///          </remarks>        <short>    Default copy constructor          </short>
        public Tag(Nepomuk.Tag arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Tag#", "Tag(const Nepomuk::Tag&)", typeof(void), typeof(Nepomuk.Tag), arg1);
        }
        public Tag(Nepomuk.Resource arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Tag#", "Tag(const Nepomuk::Resource&)", typeof(void), typeof(Nepomuk.Resource), arg1);
        }
        /// <remarks>
        ///  Create a new Tag instance representing the resource
        ///  referenced by \a uriOrIdentifier.
        ///          </remarks>        <short>    Create a new Tag instance representing the resource  referenced by \a uriOrIdentifier.</short>
        public Tag(string uriOrIdentifier) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Tag$", "Tag(const QString&)", typeof(void), typeof(string), uriOrIdentifier);
        }
        /// <remarks>
        ///  Create a new Tag instance representing the resource
        ///  referenced by \a uri.
        ///          </remarks>        <short>    Create a new Tag instance representing the resource  referenced by \a uri.</short>
        public Tag(QUrl uri) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Tag#", "Tag(const QUrl&)", typeof(void), typeof(QUrl), uri);
        }
        /// <remarks>
        ///  Get all resources that have this resource set as property 'Tag'. 
        ///  Each Resource can be tagged with an arbitrary number of Tags. 
        ///  This allows a simple grouping of resources. \sa ResourceManager.AllResourcesWithProperty 
        ///              </remarks>        <short>    Get all resources that have this resource set as property 'Tag'.</short>
        public List<Nepomuk.Resource> TagOf() {
            return (List<Nepomuk.Resource>) interceptor.Invoke("tagOf", "tagOf() const", typeof(List<Nepomuk.Resource>));
        }
        public Tag(string uri, QUrl type) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Tag$#", "Tag(const QString&, const QUrl&)", typeof(void), typeof(string), uri, typeof(QUrl), type);
        }
        public Tag(QUrl uri, QUrl type) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Tag##", "Tag(const QUrl&, const QUrl&)", typeof(void), typeof(QUrl), uri, typeof(QUrl), type);
        }
        ~Tag() {
            interceptor.Invoke("~Tag", "~Tag()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~Tag", "~Tag()", typeof(void));
        }
        /// <remarks>
        ///  Retrieve a list of all available Tag resources. This list consists 
        ///  of all resource of type Tag that are stored in the local Nepomuk 
        ///  meta data storage and any changes made locally. Be aware that 
        ///  in some cases this list can get very big. Then it might be better 
        ///  to use libKNep directly. 
        ///              </remarks>        <short>    Retrieve a list of all available Tag resources.</short>
        public static List<Nepomuk.Tag> AllTags() {
            return (List<Nepomuk.Tag>) staticInterceptor.Invoke("allTags", "allTags()", typeof(List<Nepomuk.Tag>));
        }
        /// <remarks>
        ///  \return The URI of the resource type that is used in Tag instances.
        ///          </remarks>        <short>    \return The URI of the resource type that is used in Tag instances.</short>
        public static string ResourceTypeUri() {
            return (string) staticInterceptor.Invoke("resourceTypeUri", "resourceTypeUri()", typeof(string));
        }
    }
}
