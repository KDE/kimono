//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  \brief Displays a rating value as a row of pixmaps.
    ///  The KRatingWidget displays a range of stars or other arbitrary
    ///  pixmaps and allows the user to select a certain number by mouse.
    ///  \sa KRatingPainter
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///   See <see cref="IKRatingWidgetSignals"></see> for signals emitted by KRatingWidget
    /// </remarks>        <short>    \brief Displays a rating value as a row of pixmaps.</short>
    [SmokeClass("KRatingWidget")]
    public class KRatingWidget : QFrame, IDisposable {
        protected KRatingWidget(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KRatingWidget), this);
        }
        /// <remarks>
        ///  Creates a new rating widget.
        ///      </remarks>        <short>    Creates a new rating widget.</short>
        public KRatingWidget(QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KRatingWidget#", "KRatingWidget(QWidget*)", typeof(void), typeof(QWidget), parent);
        }
        public KRatingWidget() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KRatingWidget", "KRatingWidget()", typeof(void));
        }
        /// <remarks>
        ///  \return The current rating.
        ///      </remarks>        <short>    \return The current rating.</short>
        public uint Rating() {
            return (uint) interceptor.Invoke("rating", "rating() const", typeof(uint));
        }
        /// <remarks>
        ///  \return the maximum possible rating.
        ///      </remarks>        <short>    \return the maximum possible rating.</short>
        public int MaxRating() {
            return (int) interceptor.Invoke("maxRating", "maxRating() const", typeof(int));
        }
        /// <remarks>
        ///  The alignment of the stars.
        ///  \sa setAlignment
        ///      </remarks>        <short>    The alignment of the stars.</short>
        public uint Alignment() {
            return (uint) interceptor.Invoke("alignment", "alignment() const", typeof(uint));
        }
        /// <remarks>
        ///  The layout direction. If RTL the stars
        ///  representing the rating value will be drawn from the 
        ///  right.
        ///  \sa setLayoutDirection
        ///      </remarks>        <short>    The layout direction.</short>
        public new Qt.LayoutDirection LayoutDirection() {
            return (Qt.LayoutDirection) interceptor.Invoke("layoutDirection", "layoutDirection() const", typeof(Qt.LayoutDirection));
        }
        /// <remarks>
        ///  The spacing between the rating stars.
        ///  \sa setSpacing
        ///      </remarks>        <short>    The spacing between the rating stars.</short>
        public int Spacing() {
            return (int) interceptor.Invoke("spacing", "spacing() const", typeof(int));
        }
        [SmokeMethod("sizeHint() const")]
        public override QSize SizeHint() {
            return (QSize) interceptor.Invoke("sizeHint", "sizeHint() const", typeof(QSize));
        }
        /// <remarks>
        ///  If half steps are enabled one star equals to 2 rating
        ///  points and uneven rating values result in half-stars being
        ///  drawn.
        ///  \sa setHalfStepsEnabled
        ///      </remarks>        <short>    If half steps are enabled one star equals to 2 rating  points and uneven rating values result in half-stars being  drawn.</short>
        public bool HalfStepsEnabled() {
            return (bool) interceptor.Invoke("halfStepsEnabled", "halfStepsEnabled() const", typeof(bool));
        }
        /// <remarks>
        ///  The icon used to draw a star. In case a custom pixmap has been set
        ///  this value is ignored.
        ///  \sa setIcon, setCustomPixmap
        ///      </remarks>        <short>    The icon used to draw a star.</short>
        public QIcon Icon() {
            return (QIcon) interceptor.Invoke("icon", "icon() const", typeof(QIcon));
        }
        /// <remarks>
        ///  Set the current rating. Calling this method will NOT trigger the
        ///  ratingChanged signal.
        ///      </remarks>        <short>    Set the current rating.</short>
        [Q_SLOT("void setRating(int)")]
        public void SetRating(int rating) {
            interceptor.Invoke("setRating$", "setRating(int)", typeof(void), typeof(int), rating);
        }
        /// <remarks>
        ///  Set the maximum allowed rating value. The default is 10 which means
        ///  that a rating from 1 to 10 is selectable. If \a max is uneven steps
        ///  are automatically only allowed full.
        ///      </remarks>        <short>    Set the maximum allowed rating value.</short>
        [Q_SLOT("void setMaxRating(int)")]
        public void SetMaxRating(int max) {
            interceptor.Invoke("setMaxRating$", "setMaxRating(int)", typeof(void), typeof(int), max);
        }
        /// <remarks>
        ///  If half steps are enabled (the default) then
        ///  one rating step corresponds to half a star.
        ///      </remarks>        <short>    If half steps are enabled (the default) then  one rating step corresponds to half a star.</short>
        [Q_SLOT("void setHalfStepsEnabled(bool)")]
        public void SetHalfStepsEnabled(bool enabled) {
            interceptor.Invoke("setHalfStepsEnabled$", "setHalfStepsEnabled(bool)", typeof(void), typeof(bool), enabled);
        }
        /// <remarks>
        ///  Set the spacing between the pixmaps. The default is 0.
        ///      </remarks>        <short>    Set the spacing between the pixmaps.</short>
        [Q_SLOT("void setSpacing(int)")]
        public void SetSpacing(int arg1) {
            interceptor.Invoke("setSpacing$", "setSpacing(int)", typeof(void), typeof(int), arg1);
        }
        /// <remarks>
        ///  The alignment of the stars in the drawing rect.
        ///  All alignment flags are supported.
        ///      </remarks>        <short>    The alignment of the stars in the drawing rect.</short>
        [Q_SLOT("void setAlignment(Qt::Alignment)")]
        public void SetAlignment(uint align) {
            interceptor.Invoke("setAlignment$", "setAlignment(Qt::Alignment)", typeof(void), typeof(uint), align);
        }
        /// <remarks>
        ///  LTR or RTL
        ///      </remarks>        <short>    LTR or RTL      </short>
        [Q_SLOT("void setLayoutDirection(Qt::LayoutDirection)")]
        public void SetLayoutDirection(Qt.LayoutDirection direction) {
            interceptor.Invoke("setLayoutDirection$", "setLayoutDirection(Qt::LayoutDirection)", typeof(void), typeof(Qt.LayoutDirection), direction);
        }
        /// <remarks>
        ///  Set a custom icon. Defaults to "rating".
        ///      </remarks>        <short>    Set a custom icon.</short>
        [Q_SLOT("void setIcon(QIcon)")]
        public void SetIcon(QIcon icon) {
            interceptor.Invoke("setIcon#", "setIcon(const QIcon&)", typeof(void), typeof(QIcon), icon);
        }
        /// <remarks>
        ///  Set a custom pixmap.
        ///      </remarks>        <short>    Set a custom pixmap.</short>
        [Q_SLOT("void setCustomPixmap(QPixmap)")]
        public void SetCustomPixmap(QPixmap pixmap) {
            interceptor.Invoke("setCustomPixmap#", "setCustomPixmap(const QPixmap&)", typeof(void), typeof(QPixmap), pixmap);
        }
        /// <remarks>
        ///  Set the recommended size of the pixmaps. This is
        ///  only used for the sizeHint. The actual size is always
        ///  dependant on the size of the widget itself.
        ///      </remarks>        <short>    Set the recommended size of the pixmaps.</short>
        [Q_SLOT("void setPixmapSize(int)")]
        public void SetPixmapSize(int size) {
            interceptor.Invoke("setPixmapSize$", "setPixmapSize(int)", typeof(void), typeof(int), size);
        }
        [SmokeMethod("mousePressEvent(QMouseEvent*)")]
        protected override void MousePressEvent(QMouseEvent e) {
            interceptor.Invoke("mousePressEvent#", "mousePressEvent(QMouseEvent*)", typeof(void), typeof(QMouseEvent), e);
        }
        [SmokeMethod("mouseMoveEvent(QMouseEvent*)")]
        protected override void MouseMoveEvent(QMouseEvent e) {
            interceptor.Invoke("mouseMoveEvent#", "mouseMoveEvent(QMouseEvent*)", typeof(void), typeof(QMouseEvent), e);
        }
        [SmokeMethod("leaveEvent(QEvent*)")]
        protected override void LeaveEvent(QEvent e) {
            interceptor.Invoke("leaveEvent#", "leaveEvent(QEvent*)", typeof(void), typeof(QEvent), e);
        }
        [SmokeMethod("paintEvent(QPaintEvent*)")]
        protected override void PaintEvent(QPaintEvent e) {
            interceptor.Invoke("paintEvent#", "paintEvent(QPaintEvent*)", typeof(void), typeof(QPaintEvent), e);
        }
        [SmokeMethod("resizeEvent(QResizeEvent*)")]
        protected override void ResizeEvent(QResizeEvent e) {
            interceptor.Invoke("resizeEvent#", "resizeEvent(QResizeEvent*)", typeof(void), typeof(QResizeEvent), e);
        }
        ~KRatingWidget() {
            interceptor.Invoke("~KRatingWidget", "~KRatingWidget()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KRatingWidget", "~KRatingWidget()", typeof(void));
        }
        protected new IKRatingWidgetSignals Emit {
            get { return (IKRatingWidgetSignals) Q_EMIT; }
        }
    }

    public interface IKRatingWidgetSignals : IQFrameSignals {
        /// <remarks>
        ///  Emitted if the rating is changed by user interaction (ie. mouse click).
        ///  A call to setRating does not trigger this signal.
        ///      </remarks>        <short>    Emitted if the rating is changed by user interaction (ie.</short>
        [Q_SIGNAL("void ratingChanged(unsigned int)")]
        void RatingChanged(uint rating);
        [Q_SIGNAL("void ratingChanged(int)")]
        void RatingChanged(int rating);
    }
}
