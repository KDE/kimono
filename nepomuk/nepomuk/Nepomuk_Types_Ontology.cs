//Auto-generated by kalyptus. DO NOT EDIT.
namespace Nepomuk.Types {
    using Kimono;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  \class Ontology ontology.h Nepomuk/Types/Ontology
    ///  \brief Represents one ontology.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///          </remarks>        <short>    \class Ontology ontology.</short>
    [SmokeClass("Nepomuk::Types::Ontology")]
    public class Ontology : Nepomuk.Types.Entity, IDisposable {
        protected Ontology(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Ontology), this);
        }
        /// <remarks>
        ///  Default constructor. Creates an empty Ontology.
        ///              </remarks>        <short>    Default constructor.</short>
        public Ontology() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Ontology", "Ontology()", typeof(void));
        }
        /// <remarks>
        ///  Create the ontology referred to by <pre>uri</pre>.
        ///  The result is either a valid ontology which could be loaded from the
        ///  Nepomuk store or a simple class which only contains the uri.
        ///  Be aware that the data is only loaded once read.
        ///  Subsequent calls result in a simple hash lookup of cached data.
        ///              </remarks>        <short>    Create the ontology referred to by \p uri.</short>
        public Ontology(QUrl uri) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Ontology#", "Ontology(const QUrl&)", typeof(void), typeof(QUrl), uri);
        }
        /// <remarks>
        ///  Default copy constructor
        ///              </remarks>        <short>    Default copy constructor              </short>
        public Ontology(Nepomuk.Types.Ontology arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Ontology#", "Ontology(const Nepomuk::Types::Ontology&)", typeof(void), typeof(Nepomuk.Types.Ontology), arg1);
        }
        /// <remarks>
        ///  All classes defined in this ontology, i.e. its namespace.
        ///              </remarks>        <short>    All classes defined in this ontology, i.</short>
        public List<Nepomuk.Types.Class> AllClasses() {
            return (List<Nepomuk.Types.Class>) interceptor.Invoke("allClasses", "allClasses()", typeof(List<Nepomuk.Types.Class>));
        }
        /// <remarks>
        ///  Search for a class in the ontology by its name.
        ///  \param name The name of the class.
        ///  \return the Class object identified by name or an invalid one if the class could not be found.
        ///              </remarks>        <short>    Search for a class in the ontology by its name.</short>
        public Nepomuk.Types.Class FindClassByName(string name) {
            return (Nepomuk.Types.Class) interceptor.Invoke("findClassByName$", "findClassByName(const QString&)", typeof(Nepomuk.Types.Class), typeof(string), name);
        }
        /// <remarks>
        ///  Search for a class in the ontology by its label.
        ///  \param label The label of the class (i.e. rdfs:label)
        ///  \param language The language in which the label was specified. If empty the default rdfs:label
        ///  is returned.
        ///  \return the Class object identified by label or an invalid one if the class could not be found.
        ///              </remarks>        <short>    Search for a class in the ontology by its label.</short>
        public Nepomuk.Types.Class FindClassByLabel(string label, string language) {
            return (Nepomuk.Types.Class) interceptor.Invoke("findClassByLabel$$", "findClassByLabel(const QString&, const QString&)", typeof(Nepomuk.Types.Class), typeof(string), label, typeof(string), language);
        }
        public Nepomuk.Types.Class FindClassByLabel(string label) {
            return (Nepomuk.Types.Class) interceptor.Invoke("findClassByLabel$", "findClassByLabel(const QString&)", typeof(Nepomuk.Types.Class), typeof(string), label);
        }
        /// <remarks>
        ///  A list of all properties defined in this ontology. This does not include properties that use
        ///  classes of this ontology but are defined in a different one.
        ///              </remarks>        <short>    A list of all properties defined in this ontology.</short>
        public List<Nepomuk.Types.Property> AllProperties() {
            return (List<Nepomuk.Types.Property>) interceptor.Invoke("allProperties", "allProperties()", typeof(List<Nepomuk.Types.Property>));
        }
        /// <remarks>
        ///  Search for a property in the ontology by its name.
        ///  \param name The name of the property.
        ///  \return the Property object identified by name or an invalid one if the property could not be found.
        ///              </remarks>        <short>    Search for a property in the ontology by its name.</short>
        public Nepomuk.Types.Property FindPropertyByName(string name) {
            return (Nepomuk.Types.Property) interceptor.Invoke("findPropertyByName$", "findPropertyByName(const QString&)", typeof(Nepomuk.Types.Property), typeof(string), name);
        }
        /// <remarks>
        ///  Search for a property in the ontology by its label.
        ///  \param label The label of the property (i.e. rdfs:label)
        ///  \param language The language in which the label was specified. If empty the default rdfs:label
        ///  is returned.
        ///  \return the Property object identified by label or an invalid one if the property could not be found.
        ///              </remarks>        <short>    Search for a property in the ontology by its label.</short>
        public Nepomuk.Types.Property FindPropertyByLabel(string label, string language) {
            return (Nepomuk.Types.Property) interceptor.Invoke("findPropertyByLabel$$", "findPropertyByLabel(const QString&, const QString&)", typeof(Nepomuk.Types.Property), typeof(string), label, typeof(string), language);
        }
        public Nepomuk.Types.Property FindPropertyByLabel(string label) {
            return (Nepomuk.Types.Property) interceptor.Invoke("findPropertyByLabel$", "findPropertyByLabel(const QString&)", typeof(Nepomuk.Types.Property), typeof(string), label);
        }
        ~Ontology() {
            interceptor.Invoke("~Ontology", "~Ontology()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~Ontology", "~Ontology()", typeof(void));
        }
    }
}
