//Auto-generated by kalyptus. DO NOT EDIT.
namespace Nepomuk.Types {
    using Kimono;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  \class Class class.h Nepomuk/Types/Class
    ///  \brief A Class is a resource of type rdf:Class.
    ///  Class instances are explicitly shared. Two instances created
    ///  with the same uri reference the same data.
    ///  While Resource objects can be changed Class instances are considered
    ///  to be static and never changed during their lifetime.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///          </remarks>        <short>    \class Class class.</short>
    [SmokeClass("Nepomuk::Types::Class")]
    public class Class : Nepomuk.Types.Entity, IDisposable {
        protected Class(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Class), this);
        }
        /// <remarks>
        ///  Default constructor. Creates an empty Class.
        ///              </remarks>        <short>    Default constructor.</short>
        public Class() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Class", "Class()", typeof(void));
        }
        /// <remarks>
        ///  Create the class referred to by <pre>uri</pre>.
        ///  The result is either a valid class which could be loaded from the
        ///  Nepomuk store or a simple class which only contains the uri.
        ///  Be aware that the data is only loaded once read.
        ///  Subsequent calls result in a simple hash lookup of cached data.
        ///              </remarks>        <short>    Create the class referred to by \p uri.</short>
        public Class(QUrl uri) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Class#", "Class(const QUrl&)", typeof(void), typeof(QUrl), uri);
        }
        /// <remarks>
        ///  Default copy constructor
        ///              </remarks>        <short>    Default copy constructor              </short>
        public Class(Nepomuk.Types.Class arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Class#", "Class(const Nepomuk::Types::Class&)", typeof(void), typeof(Nepomuk.Types.Class), arg1);
        }
        /// <remarks>
        ///  A Property has a certain range which is a Class or a Literal.
        ///  \return A list of all properties that have this Class as a range.
        ///  \sa Property.Range()
        ///              </remarks>        <short>    A Property has a certain range which is a Class or a Literal.</short>
        public List<Nepomuk.Types.Property> RangeOf() {
            return (List<Nepomuk.Types.Property>) interceptor.Invoke("rangeOf", "rangeOf()", typeof(List<Nepomuk.Types.Property>));
        }
        /// <remarks>
        ///  A Property has a certain domain which is a Class.
        ///  \return A list of all properties that have this Class as a domain.
        ///  \sa Property.Domain()
        ///              </remarks>        <short>    A Property has a certain domain which is a Class.</short>
        public List<Nepomuk.Types.Property> DomainOf() {
            return (List<Nepomuk.Types.Property>) interceptor.Invoke("domainOf", "domainOf()", typeof(List<Nepomuk.Types.Property>));
        }
        /// <remarks>
        ///  Search for a property in the class by its name.
        ///  \param name The name of the property.
        ///  \return the Property object identified by name or an invalid property if it could not be found.
        ///              </remarks>        <short>    Search for a property in the class by its name.</short>
        public Nepomuk.Types.Property FindPropertyByName(string name) {
            return (Nepomuk.Types.Property) interceptor.Invoke("findPropertyByName$", "findPropertyByName(const QString&)", typeof(Nepomuk.Types.Property), typeof(string), name);
        }
        /// <remarks>
        ///  Search for a property in the class by its label.
        ///  \param label The label of the property (i.e. rdfs:label)
        ///  \param language The language in which the label was specified. If empty the default rdfs:label
        ///  is returned.
        ///  \return the Property object identified by label or an invalid property if it could not be found.
        ///              </remarks>        <short>    Search for a property in the class by its label.</short>
        public Nepomuk.Types.Property FindPropertyByLabel(string label, string language) {
            return (Nepomuk.Types.Property) interceptor.Invoke("findPropertyByLabel$$", "findPropertyByLabel(const QString&, const QString&)", typeof(Nepomuk.Types.Property), typeof(string), label, typeof(string), language);
        }
        public Nepomuk.Types.Property FindPropertyByLabel(string label) {
            return (Nepomuk.Types.Property) interceptor.Invoke("findPropertyByLabel$", "findPropertyByLabel(const QString&)", typeof(Nepomuk.Types.Property), typeof(string), label);
        }
        /// <remarks>
        ///  Each class can have multiple parent classes. This method
        ///  provides a list of all direct parents.
        ///  \return A list of all parent classes of this class.
        ///  If the list is emppty it means that the class has no direct
        ///  parents, i.e. it is derived from rdf:Resource.
        ///  \sa allParentClasses()
        ///              </remarks>        <short>    Each class can have multiple parent classes.</short>
        public List<Nepomuk.Types.Class> ParentClasses() {
            return (List<Nepomuk.Types.Class>) interceptor.Invoke("parentClasses", "parentClasses()", typeof(List<Nepomuk.Types.Class>));
        }
        /// <remarks>
        ///  \return A list of all classes that have this class as a parent.
        ///  Be aware that this list can never be final since other ontologies
        ///  that have not been loaded yet may contain classes that are derived
        ///  from this class.
        ///              </remarks>        <short>    \return A list of all classes that have this class as a parent.</short>
        public List<Nepomuk.Types.Class> SubClasses() {
            return (List<Nepomuk.Types.Class>) interceptor.Invoke("subClasses", "subClasses()", typeof(List<Nepomuk.Types.Class>));
        }
        /// <remarks>
        ///  Recursively determines all parent classes of this class, not
        ///  only the direct ones.
        ///  \return A list of parent classes of this class.
        ///  \sa parentClasses()
        ///              </remarks>        <short>    Recursively determines all parent classes of this class, not  only the direct ones.</short>
        public List<Nepomuk.Types.Class> AllParentClasses() {
            return (List<Nepomuk.Types.Class>) interceptor.Invoke("allParentClasses", "allParentClasses()", typeof(List<Nepomuk.Types.Class>));
        }
        /// <remarks>
        ///  Recursively determines all sub classes of this class, not
        ///  only the direct ones.
        ///  \return A list of sub classes of this class.
        ///  \sa subClasses()
        ///              </remarks>        <short>    Recursively determines all sub classes of this class, not  only the direct ones.</short>
        public List<Nepomuk.Types.Class> AllSubClasses() {
            return (List<Nepomuk.Types.Class>) interceptor.Invoke("allSubClasses", "allSubClasses()", typeof(List<Nepomuk.Types.Class>));
        }
        /// <remarks>
        ///  Check if a class inherits this class. This is a recursive method which
        ///  does not only check direct child classes.
        ///  \return true if other is derived from this class, false otherwise.
        ///              </remarks>        <short>    Check if a class inherits this class.</short>
        public bool IsParentOf(Nepomuk.Types.Class other) {
            return (bool) interceptor.Invoke("isParentOf#", "isParentOf(const Nepomuk::Types::Class&)", typeof(bool), typeof(Nepomuk.Types.Class), other);
        }
        /// <remarks>
        ///  Check if this class is derived from another class. This is a recursive method which
        ///  does not only check direct child classes.
        ///  \return true if this class is derived from other, false otherwise.
        ///              </remarks>        <short>    Check if this class is derived from another class.</short>
        public bool IsSubClassOf(Nepomuk.Types.Class other) {
            return (bool) interceptor.Invoke("isSubClassOf#", "isSubClassOf(const Nepomuk::Types::Class&)", typeof(bool), typeof(Nepomuk.Types.Class), other);
        }
        ~Class() {
            interceptor.Invoke("~Class", "~Class()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~Class", "~Class()", typeof(void));
        }
    }
}
