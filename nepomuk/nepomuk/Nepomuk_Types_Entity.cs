//Auto-generated by kalyptus. DO NOT EDIT.
namespace Nepomuk.Types {
    using Kimono;
    using System;
    using Qyoto;
    /// <remarks>
    ///  Base class for static ontology entities Class and Property.
    ///  It encapsulates the generic labels and comments that both
    ///  types have.
    ///  Due to internal optimizations comparing two Entities is much
    ///  faster than comparing two QUrl objects.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///          </remarks>        <short>    Base class for static ontology entities Class and Property.</short>
    [SmokeClass("Nepomuk::Types::Entity")]
    public class Entity : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected Entity(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Entity), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static Entity() {
            staticInterceptor = new SmokeInvocation(typeof(Entity), null);
        }
        //  operator QUrl(); >>>> NOT CONVERTED
        /// <remarks>
        ///  Default copy constructor.
        ///              </remarks>        <short>    Default copy constructor.</short>
        public Entity(Nepomuk.Types.Entity arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Entity#", "Entity(const Nepomuk::Types::Entity&)", typeof(void), typeof(Nepomuk.Types.Entity), arg1);
        }
        /// <remarks>
        ///  The name of the resource. The name equals the fragment of the
        ///  URI.
        ///              </remarks>        <short>    The name of the resource.</short>
        public string Name() {
            return (string) interceptor.Invoke("name", "name() const", typeof(string));
        }
        /// <remarks>
        ///  The URI of the resource
        ///              </remarks>        <short>    The URI of the resource              </short>
        public QUrl Uri() {
            return (QUrl) interceptor.Invoke("uri", "uri() const", typeof(QUrl));
        }
        /// <remarks>
        ///  Retrieve the label of the entity (rdfs:label)
        ///  \param language The code of the language to use. Defaults to the session
        ///                  language configured in KDE.
        ///  \return The label translated into <pre>language</pre> or the default fallback label
        ///  if no translation is available or the name() if no label could be found
        ///  at all.
        ///              </remarks>        <short>    Retrieve the label of the entity (rdfs:label) </short>
        public string Label(string language) {
            return (string) interceptor.Invoke("label$", "label(const QString&)", typeof(string), typeof(string), language);
        }
        public string Label() {
            return (string) interceptor.Invoke("label", "label()", typeof(string));
        }
        /// <remarks>
        ///  Retrieve the comment of the entity (rdfs:comment)
        ///  \param language The code of the language to use. Defaults to the session
        ///                  language configured in KDE.
        ///  \return The comment translated into <pre>language</pre> or the default fallback comment
        ///  if no translation is available or an empty string if no comment could be found
        ///  at all.
        ///              </remarks>        <short>    Retrieve the comment of the entity (rdfs:comment) </short>
        public string Comment(string language) {
            return (string) interceptor.Invoke("comment$", "comment(const QString&)", typeof(string), typeof(string), language);
        }
        public string Comment() {
            return (string) interceptor.Invoke("comment", "comment()", typeof(string));
        }
        /// <remarks>
        ///  Retrieve the icon stored for the entity (nao:hasSymbol)
        ///  If no symbol is defined for the entity a null icon will be returned.
        ///  \since 4.1
        ///              </remarks>        <short>    Retrieve the icon stored for the entity (nao:hasSymbol) </short>
        public QIcon Icon() {
            return (QIcon) interceptor.Invoke("icon", "icon()", typeof(QIcon));
        }
        /// <remarks>
        ///  Is this a valid Entity, i.e. has it a valid URI.
        ///  A valid Entity does not necessarily have a label and a comment, it
        ///  does not even have to exist in the Nepomuk store.
        ///  \sa isAvailable
        ///              </remarks>        <short>    Is this a valid Entity, i.</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        ///  Is this Entity available locally, i.e. could its properties
        ///  be loaded from the Nepomuk store.
        ///              </remarks>        <short>    Is this Entity available locally, i.</short>
        public bool IsAvailable() {
            return (bool) interceptor.Invoke("isAvailable", "isAvailable()", typeof(bool));
        }
        /// <remarks>
        ///  The Types classes are optimized for performance under the 
        ///  aasumption that ontologies never change during the execution
        ///  time of an application.
        ///  Since there might be situations where this does not apply
        ///  the internal cache can be reset via this method.
        ///  \param recursive If <pre>true</pre> all related entities will be reset
        ///  as well.
        ///  \since 4.1
        ///              </remarks>        <short>    The Types classes are optimized for performance under the   aasumption that ontologies never change during the execution  time of an application.</short>
        public void Reset(bool recursive) {
            interceptor.Invoke("reset$", "reset(bool)", typeof(void), typeof(bool), recursive);
        }
        public void Reset() {
            interceptor.Invoke("reset", "reset()", typeof(void));
        }
        /// <remarks>
        ///  An Entity can be used as a QUrl automagically.
        ///              </remarks>        <short>    An Entity can be used as a QUrl automagically.</short>
        /// <remarks>
        ///  Compares two Entity instances by simply comparing their URI.
        ///              </remarks>        <short>    Compares two Entity instances by simply comparing their URI.</short>
        public override bool Equals(object o) {
            if (!(o is Entity)) { return false; }
            return this == (Entity) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        /// <remarks>
        ///  Create an invalid Entity instance.
        ///              </remarks>        <short>    Create an invalid Entity instance.</short>
        public Entity() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Entity", "Entity()", typeof(void));
        }
        ~Entity() {
            interceptor.Invoke("~Entity", "~Entity()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~Entity", "~Entity()", typeof(void));
        }
        public static bool operator==(Entity lhs, Nepomuk.Types.Entity other) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const Nepomuk::Types::Entity&) const", typeof(bool), typeof(Entity), lhs, typeof(Nepomuk.Types.Entity), other);
        }
        public static bool operator!=(Entity lhs, Nepomuk.Types.Entity other) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const Nepomuk::Types::Entity&) const", typeof(bool), typeof(Entity), lhs, typeof(Nepomuk.Types.Entity), other);
        }
    }
}
