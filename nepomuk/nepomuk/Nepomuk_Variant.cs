//Auto-generated by kalyptus. DO NOT EDIT.
namespace Nepomuk {
    using Kimono;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  \class Variant variant.h Nepomuk/Variant
    ///  The %Nepomuk Variant extends over QVariant by introducing
    ///  direct support for Resource embedding, automatic list conversion 
    ///  and a restricted set of supported types.
    ///  Important differences are:
    ///  <li>No</li> new types can be added other than the ones that have defined
    ///      constructors and get-methods
    ///  <li>Variant</li> supports automatic list generation. For example a Variant
    ///      containing an int also can produce an int-list via the toIntList
    ///      method.
    ///  <li>toString</li> and toStringList always return a valid list and do automatic
    ///      conversion from the actual type used in the Variant. Thus, if one only
    ///      needs to display the value in a Variant toString and toStringList 
    ///      do the job.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///      </remarks>        <short>    \class Variant variant.</short>
    [SmokeClass("Nepomuk::Variant")]
    public class Variant : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected Variant(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Variant), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static Variant() {
            staticInterceptor = new SmokeInvocation(typeof(Variant), null);
        }
        // bool operator==(const QVariant& arg1,const QVariantComparisonHelper& arg2); >>>> NOT CONVERTED
        public Variant() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant", "Variant()", typeof(void));
        }
        public Variant(Nepomuk.Variant other) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant#", "Variant(const Nepomuk::Variant&)", typeof(void), typeof(Nepomuk.Variant), other);
        }
        /// <remarks>
        ///  Will create an invalid Variant if other has an unsupported type.
        ///          </remarks>        <short>    Will create an invalid Variant if other has an unsupported type.</short>
        public Variant(QVariant other) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant#", "Variant(const QVariant&)", typeof(void), typeof(QVariant), other);
        }
        public Variant(int i) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant$", "Variant(int)", typeof(void), typeof(int), i);
        }
        public Variant(long i) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(qlonglong)", typeof(void), typeof(long), i);
        }
        public Variant(uint i) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant$", "Variant(uint)", typeof(void), typeof(uint), i);
        }
        public Variant(ulong i) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant$", "Variant(qulonglong)", typeof(void), typeof(ulong), i);
        }
        public Variant(bool b) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant$", "Variant(bool)", typeof(void), typeof(bool), b);
        }
        public Variant(double d) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant$", "Variant(double)", typeof(void), typeof(double), d);
        }
        public Variant(string arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant$", "Variant(const char*)", typeof(void), typeof(string), arg1);
        }
        public Variant(QDate date) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant#", "Variant(const QDate&)", typeof(void), typeof(QDate), date);
        }
        public Variant(QTime time) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant#", "Variant(const QTime&)", typeof(void), typeof(QTime), time);
        }
        public Variant(QDateTime datetime) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant#", "Variant(const QDateTime&)", typeof(void), typeof(QDateTime), datetime);
        }
        public Variant(QUrl url) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant#", "Variant(const QUrl&)", typeof(void), typeof(QUrl), url);
        }
        public Variant(Nepomuk.Resource r) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant#", "Variant(const Nepomuk::Resource&)", typeof(void), typeof(Nepomuk.Resource), r);
        }
        public Variant(List<int> i) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QList<int>&)", typeof(void), typeof(List<int>), i);
        }
        public Variant(List<long> i) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QList<qlonglong>&)", typeof(void), typeof(List<long>), i);
        }
        public Variant(List<uint> i) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QList<uint>&)", typeof(void), typeof(List<uint>), i);
        }
        public Variant(List<ulong> i) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QList<qulonglong>&)", typeof(void), typeof(List<ulong>), i);
        }
        public Variant(List<bool> b) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QList<bool>&)", typeof(void), typeof(List<bool>), b);
        }
        public Variant(List<double> d) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QList<double>&)", typeof(void), typeof(List<double>), d);
        }
        public Variant(List<string> stringlist) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QStringList&)", typeof(void), typeof(List<string>), stringlist);
        }
        public Variant(List<QDate> date) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QList<QDate>&)", typeof(void), typeof(List<QDate>), date);
        }
        public Variant(List<QTime> time) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QList<QTime>&)", typeof(void), typeof(List<QTime>), time);
        }
        public Variant(List<QDateTime> datetime) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QList<QDateTime>&)", typeof(void), typeof(List<QDateTime>), datetime);
        }
        public Variant(List<QUrl> url) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QList<QUrl>&)", typeof(void), typeof(List<QUrl>), url);
        }
        public Variant(List<Nepomuk.Resource> r) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Variant?", "Variant(const QList<Nepomuk::Resource>&)", typeof(void), typeof(List<Nepomuk.Resource>), r);
        }
        /// <remarks>
        ///  Append \a i to this variant. If the variant already
        ///  contains an int it will be converted to a list of int.
        ///          </remarks>        <short>    Append \a i to this variant.</short>
        public void Append(int i) {
            interceptor.Invoke("append$", "append(int)", typeof(void), typeof(int), i);
        }
        public void Append(long i) {
            interceptor.Invoke("append?", "append(qlonglong)", typeof(void), typeof(long), i);
        }
        public void Append(uint i) {
            interceptor.Invoke("append$", "append(uint)", typeof(void), typeof(uint), i);
        }
        public void Append(ulong i) {
            interceptor.Invoke("append$", "append(qulonglong)", typeof(void), typeof(ulong), i);
        }
        public void Append(bool b) {
            interceptor.Invoke("append$", "append(bool)", typeof(void), typeof(bool), b);
        }
        public void Append(double d) {
            interceptor.Invoke("append$", "append(double)", typeof(void), typeof(double), d);
        }
        public void Append(string arg1) {
            interceptor.Invoke("append$", "append(const QString&)", typeof(void), typeof(string), arg1);
        }
        public void Append(QDate date) {
            interceptor.Invoke("append#", "append(const QDate&)", typeof(void), typeof(QDate), date);
        }
        public void Append(QTime time) {
            interceptor.Invoke("append#", "append(const QTime&)", typeof(void), typeof(QTime), time);
        }
        public void Append(QDateTime datetime) {
            interceptor.Invoke("append#", "append(const QDateTime&)", typeof(void), typeof(QDateTime), datetime);
        }
        public void Append(QUrl url) {
            interceptor.Invoke("append#", "append(const QUrl&)", typeof(void), typeof(QUrl), url);
        }
        public void Append(Nepomuk.Resource r) {
            interceptor.Invoke("append#", "append(const Nepomuk::Resource&)", typeof(void), typeof(Nepomuk.Resource), r);
        }
        /// <remarks>
        ///  Appends the value stored in \a v to the list in this
        ///  Variant. If this Variant contains a value with the same
        ///  simple type as \a v they are merged into a list. Otherwise
        ///  this Variant will contain one list of simple type v.simpleType()
        ///          </remarks>        <short>    Appends the value stored in \a v to the list in this  Variant.</short>
        public void Append(Nepomuk.Variant v) {
            interceptor.Invoke("append#", "append(const Nepomuk::Variant&)", typeof(void), typeof(Nepomuk.Variant), v);
        }
        /// <remarks>
        ///  Does compare two Variant objects. single-valued lists are treated
        ///  as the single value itself. For example a List<string> variant with
        ///  one element "x" equals a string variant with value "x".
        ///          </remarks>        <short>    Does compare two Variant objects.</short>
        public override bool Equals(object o) {
            if (!(o is Variant)) { return false; }
            return this == (Variant) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        ///  \return the QT Meta type id of the type
        ///          </remarks>        <short>    \return the QT Meta type id of the type          </short>
        public int type() {
            return (int) interceptor.Invoke("type", "type() const", typeof(int));
        }
        /// <remarks>
        ///  \return the type of the simple value, i.e. with
        ///  the list stripped.
        ///          </remarks>        <short>    \return the type of the simple value, i.</short>
        public int SimpleType() {
            return (int) interceptor.Invoke("simpleType", "simpleType() const", typeof(int));
        }
        /// <remarks>
        ///  This methods does not handle all list types.
        ///  It checks the following:
        ///  <li>QList</li><Resource>
        ///  <li>QList</li><int>
        ///  <li>QList</li><double>
        ///  <li>QList</li><bool>
        ///  <li>QList</li><QDate>
        ///  <li>QList</li><QTime>
        ///  <li>QList</li><QDateTime>
        ///  <li>QList</li><QUrl>
        ///  <li>QList</li><String> (List<string>)
        ///          </remarks>        <short>    This methods does not handle all list types.</short>
        public bool IsList() {
            return (bool) interceptor.Invoke("isList", "isList() const", typeof(bool));
        }
        public bool IsInt() {
            return (bool) interceptor.Invoke("isInt", "isInt() const", typeof(bool));
        }
        public bool IsInt64() {
            return (bool) interceptor.Invoke("isInt64", "isInt64() const", typeof(bool));
        }
        public bool IsUnsignedInt() {
            return (bool) interceptor.Invoke("isUnsignedInt", "isUnsignedInt() const", typeof(bool));
        }
        public bool IsUnsignedInt64() {
            return (bool) interceptor.Invoke("isUnsignedInt64", "isUnsignedInt64() const", typeof(bool));
        }
        public bool IsBool() {
            return (bool) interceptor.Invoke("isBool", "isBool() const", typeof(bool));
        }
        public bool IsDouble() {
            return (bool) interceptor.Invoke("isDouble", "isDouble() const", typeof(bool));
        }
        public bool IsString() {
            return (bool) interceptor.Invoke("isString", "isString() const", typeof(bool));
        }
        public bool IsDate() {
            return (bool) interceptor.Invoke("isDate", "isDate() const", typeof(bool));
        }
        public bool IsTime() {
            return (bool) interceptor.Invoke("isTime", "isTime() const", typeof(bool));
        }
        public bool IsDateTime() {
            return (bool) interceptor.Invoke("isDateTime", "isDateTime() const", typeof(bool));
        }
        public bool IsUrl() {
            return (bool) interceptor.Invoke("isUrl", "isUrl() const", typeof(bool));
        }
        public bool IsResource() {
            return (bool) interceptor.Invoke("isResource", "isResource() const", typeof(bool));
        }
        public bool IsIntList() {
            return (bool) interceptor.Invoke("isIntList", "isIntList() const", typeof(bool));
        }
        public bool IsInt64List() {
            return (bool) interceptor.Invoke("isInt64List", "isInt64List() const", typeof(bool));
        }
        public bool IsUnsignedIntList() {
            return (bool) interceptor.Invoke("isUnsignedIntList", "isUnsignedIntList() const", typeof(bool));
        }
        public bool IsUnsignedInt64List() {
            return (bool) interceptor.Invoke("isUnsignedInt64List", "isUnsignedInt64List() const", typeof(bool));
        }
        public bool IsBoolList() {
            return (bool) interceptor.Invoke("isBoolList", "isBoolList() const", typeof(bool));
        }
        public bool IsDoubleList() {
            return (bool) interceptor.Invoke("isDoubleList", "isDoubleList() const", typeof(bool));
        }
        public bool IsStringList() {
            return (bool) interceptor.Invoke("isStringList", "isStringList() const", typeof(bool));
        }
        public bool IsDateList() {
            return (bool) interceptor.Invoke("isDateList", "isDateList() const", typeof(bool));
        }
        public bool IsTimeList() {
            return (bool) interceptor.Invoke("isTimeList", "isTimeList() const", typeof(bool));
        }
        public bool IsDateTimeList() {
            return (bool) interceptor.Invoke("isDateTimeList", "isDateTimeList() const", typeof(bool));
        }
        public bool IsUrlList() {
            return (bool) interceptor.Invoke("isUrlList", "isUrlList() const", typeof(bool));
        }
        public bool IsResourceList() {
            return (bool) interceptor.Invoke("isResourceList", "isResourceList() const", typeof(bool));
        }
        public QVariant variant() {
            return (QVariant) interceptor.Invoke("variant", "variant() const", typeof(QVariant));
        }
        public int ToInt() {
            return (int) interceptor.Invoke("toInt", "toInt() const", typeof(int));
        }
        public long ToInt64() {
            return (long) interceptor.Invoke("toInt64", "toInt64() const", typeof(long));
        }
        public uint ToUnsignedInt() {
            return (uint) interceptor.Invoke("toUnsignedInt", "toUnsignedInt() const", typeof(uint));
        }
        public ulong ToUnsignedInt64() {
            return (ulong) interceptor.Invoke("toUnsignedInt64", "toUnsignedInt64() const", typeof(ulong));
        }
        public bool ToBool() {
            return (bool) interceptor.Invoke("toBool", "toBool() const", typeof(bool));
        }
        public double ToDouble() {
            return (double) interceptor.Invoke("toDouble", "toDouble() const", typeof(double));
        }
        /// <remarks>
        ///  The toString() method is a little more powerful than other
        ///  toXXX methods since it actually converts all values to string.
        ///  Thus, toString should work always (even list variants are converted 
        ///  to a comma-separated list)
        ///  Resources are converted to a string representation of their URI.
        ///          </remarks>        <short>    The toString() method is a little more powerful than other  toXXX methods since it actually converts all values to string.</short>
        public new string ToString() {
            return (string) interceptor.Invoke("toString", "toString() const", typeof(string));
        }
        public QDate ToDate() {
            return (QDate) interceptor.Invoke("toDate", "toDate() const", typeof(QDate));
        }
        public QTime ToTime() {
            return (QTime) interceptor.Invoke("toTime", "toTime() const", typeof(QTime));
        }
        public QDateTime ToDateTime() {
            return (QDateTime) interceptor.Invoke("toDateTime", "toDateTime() const", typeof(QDateTime));
        }
        public QUrl ToUrl() {
            return (QUrl) interceptor.Invoke("toUrl", "toUrl() const", typeof(QUrl));
        }
        public Nepomuk.Resource ToResource() {
            return (Nepomuk.Resource) interceptor.Invoke("toResource", "toResource() const", typeof(Nepomuk.Resource));
        }
        public List<int> ToIntList() {
            return (List<int>) interceptor.Invoke("toIntList", "toIntList() const", typeof(List<int>));
        }
        public List<long> ToInt64List() {
            return (List<long>) interceptor.Invoke("toInt64List", "toInt64List() const", typeof(List<long>));
        }
        public List<uint> ToUnsignedIntList() {
            return (List<uint>) interceptor.Invoke("toUnsignedIntList", "toUnsignedIntList() const", typeof(List<uint>));
        }
        public List<ulong> ToUnsignedInt64List() {
            return (List<ulong>) interceptor.Invoke("toUnsignedInt64List", "toUnsignedInt64List() const", typeof(List<ulong>));
        }
        public List<bool> ToBoolList() {
            return (List<bool>) interceptor.Invoke("toBoolList", "toBoolList() const", typeof(List<bool>));
        }
        public List<double> ToDoubleList() {
            return (List<double>) interceptor.Invoke("toDoubleList", "toDoubleList() const", typeof(List<double>));
        }
        /// <remarks>
        ///  Just like the toString method toStringList is able to convert all
        ///  supported types into a list of strings.
        ///          </remarks>        <short>    Just like the toString method toStringList is able to convert all  supported types into a list of strings.</short>
        public List<string> ToStringList() {
            return (List<string>) interceptor.Invoke("toStringList", "toStringList() const", typeof(List<string>));
        }
        public List<QDate> ToDateList() {
            return (List<QDate>) interceptor.Invoke("toDateList", "toDateList() const", typeof(List<QDate>));
        }
        public List<QTime> ToTimeList() {
            return (List<QTime>) interceptor.Invoke("toTimeList", "toTimeList() const", typeof(List<QTime>));
        }
        public List<QDateTime> ToDateTimeList() {
            return (List<QDateTime>) interceptor.Invoke("toDateTimeList", "toDateTimeList() const", typeof(List<QDateTime>));
        }
        public List<QUrl> ToUrlList() {
            return (List<QUrl>) interceptor.Invoke("toUrlList", "toUrlList() const", typeof(List<QUrl>));
        }
        public List<Nepomuk.Resource> ToResourceList() {
            return (List<Nepomuk.Resource>) interceptor.Invoke("toResourceList", "toResourceList() const", typeof(List<Nepomuk.Resource>));
        }
        ~Variant() {
            interceptor.Invoke("~Variant", "~Variant()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~Variant", "~Variant()", typeof(void));
        }
        public static bool operator==(Variant lhs, Nepomuk.Variant other) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const Nepomuk::Variant&) const", typeof(bool), typeof(Variant), lhs, typeof(Nepomuk.Variant), other);
        }
        public static bool operator!=(Variant lhs, Nepomuk.Variant other) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const Nepomuk::Variant&) const", typeof(bool), typeof(Variant), lhs, typeof(Nepomuk.Variant), other);
        }
        /// <remarks>
        ///  Create a Variant object by parsing string \a value based on \a type.
        ///  If \a type is unknown a simple string Variant object is returned
        ///  containing the plain string \a value.
        ///          </remarks>        <short>    Create a Variant object by parsing string \a value based on \a type.</short>
        public static Nepomuk.Variant FromString(string value, int type) {
            return (Nepomuk.Variant) staticInterceptor.Invoke("fromString$$", "fromString(const QString&, int)", typeof(Nepomuk.Variant), typeof(string), value, typeof(int), type);
        }
    }
}
