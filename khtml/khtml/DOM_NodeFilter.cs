//Auto-generated by kalyptus. DO NOT EDIT.
namespace DOM {
	using Kimono;
	using System;
	using Qyoto;
	/// <remarks>
	///  Filters are objects that know how to "filter out" nodes. If an
	///  Iterator or <code>TreeWalker</code> is given a filter, before it
	///  returns the next node, it applies the filter. If the filter says to
	///  accept the node, the Iterator returns it; otherwise, the Iterator
	///  looks for the next node and pretends that the node that was
	///  rejected was not there.
	///   The DOM does not provide any filters. Filter is just an interface
	///  that users can implement to provide their own filters.
	///   Filters do not need to know how to iterate, nor do they need to
	///  know anything about the data structure that is being iterated. This
	///  makes it very easy to write filters, since the only thing they have
	///  to know how to do is evaluate a single node. One filter may be used
	///  with a number of different kinds of Iterators, encouraging code
	///  reuse.
	///  To create your own custom NodeFilter, define a subclass of
	///  CustomNodeFilter which overrides the acceptNode() method and assign
	///  an instance of it to the NodeFilter. For more details see the
	///  CustomNodeFilter class
	///  </remarks>		<short>    Filters are objects that know how to "filter out" nodes.</short>
	[SmokeClass("DOM::NodeFilter")]
	public class NodeFilter : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected NodeFilter(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(NodeFilter), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static NodeFilter() {
			staticInterceptor = new SmokeInvocation(typeof(NodeFilter), null);
		}
		/// <remarks>
		///  The following constants are returned by the acceptNode()
		///  method:
		///      </remarks>		<short>    The following constants are returned by the acceptNode()  method: </short>
		public enum AcceptCode {
			FILTER_ACCEPT = 1,
			FILTER_REJECT = 2,
			FILTER_SKIP = 3,
		}
		/// <remarks>
		///  These are the available values for the whatToShow parameter.
		///  They are the same as the set of possible types for Node, and
		///  their values are derived by using a bit position corresponding
		///  to the value of NodeType for the equivalent node type.
		///      </remarks>		<short>    These are the available values for the whatToShow parameter.</short>
		public enum ShowCode : uint {
			SHOW_ALL = 0xFFFFFFFF,
			SHOW_ELEMENT = 0x00000001,
			SHOW_ATTRIBUTE = 0x00000002,
			SHOW_TEXT = 0x00000004,
			SHOW_CDATA_SECTION = 0x00000008,
			SHOW_ENTITY_REFERENCE = 0x00000010,
			SHOW_ENTITY = 0x00000020,
			SHOW_PROCESSING_INSTRUCTION = 0x00000040,
			SHOW_COMMENT = 0x00000080,
			SHOW_DOCUMENT = 0x00000100,
			SHOW_DOCUMENT_TYPE = 0x00000200,
			SHOW_DOCUMENT_FRAGMENT = 0x00000400,
			SHOW_NOTATION = 0x00000800,
		}
		// DOM::NodeFilter* NodeFilter(DOM::NodeFilterImpl* arg1); >>>> NOT CONVERTED
		public NodeFilter() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("NodeFilter", "NodeFilter()", typeof(void));
		}
		public NodeFilter(DOM.NodeFilter other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("NodeFilter#", "NodeFilter(const DOM::NodeFilter&)", typeof(void), typeof(DOM.NodeFilter), other);
		}
		/// <remarks>
		///  Test whether a specified node is visible in the logical view of
		///  a TreeWalker or NodeIterator. This function will be called by
		///  the implementation of TreeWalker and NodeIterator; it is not
		///  intended to be called directly from user code.
		/// <param> name="n" The node to check to see if it passes the filter or
		///  not.
		/// </param>     </remarks>		<return> a constant to determine whether the node is accepted,
		///  rejected, or skipped, as defined <a
		///  href="#Traversal-NodeFilter-acceptNode-constants"> above </a> .
		/// </return>
		/// 		<short>    Test whether a specified node is visible in the logical view of  a TreeWalker or NodeIterator.</short>
		[SmokeMethod("acceptNode(const DOM::Node&)")]
		public virtual short AcceptNode(DOM.Node n) {
			return (short) interceptor.Invoke("acceptNode#", "acceptNode(const DOM::Node&)", typeof(short), typeof(DOM.Node), n);
		}
		[SmokeMethod("isNull() const")]
		public virtual bool IsNull() {
			return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
		}
		public void SetCustomNodeFilter(DOM.CustomNodeFilter custom) {
			interceptor.Invoke("setCustomNodeFilter#", "setCustomNodeFilter(DOM::CustomNodeFilter*)", typeof(void), typeof(DOM.CustomNodeFilter), custom);
		}
		public DOM.CustomNodeFilter CustomNodeFilter() {
			return (DOM.CustomNodeFilter) interceptor.Invoke("customNodeFilter", "customNodeFilter()", typeof(DOM.CustomNodeFilter));
		}
		~NodeFilter() {
			interceptor.Invoke("~NodeFilter", "~NodeFilter()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~NodeFilter", "~NodeFilter()", typeof(void));
		}
		public static DOM.NodeFilter CreateCustom(DOM.CustomNodeFilter custom) {
			return (DOM.NodeFilter) staticInterceptor.Invoke("createCustom#", "createCustom(DOM::CustomNodeFilter*)", typeof(DOM.NodeFilter), typeof(DOM.CustomNodeFilter), custom);
		}
	}
}
