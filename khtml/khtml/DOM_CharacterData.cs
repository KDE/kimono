//Auto-generated by kalyptus. DO NOT EDIT.
namespace DOM {
	using Kimono;
	using System;
	using Qyoto;
	/// <remarks>
	///  The <code>CharacterData</code> interface extends Node with a set
	///  of attributes and methods for accessing character data in the DOM.
	///  For clarity this set is defined here rather than on each object
	///  that uses these attributes and methods. No DOM objects correspond
	///  directly to <code>CharacterData</code> , though <code>Text</code>
	///  and others do inherit the interface from it. All
	///  <code>offset</code>s in this interface start from 0.
	///  </remarks>		<short>    The <code>CharacterData</code> interface extends Node with a set  of attributes and methods for accessing character data in the DOM.</short>
	[SmokeClass("DOM::CharacterData")]
	public class CharacterData : DOM.Node, IDisposable {
 		protected CharacterData(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(CharacterData), this);
		}
		// DOM::CharacterData* CharacterData(DOM::CharacterDataImpl* arg1); >>>> NOT CONVERTED
		public CharacterData() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("CharacterData", "CharacterData()", typeof(void));
		}
		public CharacterData(DOM.CharacterData other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("CharacterData#", "CharacterData(const DOM::CharacterData&)", typeof(void), typeof(DOM.CharacterData), other);
		}
		public CharacterData(DOM.Node other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("CharacterData#", "CharacterData(const DOM::Node&)", typeof(void), typeof(DOM.Node), other);
		}
		/// <remarks>
		///  The character data of the node that implements this interface.
		///  The DOM implementation may not put arbitrary limits on the
		///  amount of data that may be stored in a <code>CharacterData</code>
		///  node. However, implementation limits may mean that the
		///  entirety of a node's data may not fit into a single
		///  <code>DOMString</code> . In such cases, the user may call
		///  <code>substringData</code> to retrieve the data in appropriately
		///  sized pieces.
		///      </remarks>		<short>    The character data of the node that implements this interface.</short>
		public DOM.DOMString Data() {
			return (DOM.DOMString) interceptor.Invoke("data", "data() const", typeof(DOM.DOMString));
		}
		/// <remarks>
		///  see data
		///      </remarks>		<short>    see data </short>
		public void SetData(DOM.DOMString arg1) {
			interceptor.Invoke("setData#", "setData(const DOM::DOMString&)", typeof(void), typeof(DOM.DOMString), arg1);
		}
		/// <remarks>
		///  The number of characters that are available through <code>data</code>
		///  and the <code>substringData</code> method below. This
		///  may have the value zero, i.e., <code>CharacterData</code>
		///  nodes may be empty.
		///      </remarks>		<short>    The number of characters that are available through <code>data</code>  and the <code>substringData</code> method below.</short>
		public ulong Length() {
			return (ulong) interceptor.Invoke("length", "length() const", typeof(ulong));
		}
		/// <remarks>
		///  Extracts a range of data from the node.
		/// <param> name="offset" Start offset of substring to extract.
		/// </param><param> name="count" The number of characters to extract.
		/// </param>  DOMSTRING_SIZE_ERR: Raised if the specified range of text does
		///  not fit into a <code>DOMString</code> .
		///      </remarks>		<return> The specified substring. If the sum of <code>offset</code>
		///  and <code>count</code> exceeds the <code>length</code>
		///   , then all characters to the end of the data are
		///  returned.
		/// </return>
		/// 		<short>    Extracts a range of data from the node.</short>
		public DOM.DOMString SubstringData(ulong offset, ulong count) {
			return (DOM.DOMString) interceptor.Invoke("substringData$$", "substringData(const unsigned long, const unsigned long)", typeof(DOM.DOMString), typeof(ulong), offset, typeof(ulong), count);
		}
		/// <remarks>
		///  Append the string to the end of the character data of the node.
		///  Upon success, <code>data</code> provides access to the
		///  concatenation of <code>data</code> and the <code>DOMString</code>
		///  specified.
		/// <param> name="arg" The <code>DOMString</code> to append.
		/// </param>     </remarks>		<short>    Append the string to the end of the character data of the node.</short>
		public void AppendData(DOM.DOMString arg) {
			interceptor.Invoke("appendData#", "appendData(const DOM::DOMString&)", typeof(void), typeof(DOM.DOMString), arg);
		}
		/// <remarks>
		///  Insert a string at the specified character offset.
		/// <param> name="offset" The character offset at which to insert.
		/// </param><param> name="arg" The <code>DOMString</code> to insert.
		/// </param>  NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
		///      </remarks>		<short>    Insert a string at the specified character offset.</short>
		public void InsertData(ulong offset, DOM.DOMString arg) {
			interceptor.Invoke("insertData$#", "insertData(const unsigned long, const DOM::DOMString&)", typeof(void), typeof(ulong), offset, typeof(DOM.DOMString), arg);
		}
		/// <remarks>
		///  Remove a range of characters from the node. Upon success,
		///  <code>data</code> and <code>length</code> reflect the
		///  change.
		/// <param> name="offset" The offset from which to remove characters.
		/// </param><param> name="count" The number of characters to delete. If the sum of
		///  <code>offset</code> and <code>count</code> exceeds
		///  <code>length</code> then all characters from <code>offset</code>
		///  to the end of the data are deleted.
		/// </param>  NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
		///      </remarks>		<short>    Remove a range of characters from the node.</short>
		public void DeleteData(ulong offset, ulong count) {
			interceptor.Invoke("deleteData$$", "deleteData(const unsigned long, const unsigned long)", typeof(void), typeof(ulong), offset, typeof(ulong), count);
		}
		/// <remarks>
		///  Replace the characters starting at the specified character
		///  offset with the specified string.
		/// <param> name="offset" The offset from which to start replacing.
		/// </param><param> name="count" The number of characters to replace. If the sum of
		///  <code>offset</code> and <code>count</code> exceeds
		///  <code>length</code> , then all characters to the end of the data are
		///  replaced (i.e., the effect is the same as a <code>remove</code>
		///  method call with the same range, followed by an
		///  <code>append</code> method invocation).
		/// </param><param> name="arg" The <code>DOMString</code> with which the range
		///  must be replaced.
		/// </param>  NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
		///      </remarks>		<short>    Replace the characters starting at the specified character  offset with the specified string.</short>
		public void ReplaceData(ulong offset, ulong count, DOM.DOMString arg) {
			interceptor.Invoke("replaceData$$#", "replaceData(const unsigned long, const unsigned long, const DOM::DOMString&)", typeof(void), typeof(ulong), offset, typeof(ulong), count, typeof(DOM.DOMString), arg);
		}
		~CharacterData() {
			interceptor.Invoke("~CharacterData", "~CharacterData()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~CharacterData", "~CharacterData()", typeof(void));
		}
	}
}
