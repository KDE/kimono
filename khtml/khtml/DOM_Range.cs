//Auto-generated by kalyptus. DO NOT EDIT.
namespace DOM {
	using Kimono;
	using System;
	using Qyoto;
	[SmokeClass("DOM::Range")]
	public class Range : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected Range(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(Range), this);
		}
		public enum CompareHow {
			START_TO_START = 0,
			START_TO_END = 1,
			END_TO_END = 2,
			END_TO_START = 3,
		}
		// DOM::Range* Range(DOM::RangeImpl* arg1); >>>> NOT CONVERTED
		public Range() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Range", "Range()", typeof(void));
		}
		public Range(DOM.Document rootContainer) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Range#", "Range(const DOM::Document)", typeof(void), typeof(DOM.Document), rootContainer);
		}
		public Range(DOM.Range other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Range#", "Range(const DOM::Range&)", typeof(void), typeof(DOM.Range), other);
		}
		public Range(DOM.Node startContainer, long startOffset, DOM.Node endContainer, long endOffset) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("Range#$#$", "Range(const DOM::Node, const long, const DOM::Node, const long)", typeof(void), typeof(DOM.Node), startContainer, typeof(long), startOffset, typeof(DOM.Node), endContainer, typeof(long), endOffset);
		}
		/// <remarks>
		///  Node within which the range begins
		///      </remarks>		<short>    Node within which the range begins </short>
		public DOM.Node StartContainer() {
			return (DOM.Node) interceptor.Invoke("startContainer", "startContainer() const", typeof(DOM.Node));
		}
		/// <remarks>
		///  Offset within the starting node of the range.
		///      </remarks>		<short>    Offset within the starting node of the range.</short>
		public long StartOffset() {
			return (long) interceptor.Invoke("startOffset", "startOffset() const", typeof(long));
		}
		/// <remarks>
		///  Node within which the range ends
		///      </remarks>		<short>    Node within which the range ends </short>
		public DOM.Node EndContainer() {
			return (DOM.Node) interceptor.Invoke("endContainer", "endContainer() const", typeof(DOM.Node));
		}
		/// <remarks>
		///  Offset within the ending node of the range.
		///      </remarks>		<short>    Offset within the ending node of the range.</short>
		public long EndOffset() {
			return (long) interceptor.Invoke("endOffset", "endOffset() const", typeof(long));
		}
		/// <remarks>
		///  true if the range is collapsed
		///      </remarks>		<short>    true if the range is collapsed </short>
		public bool Collapsed() {
			return (bool) interceptor.Invoke("collapsed", "collapsed() const", typeof(bool));
		}
		/// <remarks>
		///  Gets the common ancestor container of the range's two end-points.
		///  Also sets it.
		///      </remarks>		<short>    Gets the common ancestor container of the range's two end-points.</short>
		public DOM.Node CommonAncestorContainer() {
			return (DOM.Node) interceptor.Invoke("commonAncestorContainer", "commonAncestorContainer()", typeof(DOM.Node));
		}
		/// <remarks>
		///  Sets the attributes describing the start of the range.
		/// <param> name="refNode" The <code>refNode</code> value. This parameter
		///  must be different from <code>null</code> .
		/// </param><param> name="offset" The <code>startOffset</code> value.
		/// </param>  INVALID_NODE_TYPE_ERR: Raised if <code>refNode</code> or an
		///  ancestor of <code>refNode</code> is an Attr, Entity,
		///  Notation, or DocumentType node.
		///   If an offset is out-of-bounds, should it just be fixed up or
		///  should an exception be raised.
		///      </remarks>		<short>    Sets the attributes describing the start of the range.</short>
		public void SetStart(DOM.Node refNode, long offset) {
			interceptor.Invoke("setStart#$", "setStart(const DOM::Node&, long)", typeof(void), typeof(DOM.Node), refNode, typeof(long), offset);
		}
		/// <remarks>
		///  Sets the attributes describing the end of a range.
		/// <param> name="refNode" The <code>refNode</code> value. This parameter
		///  must be different from <code>null</code> .
		/// </param><param> name="offset" The <code>endOffset</code> value.
		/// </param>  INVALID_NODE_TYPE_ERR: Raised if <code>refNode</code> or an
		///  ancestor of <code>refNode</code> is an Attr, Entity,
		///  Notation, or DocumentType node.
		///      </remarks>		<short>    Sets the attributes describing the end of a range.</short>
		public void SetEnd(DOM.Node refNode, long offset) {
			interceptor.Invoke("setEnd#$", "setEnd(const DOM::Node&, long)", typeof(void), typeof(DOM.Node), refNode, typeof(long), offset);
		}
		/// <remarks>
		///  Sets the start position to be before a node
		/// <param> name="refNode" Range starts before <code>refNode</code>
		/// </param>     </remarks>		<short>    Sets the start position to be before a node </short>
		public void SetStartBefore(DOM.Node refNode) {
			interceptor.Invoke("setStartBefore#", "setStartBefore(const DOM::Node&)", typeof(void), typeof(DOM.Node), refNode);
		}
		/// <remarks>
		///  Sets the start position to be after a node
		/// <param> name="refNode" Range starts after <code>refNode</code>
		/// </param>     </remarks>		<short>    Sets the start position to be after a node </short>
		public void SetStartAfter(DOM.Node refNode) {
			interceptor.Invoke("setStartAfter#", "setStartAfter(const DOM::Node&)", typeof(void), typeof(DOM.Node), refNode);
		}
		/// <remarks>
		///  Sets the end position to be before a node.
		/// <param> name="refNode" Range ends before <code>refNode</code>
		/// </param>     </remarks>		<short>    Sets the end position to be before a node.</short>
		public void SetEndBefore(DOM.Node refNode) {
			interceptor.Invoke("setEndBefore#", "setEndBefore(const DOM::Node&)", typeof(void), typeof(DOM.Node), refNode);
		}
		/// <remarks>
		///  Sets the end of a range to be after a node
		/// <param> name="refNode" Range ends after <code>refNode</code> .
		/// </param>     </remarks>		<short>    Sets the end of a range to be after a node </short>
		public void SetEndAfter(DOM.Node refNode) {
			interceptor.Invoke("setEndAfter#", "setEndAfter(const DOM::Node&)", typeof(void), typeof(DOM.Node), refNode);
		}
		/// <remarks>
		///  Collapse a range onto one of its end-points
		/// <param> name="toStart" If true, collapses the Range onto its start; if
		///  false, collapses it onto its end.
		/// </param>     </remarks>		<short>    Collapse a range onto one of its end-points </short>
		public void Collapse(bool toStart) {
			interceptor.Invoke("collapse$", "collapse(bool)", typeof(void), typeof(bool), toStart);
		}
		/// <remarks>
		///  Select a node and its contents
		/// <param> name="refNode" The node to select.
		/// </param>     </remarks>		<short>    Select a node and its contents </short>
		public void SelectNode(DOM.Node refNode) {
			interceptor.Invoke("selectNode#", "selectNode(const DOM::Node&)", typeof(void), typeof(DOM.Node), refNode);
		}
		/// <remarks>
		///  Select the contents within a node
		/// <param> name="refNode" Node to select from
		/// </param>     </remarks>		<short>    Select the contents within a node </short>
		public void SelectNodeContents(DOM.Node refNode) {
			interceptor.Invoke("selectNodeContents#", "selectNodeContents(const DOM::Node&)", typeof(void), typeof(DOM.Node), refNode);
		}
		/// <remarks>
		///  Compare the end-points of two ranges in a document.
		///      </remarks>		<return> -1, 0 or 1 depending on whether the corresponding
		///  end-point of the Range is before, equal to, or after the
		///  corresponding end-point of <code>sourceRange</code> .
		/// </return>
		/// 		<short>    Compare the end-points of two ranges in a document.</short>
		public short CompareBoundaryPoints(DOM.Range.CompareHow how, DOM.Range sourceRange) {
			return (short) interceptor.Invoke("compareBoundaryPoints$#", "compareBoundaryPoints(DOM::Range::CompareHow, const DOM::Range&)", typeof(short), typeof(DOM.Range.CompareHow), how, typeof(DOM.Range), sourceRange);
		}
		/// <remarks>
		///  not part of the DOM
		///  Compare the boundary-points of a range.
		///  Return true if the startContainer is before the endContainer,
		///  or if they are equal.
		///  Return false if the startContainer is after the endContainer.
		///      </remarks>		<short>   </short>
		public bool BoundaryPointsValid() {
			return (bool) interceptor.Invoke("boundaryPointsValid", "boundaryPointsValid()", typeof(bool));
		}
		/// <remarks>
		///  Removes the contents of a range from the containing document or
		///  document fragment without returning a reference to the removed
		///  content.
		///      </remarks>		<short>    Removes the contents of a range from the containing document or  document fragment without returning a reference to the removed  content.</short>
		public void DeleteContents() {
			interceptor.Invoke("deleteContents", "deleteContents()", typeof(void));
		}
		/// <remarks>
		///  Moves the contents of a range from the containing document or
		///  document fragment to a new DocumentFragment.
		///   HIERARCHY_REQUEST_ERR: Raised if a DocumentType node would be
		///  extracted into the new DocumentFragment.
		///      </remarks>		<return> A DocumentFragment containing the extracted contents.
		/// </return>
		/// 		<short>    Moves the contents of a range from the containing document or  document fragment to a new DocumentFragment.</short>
		public DOM.DocumentFragment ExtractContents() {
			return (DOM.DocumentFragment) interceptor.Invoke("extractContents", "extractContents()", typeof(DOM.DocumentFragment));
		}
		/// <remarks>
		///  Duplicates the contents of a range
		///      </remarks>		<return> A DocumentFragment containing contents equivalent to
		///  those of this range.
		/// </return>
		/// 		<short>    Duplicates the contents of a range </short>
		public DOM.DocumentFragment CloneContents() {
			return (DOM.DocumentFragment) interceptor.Invoke("cloneContents", "cloneContents()", typeof(DOM.DocumentFragment));
		}
		/// <remarks>
		///  Inserts a node into the document or document fragment at the
		///  start of the range.
		/// <param> name="newNode" The node to insert at the start of the range
		/// </param>  WRONG_DOCUMENT_ERR: Raised if <code>newNode</code> and the
		///  container of the start of the Range were not created from the
		///  same document.
		///   HIERARCHY_REQUEST_ERR: Raised if the container of the start of
		///  the Range is of a type that does not allow children of the type
		///  of <code>newNode</code> or if <code>newNode</code> is an
		///  ancestor of the container .
		///      </remarks>		<short>    Inserts a node into the document or document fragment at the  start of the range.</short>
		public void InsertNode(DOM.Node newNode) {
			interceptor.Invoke("insertNode#", "insertNode(const DOM::Node&)", typeof(void), typeof(DOM.Node), newNode);
		}
		/// <remarks>
		///  Reparents the contents of the range to the given node and
		///  inserts the node at the position of the start of the range.
		/// <param> name="newParent" The node to surround the contents with.
		/// </param>  WRONG_DOCUMENT_ERR: Raised if <code>newParent</code> and the
		///  container of the start of the Range were not created from the
		///  same document.
		///   HIERARCHY_REQUEST_ERR: Raised if the container of the start of
		///  the Range is of a type that does not allow children of the type
		///  of <code>newParent</code> or if <code>newParent</code> is
		///  an ancestor of the container or if <code>node</code> would
		///  end up with a child node of a type not allowed by the type of
		///  <code>node</code> .
		///   INVALID_NODE_TYPE_ERR: Raised if <code>node</code> is an
		///  Attr, Entity, DocumentType, Notation, Document, or
		///  DocumentFragment node.
		///      </remarks>		<short>    Reparents the contents of the range to the given node and  inserts the node at the position of the start of the range.</short>
		public void SurroundContents(DOM.Node newParent) {
			interceptor.Invoke("surroundContents#", "surroundContents(const DOM::Node&)", typeof(void), typeof(DOM.Node), newParent);
		}
		/// <remarks>
		///  Produces a new range whose end-points are equal to the
		///  end-points of the range.
		///      </remarks>		<return> The duplicated range.
		/// </return>
		/// 		<short>    Produces a new range whose end-points are equal to the  end-points of the range.</short>
		public DOM.Range CloneRange() {
			return (DOM.Range) interceptor.Invoke("cloneRange", "cloneRange()", typeof(DOM.Range));
		}
		/// <remarks>
		///  Returns the contents of a range as a string.
		///      </remarks>		<return> The contents of the range.
		/// </return>
		/// 		<short>    Returns the contents of a range as a string.</short>
		public new DOM.DOMString ToString() {
			return (DOM.DOMString) interceptor.Invoke("toString", "toString()", typeof(DOM.DOMString));
		}
		/// <remarks>
		///      </remarks>		<short>   </short>
		public DOM.DOMString ToHTML() {
			return (DOM.DOMString) interceptor.Invoke("toHTML", "toHTML()", typeof(DOM.DOMString));
		}
		public DOM.DocumentFragment CreateContextualFragment(DOM.DOMString html) {
			return (DOM.DocumentFragment) interceptor.Invoke("createContextualFragment#", "createContextualFragment(const DOM::DOMString&)", typeof(DOM.DocumentFragment), typeof(DOM.DOMString), html);
		}
		/// <remarks>
		///  Called to indicate that the range is no longer in use and that
		///  the implementation may relinquish any resources associated with
		///  this range. Subsequent calls to any methods or attribute getters
		///  on this range will result in a DOMException being thrown with an
		///  error code of INVALID_STATE_ERR.
		///      </remarks>		<short>    Called to indicate that the range is no longer in use and that  the implementation may relinquish any resources associated with  this range.</short>
		public void Detach() {
			interceptor.Invoke("detach", "detach()", typeof(void));
		}
		/// <remarks>
		///  not part of the DOM
		///  true if the range is detached
		///      </remarks>		<short>    not part of the DOM  true if the range is detached </short>
		public bool IsDetached() {
			return (bool) interceptor.Invoke("isDetached", "isDetached() const", typeof(bool));
		}
		public bool IsNull() {
			return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
		}
		~Range() {
			interceptor.Invoke("~Range", "~Range()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~Range", "~Range()", typeof(void));
		}
	}
}
