//Auto-generated by kalyptus. DO NOT EDIT.
namespace DOM {
	using Kimono;
	using System;
	using Qyoto;
	/// <remarks>
	///  An <code>HTMLCollection</code> is a list of nodes. An individual
	///  node may be accessed by either ordinal index or the node's
	///  <code>name</code> or <code>id</code> attributes. Note: Collections in
	///  the HTML DOM are assumed to be live meaning that they are
	///  automatically updated when the underlying document is changed.
	///  </remarks>		<short>    An <code>HTMLCollection</code> is a list of nodes.</short>
	[SmokeClass("DOM::HTMLCollection")]
	public class HTMLCollection : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected HTMLCollection(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(HTMLCollection), this);
		}
		// DOM::HTMLCollection* HTMLCollection(DOM::HTMLCollectionImpl* arg1); >>>> NOT CONVERTED
		// DOM::HTMLCollection* HTMLCollection(DOM::NodeImpl* arg1,int arg2); >>>> NOT CONVERTED
		public HTMLCollection() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLCollection", "HTMLCollection()", typeof(void));
		}
		public HTMLCollection(DOM.HTMLCollection other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLCollection#", "HTMLCollection(const DOM::HTMLCollection&)", typeof(void), typeof(DOM.HTMLCollection), other);
		}
		/// <remarks>
		///  This attribute specifies the length or size of the list.
		///      </remarks>		<short>    This attribute specifies the length or size of the list.</short>
		public ulong Length() {
			return (ulong) interceptor.Invoke("length", "length() const", typeof(ulong));
		}
		/// <remarks>
		///  This method retrieves a node specified by ordinal index. Nodes
		///  are numbered in tree order (depth-first traversal order).
		/// <param> name="index" The index of the node to be fetched. The index
		///  origin is 0.
		/// </param>     </remarks>		<return> The <code>Node</code> at the corresponding position
		///  upon success. A value of <code>null</code> is returned if the
		///  index is out of range.
		/// </return>
		/// 		<short>    This method retrieves a node specified by ordinal index.</short>
		public DOM.Node Item(ulong index) {
			return (DOM.Node) interceptor.Invoke("item$", "item(unsigned long) const", typeof(DOM.Node), typeof(ulong), index);
		}
		/// <remarks>
		///  This method retrieves a <code>Node</code> using a name. It
		///  first searches for a <code>Node</code> with a matching
		///  <code>id</code> attribute. If it doesn't find one, it then searches
		///  for a <code>Node</code> with a matching <code>name</code>
		///  attribute, but only on those elements that are allowed a name
		///  attribute.
		/// <param> name="name" The name of the <code>Node</code> to be fetched.
		/// </param>     </remarks>		<return> The <code>Node</code> with a <code>name</code> or
		///  <code>id</code> attribute whose value corresponds to the
		///  specified string. Upon failure (e.g., no node with this name
		///  exists), returns <code>null</code> .
		/// </return>
		/// 		<short>    This method retrieves a <code>Node</code> using a name.</short>
		public DOM.Node NamedItem(DOM.DOMString name) {
			return (DOM.Node) interceptor.Invoke("namedItem#", "namedItem(const DOM::DOMString&) const", typeof(DOM.Node), typeof(DOM.DOMString), name);
		}
		/// <remarks>
		///  not part of the DOM
		///      </remarks>		<short>   </short>
		public DOM.Node Base() {
			return (DOM.Node) interceptor.Invoke("base", "base() const", typeof(DOM.Node));
		}
		public bool IsNull() {
			return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
		}
		public DOM.Node FirstItem() {
			return (DOM.Node) interceptor.Invoke("firstItem", "firstItem() const", typeof(DOM.Node));
		}
		public DOM.Node NextItem() {
			return (DOM.Node) interceptor.Invoke("nextItem", "nextItem() const", typeof(DOM.Node));
		}
		public DOM.Node NextNamedItem(DOM.DOMString name) {
			return (DOM.Node) interceptor.Invoke("nextNamedItem#", "nextNamedItem(const DOM::DOMString&) const", typeof(DOM.Node), typeof(DOM.DOMString), name);
		}
		~HTMLCollection() {
			interceptor.Invoke("~HTMLCollection", "~HTMLCollection()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~HTMLCollection", "~HTMLCollection()", typeof(void));
		}
	}
}
