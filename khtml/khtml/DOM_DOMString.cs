//Auto-generated by kalyptus. DO NOT EDIT.
namespace DOM {
	using Kimono;
	using System;
	using Qyoto;
	/// <remarks>
	///  This class implements the basic string we use in the DOM. We do not use
	///  string for 2 reasons: Memory overhead, and the missing explicit sharing
	///  of strings we need for the DOM.
	///  All DOMStrings are explicitly shared (they behave like pointers), meaning
	///  that modifications to one instance will also modify all others. If you
	///  wish to get a DOMString that is independent, use copy().
	///  </remarks>		<short>    This class implements the basic string we use in the DOM.</short>
	[SmokeClass("DOM::DOMString")]
	public class DOMString : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected DOMString(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(DOMString), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static DOMString() {
			staticInterceptor = new SmokeInvocation(typeof(DOMString), null);
		}
		// DOM::DOMString* DOMString(DOM::DOMStringImpl* arg1); >>>> NOT CONVERTED
		// DOM::DOMStringImpl* implementation(); >>>> NOT CONVERTED
		/// <remarks>
		///  default constructor. Gives an empty DOMString
		///      </remarks>		<short>    default constructor.</short>
		public DOMString() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("DOMString", "DOMString()", typeof(void));
		}
		public DOMString(QChar str, uint len) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("DOMString#$", "DOMString(const QChar*, uint)", typeof(void), typeof(QChar), str, typeof(uint), len);
		}
		public DOMString(string arg1) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("DOMString$", "DOMString(const QString&)", typeof(void), typeof(string), arg1);
		}
		public DOMString(DOM.DOMString str) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("DOMString#", "DOMString(const DOM::DOMString&)", typeof(void), typeof(DOM.DOMString), str);
		}
		/// <remarks>
		///  add two DOMString's
		///      </remarks>		<short>    add two DOMString's      </short>
		public void Insert(DOM.DOMString str, uint pos) {
			interceptor.Invoke("insert#$", "insert(DOM::DOMString, uint)", typeof(void), typeof(DOM.DOMString), str, typeof(uint), pos);
		}
		public int Find(QChar c, int start) {
			return (int) interceptor.Invoke("find#$", "find(const QChar, int) const", typeof(int), typeof(QChar), c, typeof(int), start);
		}
		public int Find(QChar c) {
			return (int) interceptor.Invoke("find#", "find(const QChar) const", typeof(int), typeof(QChar), c);
		}
		public uint Length() {
			return (uint) interceptor.Invoke("length", "length() const", typeof(uint));
		}
		public void Truncate(uint len) {
			interceptor.Invoke("truncate$", "truncate(unsigned int)", typeof(void), typeof(uint), len);
		}
		public void Remove(uint pos, int len) {
			interceptor.Invoke("remove$$", "remove(unsigned int, int)", typeof(void), typeof(uint), pos, typeof(int), len);
		}
		public void Remove(uint pos) {
			interceptor.Invoke("remove$", "remove(unsigned int)", typeof(void), typeof(uint), pos);
		}
		/// <remarks>
		///  Splits the string into two. The original string gets truncated to pos, and the rest is returned.
		///      </remarks>		<short>    Splits the string into two.</short>
		public DOM.DOMString Split(uint pos) {
			return (DOM.DOMString) interceptor.Invoke("split$", "split(unsigned int)", typeof(DOM.DOMString), typeof(uint), pos);
		}
		/// <remarks>
		///  Returns a lowercase version of the string
		///      </remarks>		<short>    Returns a lowercase version of the string      </short>
		public DOM.DOMString Lower() {
			return (DOM.DOMString) interceptor.Invoke("lower", "lower() const", typeof(DOM.DOMString));
		}
		/// <remarks>
		///  Returns an uppercase version of the string
		///      </remarks>		<short>    Returns an uppercase version of the string      </short>
		public DOM.DOMString Upper() {
			return (DOM.DOMString) interceptor.Invoke("upper", "upper() const", typeof(DOM.DOMString));
		}
		public QChar Unicode() {
			return (QChar) interceptor.Invoke("unicode", "unicode() const", typeof(QChar));
		}
		public QChar Characters() {
			return (QChar) interceptor.Invoke("characters", "characters() const", typeof(QChar));
		}
		public string String() {
			return (string) interceptor.Invoke("string", "string() const", typeof(string));
		}
		public int ToInt() {
			return (int) interceptor.Invoke("toInt", "toInt() const", typeof(int));
		}
		public int ToInt(ref bool ok) {
			StackItem[] stack = new StackItem[2];
			stack[1].s_bool = ok;
			interceptor.Invoke("toInt$", "toInt(bool*) const", stack);
			ok = stack[1].s_bool;
			return stack[0].s_int;
		}
		public float ToFloat(ref bool ok) {
			StackItem[] stack = new StackItem[2];
			stack[1].s_bool = ok;
			interceptor.Invoke("toFloat$", "toFloat(bool*) const", stack);
			ok = stack[1].s_bool;
			return stack[0].s_float;
		}
		public float ToFloat() {
			return (float) interceptor.Invoke("toFloat", "toFloat() const", typeof(float));
		}
		public bool Percentage(ref int _percentage) {
			StackItem[] stack = new StackItem[2];
			stack[1].s_int = _percentage;
			interceptor.Invoke("percentage$", "percentage(int&) const", stack);
			_percentage = stack[1].s_int;
			return stack[0].s_bool;
		}
		public DOM.DOMString Copy() {
			return (DOM.DOMString) interceptor.Invoke("copy", "copy() const", typeof(DOM.DOMString));
		}
		public bool IsNull() {
			return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
		}
		public bool IsEmpty() {
			return (bool) interceptor.Invoke("isEmpty", "isEmpty() const", typeof(bool));
		}
		public bool EndsWith(DOM.DOMString str) {
			return (bool) interceptor.Invoke("endsWith#", "endsWith(const DOM::DOMString&) const", typeof(bool), typeof(DOM.DOMString), str);
		}
		/// <remarks>
		///  Use at own risk!!!
		///      </remarks>		<short>   </short>
		~DOMString() {
			interceptor.Invoke("~DOMString", "~DOMString()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~DOMString", "~DOMString()", typeof(void));
		}
		public static DOM.DOMString operator+(DOMString lhs, DOM.DOMString str) {
			return (DOM.DOMString) staticInterceptor.Invoke("operator+#", "operator+(const DOM::DOMString&)", typeof(DOM.DOMString), typeof(DOMString), lhs, typeof(DOM.DOMString), str);
		}
		public static DOM.DOMString Number(float f) {
			return (DOM.DOMString) staticInterceptor.Invoke("number$", "number(float)", typeof(DOM.DOMString), typeof(float), f);
		}
	}
}
