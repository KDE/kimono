//Auto-generated by kalyptus. DO NOT EDIT.
namespace DOM {
	using Kimono;
	using System;
	using Qyoto;
	/// <remarks>
	///  An <code>HTMLDocument</code> is the root of the HTML hierarchy
	///  and holds the entire content. Beside providing access to the
	///  hierarchy, it also provides some convenience methods for accessing
	///  certain sets of information from the document.
	///   The following properties have been deprecated in favor of the
	///  corresponding ones for the BODY element:
	///   \li <code>alinkColor</code>
	///   \li <code>background</code>
	///   \li <code>bgColor</code>
	///   \li <code>fgColor</code>
	///   \li <code>linkColor</code>
	///   \li <code>vlinkColor</code>
	///  </remarks>		<short>    An <code>HTMLDocument</code> is the root of the HTML hierarchy  and holds the entire content.</short>
	[SmokeClass("DOM::HTMLDocument")]
	public class HTMLDocument : DOM.Document, IDisposable {
 		protected HTMLDocument(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(HTMLDocument), this);
		}
		// DOM::HTMLDocument* HTMLDocument(DOM::HTMLDocumentImpl* arg1); >>>> NOT CONVERTED
		public HTMLDocument() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLDocument", "HTMLDocument()", typeof(void));
		}
		/// <remarks>
		///  The parent is the widget the document should render itself in.
		///  Rendering information (like sizes, etc...) is only created if
		///  parent != 0
		///      </remarks>		<short>    The parent is the widget the document should render itself in.</short>
		public HTMLDocument(KHTMLView parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLDocument#", "HTMLDocument(KHTMLView*)", typeof(void), typeof(KHTMLView), parent);
		}
		public HTMLDocument(DOM.HTMLDocument other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLDocument#", "HTMLDocument(const DOM::HTMLDocument&)", typeof(void), typeof(DOM.HTMLDocument), other);
		}
		public HTMLDocument(DOM.Node other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLDocument#", "HTMLDocument(const DOM::Node&)", typeof(void), typeof(DOM.Node), other);
		}
		/// <remarks>
		///  The title of a document as specified by the <code>TITLE</code>
		///  element in the head of the document.
		///      </remarks>		<short>    The title of a document as specified by the <code>TITLE</code>  element in the head of the document.</short>
		public DOM.DOMString Title() {
			return (DOM.DOMString) interceptor.Invoke("title", "title() const", typeof(DOM.DOMString));
		}
		/// <remarks>
		///  see title
		///      </remarks>		<short>    see title      </short>
		public void SetTitle(DOM.DOMString arg1) {
			interceptor.Invoke("setTitle#", "setTitle(const DOM::DOMString&)", typeof(void), typeof(DOM.DOMString), arg1);
		}
		/// <remarks>
		///  Returns the URI of the page that linked to this page. The value
		///  is an empty string if the user navigated to the page directly
		///  (not through a link, but, for example, via a bookmark).
		///      </remarks>		<short>    Returns the URI of the page that linked to this page.</short>
		public DOM.DOMString Referrer() {
			return (DOM.DOMString) interceptor.Invoke("referrer", "referrer() const", typeof(DOM.DOMString));
		}
		/// <remarks>
		///  The domain name of the server that served the document, or a
		///  null string if the server cannot be identified by a domain
		///  name.
		///      </remarks>		<short>    The domain name of the server that served the document, or a  null string if the server cannot be identified by a domain  name.</short>
		public DOM.DOMString Domain() {
			return (DOM.DOMString) interceptor.Invoke("domain", "domain() const", typeof(DOM.DOMString));
		}
		/// <remarks>
		///  The absolute URI of the document.
		///      </remarks>		<short>    The absolute URI of the document.</short>
		public DOM.DOMString URL() {
			return (DOM.DOMString) interceptor.Invoke("URL", "URL() const", typeof(DOM.DOMString));
		}
		/// <remarks>
		///  The element that contains the content for the document. In
		///  documents with <code>BODY</code> contents, returns the
		///  <code>BODY</code> element, and in frameset documents, this returns
		///  the outermost <code>FRAMESET</code> element.
		///      </remarks>		<short>    The element that contains the content for the document.</short>
		public DOM.HTMLElement Body() {
			return (DOM.HTMLElement) interceptor.Invoke("body", "body() const", typeof(DOM.HTMLElement));
		}
		/// <remarks>
		///  see body
		///      </remarks>		<short>    see body      </short>
		public void SetBody(DOM.HTMLElement arg1) {
			interceptor.Invoke("setBody#", "setBody(const DOM::HTMLElement&)", typeof(void), typeof(DOM.HTMLElement), arg1);
		}
		/// <remarks>
		///  A collection of all the <code>IMG</code> elements in a
		///  document. The behavior is limited to <code>IMG</code>
		///  elements for backwards compatibility.
		///      </remarks>		<short>    A collection of all the <code>IMG</code> elements in a  document.</short>
		public DOM.HTMLCollection Images() {
			return (DOM.HTMLCollection) interceptor.Invoke("images", "images() const", typeof(DOM.HTMLCollection));
		}
		/// <remarks>
		///  A collection of all the <code>OBJECT</code> elements that
		///  include applets and <code>APPLET</code> ( deprecated )
		///  elements in a document.
		///      </remarks>		<short>    A collection of all the <code>OBJECT</code> elements that  include applets and <code>APPLET</code> ( deprecated )  elements in a document.</short>
		public DOM.HTMLCollection Applets() {
			return (DOM.HTMLCollection) interceptor.Invoke("applets", "applets() const", typeof(DOM.HTMLCollection));
		}
		/// <remarks>
		///  A collection of all <code>AREA</code> elements and anchor (
		///  <code>A</code> ) elements in a document with a value for the
		///  <code>href</code> attribute.
		///      </remarks>		<short>    A collection of all <code>AREA</code> elements and anchor (  <code>A</code> ) elements in a document with a value for the  <code>href</code> attribute.</short>
		public DOM.HTMLCollection Links() {
			return (DOM.HTMLCollection) interceptor.Invoke("links", "links() const", typeof(DOM.HTMLCollection));
		}
		/// <remarks>
		///  A collection of all the forms of a document.
		///      </remarks>		<short>    A collection of all the forms of a document.</short>
		public DOM.HTMLCollection Forms() {
			return (DOM.HTMLCollection) interceptor.Invoke("forms", "forms() const", typeof(DOM.HTMLCollection));
		}
		/// <remarks>
		///  A collection of all the layers of a document.
		///      </remarks>		<short>    A collection of all the layers of a document.</short>
		public DOM.HTMLCollection Layers() {
			return (DOM.HTMLCollection) interceptor.Invoke("layers", "layers() const", typeof(DOM.HTMLCollection));
		}
		/// <remarks>
		///  A collection of all the scripts in the document.
		///      </remarks>		<short>    A collection of all the scripts in the document.</short>
		public DOM.HTMLCollection Scripts() {
			return (DOM.HTMLCollection) interceptor.Invoke("scripts", "scripts() const", typeof(DOM.HTMLCollection));
		}
		/// <remarks>
		///  A collection of all the anchor ( <code>A</code> ) elements in
		///  a document with a value for the <code>name</code> attribute.
		///  Note. For reasons of backwards compatibility, the returned set
		///  of anchors only contains those anchors created with the
		///  <code>name</code> attribute, not those created with the <code>id</code>
		///  attribute.
		///      </remarks>		<short>    A collection of all the anchor ( <code>A</code> ) elements in  a document with a value for the <code>name</code> attribute.</short>
		public DOM.HTMLCollection Anchors() {
			return (DOM.HTMLCollection) interceptor.Invoke("anchors", "anchors() const", typeof(DOM.HTMLCollection));
		}
		/// <remarks>
		///  The cookies associated with this document. If there are none,
		///  the value is an empty string. Otherwise, the value is a string:
		///  a semicolon-delimited list of "name, value" pairs for all the
		///  cookies associated with the page. For example,
		///  <code>name</code>=value;expires=date .
		///      </remarks>		<short>    The cookies associated with this document.</short>
		public DOM.DOMString Cookie() {
			return (DOM.DOMString) interceptor.Invoke("cookie", "cookie() const", typeof(DOM.DOMString));
		}
		/// <remarks>
		///  see cookie
		///      </remarks>		<short>    see cookie      </short>
		public void SetCookie(DOM.DOMString arg1) {
			interceptor.Invoke("setCookie#", "setCookie(const DOM::DOMString&)", typeof(void), typeof(DOM.DOMString), arg1);
		}
		/// <remarks>
		///  Note. This method and the ones following allow a user to add to
		///  or replace the structure model of a document using strings of
		///  unparsed HTML. At the time of writing alternate methods for
		///  providing similar functionality for both HTML and XML documents
		///  were being considered. The following methods may be deprecated
		///  at some point in the future in favor of a more general-purpose
		///  mechanism.
		///   Open a document stream for writing. If a document exists in
		///  the target, this method clears it.
		///      </remarks>		<short>    Note.</short>
		public void Open() {
			interceptor.Invoke("open", "open()", typeof(void));
		}
		/// <remarks>
		///  Closes a document stream opened by <code>open</code>() and
		///  forces rendering.
		///      </remarks>		<short>    Closes a document stream opened by <code>open</code>() and  forces rendering.</short>
		public void Close() {
			interceptor.Invoke("close", "close()", typeof(void));
		}
		/// <remarks>
		///  Write a string of text to a document stream opened by
		///  <code>open</code>() . The text is parsed into the document's
		///  structure model.
		/// <param> name="text" The string to be parsed into some structure in the
		///  document structure model.
		/// </param>     </remarks>		<short>    Write a string of text to a document stream opened by  <code>open</code>() .</short>
		public void Write(DOM.DOMString text) {
			interceptor.Invoke("write#", "write(const DOM::DOMString&)", typeof(void), typeof(DOM.DOMString), text);
		}
		/// <remarks>
		///  Write a string of text followed by a newline character to a
		///  document stream opened by <code>open</code>() . The text is
		///  parsed into the document's structure model.
		/// <param> name="text" The string to be parsed into some structure in the
		///  document structure model.
		/// </param>     </remarks>		<short>    Write a string of text followed by a newline character to a  document stream opened by <code>open</code>() .</short>
		public void Writeln(DOM.DOMString text) {
			interceptor.Invoke("writeln#", "writeln(const DOM::DOMString&)", typeof(void), typeof(DOM.DOMString), text);
		}
		/// <remarks>
		///  Returns the (possibly empty) collection of elements whose
		///  <code>name</code> value is given by <code>elementName</code> .
		/// <param> name="elementName" The <code>name</code> attribute value for
		///  an element.
		/// </param>     </remarks>		<return> The matching elements.
		/// </return>
		/// 		<short>    Returns the (possibly empty) collection of elements whose  <code>name</code> value is given by <code>elementName</code> .</short>
		public DOM.NodeList GetElementsByName(DOM.DOMString elementName) {
			return (DOM.NodeList) interceptor.Invoke("getElementsByName#", "getElementsByName(const DOM::DOMString&)", typeof(DOM.NodeList), typeof(DOM.DOMString), elementName);
		}
		/// <remarks>
		///  not part of the DOM
		///  converts the given (potentially relative) URL in a
		///  full-qualified one, using the baseURL / document URL for
		///  the missing parts.
		///      </remarks>		<short>    not part of the DOM </short>
		public DOM.DOMString CompleteURL(DOM.DOMString url) {
			return (DOM.DOMString) interceptor.Invoke("completeURL#", "completeURL(const DOM::DOMString&) const", typeof(DOM.DOMString), typeof(DOM.DOMString), url);
		}
		/// <remarks>
		///  Not part of the DOM
		///  The date the document was last modified.
		///      </remarks>		<short>    Not part of the DOM </short>
		public DOM.DOMString LastModified() {
			return (DOM.DOMString) interceptor.Invoke("lastModified", "lastModified() const", typeof(DOM.DOMString));
		}
		/// <remarks>
		///  Not part of the DOM
		///  A collection of all the <code>IMG</code>, <code>OBJECT</code>,
		///  <code>AREA</code>, <code>A</code>, forms and anchor elements of
		///  a document.
		///      </remarks>		<short>    Not part of the DOM </short>
		public DOM.HTMLCollection All() {
			return (DOM.HTMLCollection) interceptor.Invoke("all", "all() const", typeof(DOM.HTMLCollection));
		}
		~HTMLDocument() {
			interceptor.Invoke("~HTMLDocument", "~HTMLDocument()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~HTMLDocument", "~HTMLDocument()", typeof(void));
		}
	}
}
