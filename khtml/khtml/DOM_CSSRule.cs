//Auto-generated by kalyptus. DO NOT EDIT.
namespace DOM {
	using Kimono;
	using System;
	using Qyoto;
	/// <remarks>
	///  The <code>CSSRule</code> interface is the abstract base interface
	///  for any type of CSS <a
	///  href="http://www.w3.org/TR/REC-CSS2/syndata.html#q5"> statement
	///  </a> . This includes both <a
	///  href="http://www.w3.org/TR/REC-CSS2/syndata.html#q8"> rule sets
	///  </a> and <a
	///  href="http://www.w3.org/TR/REC-CSS2/syndata.html#at-rules">
	///  at-rules </a> . An implementation is expected to preserve all rules
	///  specified in a CSS style sheet, even if it is not recognized.
	///  Unrecognized rules are represented using the <code>CSSUnknownRule</code>
	///  interface.
	///  </remarks>		<short>    The <code>CSSRule</code> interface is the abstract base interface  for any type of CSS <a  href="http://www.</short>
	[SmokeClass("DOM::CSSRule")]
	public class CSSRule : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected CSSRule(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(CSSRule), this);
		}
		/// <remarks>
		///  An integer indicating which type of rule this is.
		///      </remarks>		<short>    An integer indicating which type of rule this is.</short>
		public enum RuleType {
			UNKNOWN_RULE = 0,
			STYLE_RULE = 1,
			CHARSET_RULE = 2,
			IMPORT_RULE = 3,
			MEDIA_RULE = 4,
			FONT_FACE_RULE = 5,
			PAGE_RULE = 6,
			QUIRKS_RULE = 100,
		}
		// DOM::CSSRule* CSSRule(DOM::CSSRuleImpl* arg1); >>>> NOT CONVERTED
		public CSSRule() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("CSSRule", "CSSRule()", typeof(void));
		}
		public CSSRule(DOM.CSSRule other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("CSSRule#", "CSSRule(const DOM::CSSRule&)", typeof(void), typeof(DOM.CSSRule), other);
		}
		/// <remarks>
		///  The type of the rule, as defined above. The expectation is that
		///  binding-specific casting methods can be used to cast down from
		///  an instance of the <code>CSSRule</code> interface to the
		///  specific derived interface implied by the <code>type</code> .
		///      </remarks>		<short>    The type of the rule, as defined above.</short>
		public ushort type() {
			return (ushort) interceptor.Invoke("type", "type() const", typeof(ushort));
		}
		/// <remarks>
		///  The parsable textual representation of the rule. This reflects
		///  the current state of the rule and not its initial value.
		///      </remarks>		<short>    The parsable textual representation of the rule.</short>
		public DOM.DOMString CssText() {
			return (DOM.DOMString) interceptor.Invoke("cssText", "cssText() const", typeof(DOM.DOMString));
		}
		/// <remarks>
		///  see cssText
		///   HIERARCHY_REQUEST_ERR: Raised if the rule cannot be inserted
		///  at this point in the style sheet.
		///   NO_MODIFICATION_ALLOWED_ERR: Raised if this style sheet is
		///  readonly.
		///  INVALID_MODIFICATION_ERR: Raised if the specified CSS string value
		///  represents a different type of rule than the current one.
		///      </remarks>		<short>    see cssText </short>
		public void SetCssText(DOM.DOMString arg1) {
			interceptor.Invoke("setCssText#", "setCssText(const DOM::DOMString&)", typeof(void), typeof(DOM.DOMString), arg1);
		}
		/// <remarks>
		///  The style sheet that contains this rule.
		///      </remarks>		<short>    The style sheet that contains this rule.</short>
		public DOM.CSSStyleSheet ParentStyleSheet() {
			return (DOM.CSSStyleSheet) interceptor.Invoke("parentStyleSheet", "parentStyleSheet() const", typeof(DOM.CSSStyleSheet));
		}
		/// <remarks>
		///  If this rule is contained inside another rule (e.g. a style
		///  rule inside an \@media block), this is the containing rule. If
		///  this rule is not nested inside any other rules, this returns
		///  <code>null</code> .
		///      </remarks>		<short>    If this rule is contained inside another rule (e.</short>
		public DOM.CSSRule ParentRule() {
			return (DOM.CSSRule) interceptor.Invoke("parentRule", "parentRule() const", typeof(DOM.CSSRule));
		}
		public bool IsNull() {
			return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
		}
		protected void AssignOther(DOM.CSSRule other, DOM.CSSRule.RuleType thisType) {
			interceptor.Invoke("assignOther#$", "assignOther(const DOM::CSSRule&, DOM::CSSRule::RuleType)", typeof(void), typeof(DOM.CSSRule), other, typeof(DOM.CSSRule.RuleType), thisType);
		}
		~CSSRule() {
			interceptor.Invoke("~CSSRule", "~CSSRule()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~CSSRule", "~CSSRule()", typeof(void));
		}
	}
}
