//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano {
    using Soprano;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    [SmokeClass("Soprano::QueryResultIterator")]
    public class QueryResultIterator : Soprano.Iterator, IDisposable {
        protected QueryResultIterator(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(QueryResultIterator), this);
        }
        // Soprano::QueryResultIterator* QueryResultIterator(Soprano::QueryResultIteratorBackend* arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Creates and empty, invalid iterator.
        ///          </remarks>        <short>    Creates and empty, invalid iterator.</short>
        public QueryResultIterator() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QueryResultIterator", "QueryResultIterator()", typeof(void));
        }
        /// <remarks>
        ///  Copy constructor. Copies of iterators share their data.
        ///          </remarks>        <short>    Copy constructor.</short>
        public QueryResultIterator(Soprano.QueryResultIterator arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QueryResultIterator#", "QueryResultIterator(const Soprano::QueryResultIterator&)", typeof(void), typeof(Soprano.QueryResultIterator), arg1);
        }
        /// <remarks>
        ///  Retrieve the current Statement after a call to next.
        ///  This method does only make sense for graph queries.
        ///          </remarks>        <short>    Retrieve the current Statement after a call to next.</short>
        public Soprano.Statement CurrentStatement() {
            return (Soprano.Statement) interceptor.Invoke("currentStatement", "currentStatement() const", typeof(Soprano.Statement));
        }
        /// <remarks>
        ///  Convenience method that puts all current bindings into one map.
        ///  This method does only make sense for tuple queries.
        ///          </remarks>        <short>    Convenience method that puts all current bindings into one map.</short>
        public Soprano.BindingSet CurrentBindings() {
            return (Soprano.BindingSet) interceptor.Invoke("currentBindings", "currentBindings() const", typeof(Soprano.BindingSet));
        }
        /// <remarks>
        ///  This method does only make sense for boolean queries.
        ///  \return The result of a boolean query (SPARQL ASK).
        ///  \sa isBool()
        ///          </remarks>        <short>    This method does only make sense for boolean queries.</short>
        public bool BoolValue() {
            return (bool) interceptor.Invoke("boolValue", "boolValue() const", typeof(bool));
        }
        /// <remarks>
        ///  Get the current binding for a variable.
        ///  \param name The name of the requested variable.
        ///  This method does only make sense for tuple queries.
        ///  \return The binding for the requested variable or and invalid
        ///  node if the bindings do not contain the variable.
        ///          </remarks>        <short>    Get the current binding for a variable.</short>
        public Soprano.Node Binding(string name) {
            return (Soprano.Node) interceptor.Invoke("binding$", "binding(const QString&) const", typeof(Soprano.Node), typeof(string), name);
        }
        /// <remarks>
        ///  Get the current binding for a variable by index.
        ///  \param offset The index of the requested variable.
        ///  This method does only make sense for tuple queries.
        ///  \return The binding for the requested variable or and invalid
        ///  node if offset is out of bounds, i.e. bigger or equal to bindingCount().
        ///          </remarks>        <short>    Get the current binding for a variable by index.</short>
        public Soprano.Node Binding(int offset) {
            return (Soprano.Node) interceptor.Invoke("binding$", "binding(int) const", typeof(Soprano.Node), typeof(int), offset);
        }
        /// <remarks>
        ///  The number of bindings in this query result.
        ///  This method does only make sense for tuple queries.
        ///  \return The number of bindings.
        ///          </remarks>        <short>    The number of bindings in this query result.</short>
        public int BindingCount() {
            return (int) interceptor.Invoke("bindingCount", "bindingCount() const", typeof(int));
        }
        /// <remarks>
        ///  This method does only make sense for tuple queries.
        ///  \return The names of the bound variables in this query result.
        ///          </remarks>        <short>    This method does only make sense for tuple queries.</short>
        public List<string> BindingNames() {
            return (List<string>) interceptor.Invoke("bindingNames", "bindingNames() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Check if this is a graph result.
        ///  \return <pre>true</pre> if this result refers to a graph query, i.e. currentStatement()
        ///  and iterateStatements() return valid values.
        ///          </remarks>        <short>    Check if this is a graph result.</short>
        public bool IsGraph() {
            return (bool) interceptor.Invoke("isGraph", "isGraph() const", typeof(bool));
        }
        /// <remarks>
        ///  Check if this is a tuple result.
        ///  \return <pre>true</pre> if this result refers to a tuple query, i.e. currentBindings(),
        ///  binding(), bindingCount(), bindingNames(), and allBindings() return valid values.
        ///          </remarks>        <short>    Check if this is a tuple result.</short>
        public bool IsBinding() {
            return (bool) interceptor.Invoke("isBinding", "isBinding() const", typeof(bool));
        }
        /// <remarks>
        ///  Check if this is a boolean result.
        ///  There is no need to call next() for boolean results. However, for internal reasons
        ///  backends need to always return <pre>true</pre> for boolean queries.
        ///  \return <pre>true</pre> if this result refers to a boolean query (SPARQL ASK), i.e.
        ///  boolValue() returns a valid value.
        ///          </remarks>        <short>    Check if this is a boolean result.</short>
        public bool IsBool() {
            return (bool) interceptor.Invoke("isBool", "isBool() const", typeof(bool));
        }
        /// <remarks>
        ///  Convenience method that collects all binding sets that are left
        ///  in the iterator.
        ///          </remarks>        <short>    Convenience method that collects all binding sets that are left  in the iterator.</short>
        public List<Soprano.BindingSet> AllBindings() {
            return (List<Soprano.BindingSet>) interceptor.Invoke("allBindings", "allBindings()", typeof(List<Soprano.BindingSet>));
        }
        /// <remarks>
        ///  Convenience method that creates an iterator over the statements in this query result.
        ///  This method does only make sense for graph queries.
        ///  \warning The new iterator is just a wrapper around this one. Thus, changing it will also
        ///  change this one.
        ///  \return A wrapper iterator over the statements in a graph query.
        ///          </remarks>        <short>    Convenience method that creates an iterator over the statements in this query result.</short>
        public Soprano.StatementIterator IterateStatements() {
            return (Soprano.StatementIterator) interceptor.Invoke("iterateStatements", "iterateStatements() const", typeof(Soprano.StatementIterator));
        }
        /// <remarks>
        ///  Convenience method that creates an iterator over one column of bindings in this query result.
        ///  This method does only make sense for tuple queries.
        ///  \param variableName The name of the requested variable.
        ///  \warning The new iterator is just a wrapper around this one. Thus, changing it will also
        ///  change this one.
        ///  \return A wrapper iterator over one column in a tuple query or an invalid iterator if the
        ///  result does not contain bindings for variableName.
        ///          </remarks>        <short>    Convenience method that creates an iterator over one column of bindings in this query result.</short>
        public Soprano.NodeIterator IterateBindings(string variableName) {
            return (Soprano.NodeIterator) interceptor.Invoke("iterateBindings$", "iterateBindings(const QString&) const", typeof(Soprano.NodeIterator), typeof(string), variableName);
        }
        /// <remarks>
        ///  Convenience method that creates an iterator over one column of bindings in this query result.
        ///  This method does only make sense for tuple queries.
        ///  \param offset The index of the requested variable.
        ///  \warning The new iterator is just a wrapper around this one. Thus, changing it will also
        ///  change this one.
        ///  \return A wrapper iterator over one column in a tuple query or an invalid iterator
        ///  if offset is out of bounds, i.e. bigger or equal to bindingCount().
        ///          </remarks>        <short>    Convenience method that creates an iterator over one column of bindings in this query result.</short>
        public Soprano.NodeIterator IterateBindings(int offset) {
            return (Soprano.NodeIterator) interceptor.Invoke("iterateBindings$", "iterateBindings(int) const", typeof(Soprano.NodeIterator), typeof(int), offset);
        }
        ~QueryResultIterator() {
            interceptor.Invoke("~QueryResultIterator", "~QueryResultIterator()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~QueryResultIterator", "~QueryResultIterator()", typeof(void));
        }
    }
}
