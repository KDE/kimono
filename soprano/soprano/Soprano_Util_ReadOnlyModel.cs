//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano.Util {
    using Soprano;
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class ReadOnlyModel readonlymodel.h Soprano/Util/ReadOnlyModel
    ///  \brief Simple filter model preventing any write operations.
    ///  Stacking a ReadOnlyModel on top of another model will prevent
    ///  any write operation to be performed. All calls to non-const methods
    ///  are terminated by Error.ErrorPermissionDenied.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///  \since 2.1
    ///          </remarks>        <short>    \class ReadOnlyModel readonlymodel.</short>
    [SmokeClass("Soprano::Util::ReadOnlyModel")]
    public class ReadOnlyModel : Soprano.Model, IDisposable {
        protected ReadOnlyModel(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(ReadOnlyModel), this);
        }
        /// <remarks>
        ///  Create a new read-only-model
        ///  \param parentModel The parent Model.
        ///              </remarks>        <short>    Create a new read-only-model  \param parentModel The parent Model.</short>
        public ReadOnlyModel(Soprano.Model parentModel) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ReadOnlyModel#", "ReadOnlyModel(Soprano::Model*)", typeof(void), typeof(Soprano.Model), parentModel);
        }
        public ReadOnlyModel() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ReadOnlyModel", "ReadOnlyModel()", typeof(void));
        }
        /// <remarks>
        ///  Set the parent Model.
        ///  \param model The Model that this filter will forward any commands to.
        ///              </remarks>        <short>    Set the parent Model.</short>
        public void SetParentModel(Soprano.Model model) {
            interceptor.Invoke("setParentModel#", "setParentModel(Soprano::Model*)", typeof(void), typeof(Soprano.Model), model);
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///              </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("listStatements(const Soprano::Statement&) const")]
        public override Soprano.StatementIterator ListStatements(Soprano.Statement partial) {
            return (Soprano.StatementIterator) interceptor.Invoke("listStatements#", "listStatements(const Soprano::Statement&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Statement), partial);
        }
        /// <remarks>
        ///  Simply pipes the call through to the parent model.
        ///              </remarks>        <short>    Simply pipes the call through to the parent model.</short>
        [SmokeMethod("listContexts() const")]
        public override Soprano.NodeIterator ListContexts() {
            return (Soprano.NodeIterator) interceptor.Invoke("listContexts", "listContexts() const", typeof(Soprano.NodeIterator));
        }
        /// <remarks>
        ///  Simply pipes the call through to the parent model.
        ///              </remarks>        <short>    Simply pipes the call through to the parent model.</short>
        [SmokeMethod("executeQuery(const QString&, Soprano::Query::QueryLanguage, const QString&) const")]
        public override Soprano.QueryResultIterator ExecuteQuery(string query, Soprano.Query.QueryLanguage language, string userQueryLanguage) {
            return (Soprano.QueryResultIterator) interceptor.Invoke("executeQuery$$$", "executeQuery(const QString&, Soprano::Query::QueryLanguage, const QString&) const", typeof(Soprano.QueryResultIterator), typeof(string), query, typeof(Soprano.Query.QueryLanguage), language, typeof(string), userQueryLanguage);
        }
        [SmokeMethod("executeQuery(const QString&, Soprano::Query::QueryLanguage) const")]
        public virtual Soprano.QueryResultIterator ExecuteQuery(string query, Soprano.Query.QueryLanguage language) {
            return (Soprano.QueryResultIterator) interceptor.Invoke("executeQuery$$", "executeQuery(const QString&, Soprano::Query::QueryLanguage) const", typeof(Soprano.QueryResultIterator), typeof(string), query, typeof(Soprano.Query.QueryLanguage), language);
        }
        /// <remarks>
        ///  Simply pipes the call through to the parent model.
        ///              </remarks>        <short>    Simply pipes the call through to the parent model.</short>
        [SmokeMethod("containsStatement(const Soprano::Statement&) const")]
        public override bool ContainsStatement(Soprano.Statement statement) {
            return (bool) interceptor.Invoke("containsStatement#", "containsStatement(const Soprano::Statement&) const", typeof(bool), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Simply pipes the call through to the parent model.
        ///              </remarks>        <short>    Simply pipes the call through to the parent model.</short>
        [SmokeMethod("containsAnyStatement(const Soprano::Statement&) const")]
        public override bool ContainsAnyStatement(Soprano.Statement statement) {
            return (bool) interceptor.Invoke("containsAnyStatement#", "containsAnyStatement(const Soprano::Statement&) const", typeof(bool), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Simply pipes the call through to the parent model.
        ///              </remarks>        <short>    Simply pipes the call through to the parent model.</short>
        [SmokeMethod("isEmpty() const")]
        public override bool IsEmpty() {
            return (bool) interceptor.Invoke("isEmpty", "isEmpty() const", typeof(bool));
        }
        /// <remarks>
        ///  Simply pipes the call through to the parent model.
        ///              </remarks>        <short>    Simply pipes the call through to the parent model.</short>
        [SmokeMethod("statementCount() const")]
        public override int StatementCount() {
            return (int) interceptor.Invoke("statementCount", "statementCount() const", typeof(int));
        }
        /// <remarks>
        ///  Will do nothing but set an Error.ErrorPermissionDenied error.
        ///              </remarks>        <short>    Will do nothing but set an Error.ErrorPermissionDenied error.</short>
        [SmokeMethod("addStatement(const Soprano::Statement&)")]
        public override Soprano.Error.ErrorCode AddStatement(Soprano.Statement statement) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("addStatement#", "addStatement(const Soprano::Statement&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Will do nothing but set an Error.ErrorPermissionDenied error.
        ///              </remarks>        <short>    Will do nothing but set an Error.ErrorPermissionDenied error.</short>
        [SmokeMethod("removeStatement(const Soprano::Statement&)")]
        public override Soprano.Error.ErrorCode RemoveStatement(Soprano.Statement statement) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("removeStatement#", "removeStatement(const Soprano::Statement&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Will do nothing but set an Error.ErrorPermissionDenied error.
        ///              </remarks>        <short>    Will do nothing but set an Error.ErrorPermissionDenied error.</short>
        [SmokeMethod("removeAllStatements(const Soprano::Statement&)")]
        public override Soprano.Error.ErrorCode RemoveAllStatements(Soprano.Statement statement) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("removeAllStatements#", "removeAllStatements(const Soprano::Statement&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Will do nothing but set an Error.ErrorPermissionDenied error.
        ///              </remarks>        <short>    Will do nothing but set an Error.ErrorPermissionDenied error.</short>
        [SmokeMethod("createBlankNode()")]
        public override Soprano.Node CreateBlankNode() {
            return (Soprano.Node) interceptor.Invoke("createBlankNode", "createBlankNode()", typeof(Soprano.Node));
        }
        ~ReadOnlyModel() {
            interceptor.Invoke("~ReadOnlyModel", "~ReadOnlyModel()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~ReadOnlyModel", "~ReadOnlyModel()", typeof(void));
        }
        protected new IReadOnlyModelSignals Emit {
            get { return (IReadOnlyModelSignals) Q_EMIT; }
        }
    }

    public interface IReadOnlyModelSignals : Soprano.IModelSignals {
    }
}
