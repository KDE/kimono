//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano.Inference {
    using Soprano;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  \class Rule inferencerule.h Soprano/Inference/Rule
    ///  \brief A rule used by the InferenceModel to generate inferenced statements.
    ///  Rules can be created manually by adding preconditions and the effect via addPrecondition() and
    ///  setEffect() or from a rules file through the RuleParser.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///          </remarks>        <short>    \class Rule inferencerule.</short>
    [SmokeClass("Soprano::Inference::Rule")]
    public class Rule : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected Rule(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Rule), this);
        }
        public Rule() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Rule", "Rule()", typeof(void));
        }
        public Rule(Soprano.Inference.Rule other) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Rule#", "Rule(const Soprano::Inference::Rule&)", typeof(void), typeof(Soprano.Inference.Rule), other);
        }
        /// <remarks>
        ///  The list of preconditions for the rule. Each condition
        ///  is a StatementPattern which can contain variables.
        ///  These variables are identified by their name and matched
        ///  accordingly.
        ///              </remarks>        <short>    The list of preconditions for the rule.</short>
        public List<Soprano.Inference.StatementPattern> Preconditions() {
            return (List<Soprano.Inference.StatementPattern>) interceptor.Invoke("preconditions", "preconditions() const", typeof(List<Soprano.Inference.StatementPattern>));
        }
        public void AddPrecondition(Soprano.Inference.StatementPattern arg1) {
            interceptor.Invoke("addPrecondition#", "addPrecondition(const Soprano::Inference::StatementPattern&)", typeof(void), typeof(Soprano.Inference.StatementPattern), arg1);
        }
        /// <remarks>
        ///  The effect of a rule is a pattern that repeats variables from
        ///  the preconditions and thus, identifies the statements that
        ///  are to be infered from the preconditions.
        ///              </remarks>        <short>    The effect of a rule is a pattern that repeats variables from  the preconditions and thus, identifies the statements that  are to be infered from the preconditions.</short>
        public Soprano.Inference.StatementPattern Effect() {
            return (Soprano.Inference.StatementPattern) interceptor.Invoke("effect", "effect() const", typeof(Soprano.Inference.StatementPattern));
        }
        public void SetEffect(Soprano.Inference.StatementPattern arg1) {
            interceptor.Invoke("setEffect#", "setEffect(const Soprano::Inference::StatementPattern&)", typeof(void), typeof(Soprano.Inference.StatementPattern), arg1);
        }
        /// <remarks>
        ///  Check if a statement matches any of the statement patterns
        ///  in this rule.
        ///  \return true if statement matches any of the patterns, false otherwise.
        ///              </remarks>        <short>    Check if a statement matches any of the statement patterns  in this rule.</short>
        public bool Match(Soprano.Statement statement) {
            return (bool) interceptor.Invoke("match#", "match(const Soprano::Statement&) const", typeof(bool), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Bind this rule to a specific Statement.
        ///  The purpose of this method is to allow retricting the application of
        ///  a rule to one statement, i.e. a newly added one.
        ///  \param statement The Statement to bind this rule to.
        ///  \sa createSparqlQuery, bindEffect, bindPreconditions
        ///              </remarks>        <short>    Bind this rule to a specific Statement.</short>
        public void BindToStatement(Soprano.Statement statement) {
            interceptor.Invoke("bindToStatement#", "bindToStatement(const Soprano::Statement&)", typeof(void), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Create a SPARQL query that retrieves all resources matching this rule.
        ///  \param bindVariables If true and a valid binding statement is set the query
        ///  will be bound to this statement resulting in a UNION query of all possible
        ///  bindings.
        ///  \sa bindToStatement
        ///              </remarks>        <short>    Create a SPARQL query that retrieves all resources matching this rule.</short>
        public string CreateSparqlQuery(bool bindVariables) {
            return (string) interceptor.Invoke("createSparqlQuery$", "createSparqlQuery(bool) const", typeof(string), typeof(bool), bindVariables);
        }
        public string CreateSparqlQuery() {
            return (string) interceptor.Invoke("createSparqlQuery", "createSparqlQuery() const", typeof(string));
        }
        /// <remarks>
        ///  Bind the rule's effect to a set of bindings as reveived from a query.
        ///  If the bindings do not contain all variables the bound statement is used as backup.
        ///  \param bindings The bindings to apply to this rule.
        ///  \return The statement infered by this rule under the application of bindings.
        ///  \sa bindToStatement, bindPreconditions
        ///              </remarks>        <short>    Bind the rule's effect to a set of bindings as reveived from a query.</short>
        public Soprano.Statement BindEffect(Soprano.BindingSet bindings) {
            return (Soprano.Statement) interceptor.Invoke("bindEffect#", "bindEffect(const Soprano::BindingSet&) const", typeof(Soprano.Statement), typeof(Soprano.BindingSet), bindings);
        }
        /// <remarks>
        ///  Bind the rule's preconditions to a set of bindings as reveived from a query.
        ///  If the bindings do not contain all variables the bound statement is used as backup.
        ///  \param bindings The bindings to apply to this rule.
        ///  \return The statements that have to be valid in order for this rule to infer the statement
        ///  returned by bindEffect under the same bindings.
        ///  \sa bindToStatement, bindEffect
        ///              </remarks>        <short>    Bind the rule's preconditions to a set of bindings as reveived from a query.</short>
        public List<Soprano.Statement> BindPreconditions(Soprano.BindingSet bindings) {
            return (List<Soprano.Statement>) interceptor.Invoke("bindPreconditions#", "bindPreconditions(const Soprano::BindingSet&) const", typeof(List<Soprano.Statement>), typeof(Soprano.BindingSet), bindings);
        }
        ~Rule() {
            interceptor.Invoke("~Rule", "~Rule()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~Rule", "~Rule()", typeof(void));
        }
    }
}
