//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano.Index {
    using Soprano;
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class CLuceneIndex cluceneindex.h Soprano/Index/CLuceneIndex
    ///  \brief The CLuceneIndex provides a wrapper around a CLucene index 
    ///  which stores RDF statements.
    ///  It is used by the IndexFilterModel to actually handle the index. It has been
    ///  made visible in the public API to provide the possibility for advanced queries
    ///  and data modifications.
    ///  CLuceneIndex is thread-safe.
    ///  <b>Data organization</b>
    ///  In the %Soprano index each resouce gets its own clucene document. Only statements with literal
    ///  objects are indexed. The clucene is identified through the statements' subject and then a new
    ///  field is created that uses the statement's predicate as field name and the statement's object
    ///  as value. The index ignores all context information.
    ///  \warning <b>The API is subject to change. Most likely CLucene classes will be wrapped and hidden from the public API.</b>
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///          </remarks>        <short>    \class CLuceneIndex cluceneindex.</short>
    [SmokeClass("Soprano::Index::CLuceneIndex")]
    public class CLuceneIndex : Soprano.Error.ErrorCache, IDisposable {
        protected CLuceneIndex(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(CLuceneIndex), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static CLuceneIndex() {
            staticInterceptor = new SmokeInvocation(typeof(CLuceneIndex), null);
        }
        // Soprano::Index::CLuceneIndex* CLuceneIndex(lucene::analysis::Analyzer* arg1); >>>> NOT CONVERTED
        // lucene::document::Document* documentForResource(const Soprano::Node& arg1); >>>> NOT CONVERTED
        // Soprano::Iterator<Soprano::Index::QueryHit> search(const QString& arg1); >>>> NOT CONVERTED
        // Soprano::Iterator<Soprano::Index::QueryHit> search(lucene::search::Query* arg1); >>>> NOT CONVERTED
        // Soprano::Node getResource(lucene::document::Document* arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  \param analyzer The analyzer to be used. If 0 a standard analyzer will be created.
        ///              </remarks>        <short>    \param analyzer The analyzer to be used.</short>
        /// <remarks>
        ///  Open the index.
        ///  \param folder The folder where the index is stored.
        ///  \param force If true any CLucene locks on the folder are removed. This is useful
        ///  if a previous session crashed and left an unused lock lying around.
        ///              </remarks>        <short>    Open the index.</short>
        public bool Open(string folder, bool force) {
            return (bool) interceptor.Invoke("open$$", "open(const QString&, bool)", typeof(bool), typeof(string), folder, typeof(bool), force);
        }
        public bool Open(string folder) {
            return (bool) interceptor.Invoke("open$", "open(const QString&)", typeof(bool), typeof(string), folder);
        }
        /// <remarks>
        ///  Close the index. Write back any changes, close any open transactions. (Is called in ~CLuceneIndex())
        ///              </remarks>        <short>    Close the index.</short>
        public void Close() {
            interceptor.Invoke("close", "close()", typeof(void));
        }
        /// <remarks>
        ///  \return <pre>true</pre> If the index has been opened successfully.
        ///  \sa open()
        ///              </remarks>        <short>    \return \p true If the index has been opened successfully.</short>
        public bool IsOpen() {
            return (bool) interceptor.Invoke("isOpen", "isOpen() const", typeof(bool));
        }
        /// <remarks>
        ///  Get the number of indexed resources.
        ///  \return The number of indexed resoruces or -1 on error (In the case of error
        ///  lastError() provides more information.
        ///              </remarks>        <short>    Get the number of indexed resources.</short>
        public int ResourceCount() {
            return (int) interceptor.Invoke("resourceCount", "resourceCount() const", typeof(int));
        }
        /// <remarks>
        ///  Start a new transaction. After calling this method multiple fields and statements may be added to the
        ///  index and nothing is written back to disk. A transaction has to be closed. Otherwise the data will not be written to the index.
        ///  (All transactions are closed on deletion.)
        ///  Methods such as addStatement will start and close a transaction internally if none has been started
        ///  before.
        ///  \return A transaction id that has to be used to close the transaction. This is a safety mechanism to ensure
        ///  that no other user closes one's transaction. If another transaction has already been started 0 is returned.
        ///              </remarks>        <short>    Start a new transaction.</short>
        public int StartTransaction() {
            return (int) interceptor.Invoke("startTransaction", "startTransaction()", typeof(int));
        }
        /// <remarks>
        ///  Close a transaction and write the changes back to the index.
        ///  \param id The transaction ID as returned by startTransaction()
        ///  \return <pre>true</pre> if the transaction was closed,  false if no transaction was started,
        ///  a wrong transaction id has been supplied, or a clucene error occured.
        ///              </remarks>        <short>    Close a transaction and write the changes back to the index.</short>
        public bool CloseTransaction(int id) {
            return (bool) interceptor.Invoke("closeTransaction$", "closeTransaction(int)", typeof(bool), typeof(int), id);
        }
        /// <remarks>
        ///  Indexes a statement.
        ///  \return An error code or 0 on success
        ///              </remarks>        <short>    Indexes a statement.</short>
        public Soprano.Error.ErrorCode AddStatement(Soprano.Statement arg1) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("addStatement#", "addStatement(const Soprano::Statement&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Statement), arg1);
        }
        /// <remarks>
        ///  Removes a statement from the index.
        ///  \return An error code or 0 on success
        ///              </remarks>        <short>    Removes a statement from the index.</short>
        public Soprano.Error.ErrorCode RemoveStatement(Soprano.Statement arg1) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("removeStatement#", "removeStatement(const Soprano::Statement&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Statement), arg1);
        }
        /// <remarks>
        ///  Get a document for a specific resource. This is only possible after starting a transaction.
        ///  \param resource The resource for which a document is requested.
        ///  \return The document representing the resource or 0 if no transaction has been started or
        ///  a clucene error occured.
        ///  \warning This is an advanced method. Calling this method is thread-safe but using the 
        ///  returned document is not.
        ///              </remarks>        <short>    Get a document for a specific resource.</short>
        /// <remarks>
        ///  Evaluates the given query.
        ///  Each hit is a resource and a score. Resource properties may be read from the model.
        ///  \param query The query in the CLucene query language.
        ///  \return The results as an iterator over QueryHit objects or an invalid iterator
        ///  on error.
        ///              </remarks>        <short>    Evaluates the given query.</short>
        /// <remarks>
        ///  Evaluates the given query.
        ///  Each hit is a resource and a score. Resource properties may be read from the model.
        ///  \param query The query to evaluate. The iterator takes ownership of the query. 
        ///  Do not delete.it! (If anyone using this understands the weird CLucene memory
        ///  management enough to fix this issue, please...)
        ///  \return The results as an iterator over QueryHit objects or an invalid iterator
        ///  on error.
        ///  \warning The result iterator uses the query object.
        ///              </remarks>        <short>    Evaluates the given query.</short>
        /// <remarks>
        ///  Dump the index contents to the stream
        ///              </remarks>        <short>    Dump the index contents to the stream              </short>
        public void Dump(QTextStream arg1) {
            interceptor.Invoke("dump#", "dump(QTextStream&) const", typeof(void), typeof(QTextStream), arg1);
        }
        /// <remarks>
        ///  Clear the index, i.e. delete all entries.
        ///  \since 2.1
        ///              </remarks>        <short>    Clear the index, i.</short>
        public void Clear() {
            interceptor.Invoke("clear", "clear()", typeof(void));
        }
        /// <remarks>
        ///  Optimize the index for search. This makes sense after adding or
        ///  removing a large number of statements.
        ///  \since 2.2
        ///              </remarks>        <short>    Optimize the index for search.</short>
        public void Optimize() {
            interceptor.Invoke("optimize", "optimize()", typeof(void));
        }
        ~CLuceneIndex() {
            interceptor.Invoke("~CLuceneIndex", "~CLuceneIndex()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~CLuceneIndex", "~CLuceneIndex()", typeof(void));
        }
        /// <remarks>
        ///  Returns the Resource corresponding with the specified Document.
        ///              </remarks>        <short>    Returns the Resource corresponding with the specified Document.</short>
        /// <remarks>
        ///  This is a temporary method which supports the advanced query interface based on
        ///  CLucene classes.
        ///  The %Soprano index creates one special field for each indexed resource which contains
        ///  all data to allow simple queries without property names or URIs.
        ///  \return The name of the default CLucene search field to be queried when no properties
        ///  are known.
        ///              </remarks>        <short>    This is a temporary method which supports the advanced query interface based on  CLucene classes.</short>
        public static string DefaultSearchField() {
            return (string) staticInterceptor.Invoke("defaultSearchField", "defaultSearchField()", typeof(string));
        }
    }
}
