//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano.Client {
    using Soprano;
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class UnixSocketClient unixsocketclient.h Soprano/Client/UnixSocketClient
    ///  \brief Creates a connection to the %Soprano server through a unix socket interface.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///          </remarks>        <short>    \class UnixSocketClient unixsocketclient.</short>
    [SmokeClass("Soprano::Client::UnixSocketClient")]
    public class UnixSocketClient : QObject, Soprano.Error.IErrorCache, IDisposable {
        protected UnixSocketClient(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(UnixSocketClient), this);
        }
        // Soprano::Model* createModel(const QString& arg1,const QList<Soprano::BackendSetting>& arg2); >>>> NOT CONVERTED
        // Error lastError(); >>>> NOT CONVERTED
        // void setError(const Error& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Create a new Client instance.
        ///              </remarks>        <short>    Create a new Client instance.</short>
        public UnixSocketClient(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("UnixSocketClient#", "UnixSocketClient(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public UnixSocketClient() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("UnixSocketClient", "UnixSocketClient()", typeof(void));
        }
        /// <remarks>
        ///  Tries to connect to the %Soprano server.
        ///  \return <pre>true</pre> on success, <pre>false</pre> if an error occured.
        ///  Check lastError() for details.
        ///              </remarks>        <short>    Tries to connect to the %Soprano server.</short>
        public bool Connect(string name) {
            return (bool) interceptor.Invoke("connect$", "connect(const QString&)", typeof(bool), typeof(string), name);
        }
        public bool Connect() {
            return (bool) interceptor.Invoke("connect", "connect()", typeof(bool));
        }
        /// <remarks>
        ///  Check if the client is connected to a server.
        ///  \return <pre>true</pre> if this client is connected to a server, <pre>false</pre>
        ///  otherwise.
        ///              </remarks>        <short>    Check if the client is connected to a server.</short>
        public bool IsConnected() {
            return (bool) interceptor.Invoke("isConnected", "isConnected()", typeof(bool));
        }
        /// <remarks>
        ///  Disconnect from the server. The created model instances are not
        ///  deleted but remain useless; open iterators are closed.
        ///              </remarks>        <short>    Disconnect from the server.</short>
        public new void Disconnect() {
            interceptor.Invoke("disconnect", "disconnect()", typeof(void));
        }
        /// <remarks>
        ///  Creates a new Model instance that wraps a server model.
        ///  %Client models are very light wrappers and creating them is
        ///  very fast.
        ///  \param name The name of the model to access.
        ///  \param settings The settings to send to the server for creating a new model.
        ///  These settings may be ignored by the server if a model with that name has
        ///  already been created.
        ///  \return A new Model instance wrapping the requested server
        ///  model or 0 on error (check lastError() for details.)
        ///              </remarks>        <short>    Creates a new Model instance that wraps a server model.</short>
        public Soprano.Model CreateModel(string name) {
            return (Soprano.Model) interceptor.Invoke("createModel$", "createModel(const QString&)", typeof(Soprano.Model), typeof(string), name);
        }
        ~UnixSocketClient() {
            interceptor.Invoke("~UnixSocketClient", "~UnixSocketClient()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~UnixSocketClient", "~UnixSocketClient()", typeof(void));
        }
        /// <remarks>
        ///  Get the last error that occured in the current thread.
        ///              </remarks>        <short>    Get the last error that occured in the current thread.</short>
        /// <remarks>
        ///  Reset the error for the current thread to no error.
        ///              </remarks>        <short>    Reset the error for the current thread to no error.</short>
        protected void ClearError() {
            interceptor.Invoke("clearError", "clearError() const", typeof(void));
        }
        /// <remarks>
        ///  Set the last occured error. This method is const to allow setting
        ///  of errors in all types of methods. The last error is as such a 
        ///  mutable property.
        ///              </remarks>        <short>    Set the last occured error.</short>
        /// <remarks>
        ///  Convenience method to set simple string error messages with a default
        ///  error code ErrorUnknown.
        ///              </remarks>        <short>    Convenience method to set simple string error messages with a default  error code ErrorUnknown.</short>
        protected void SetError(string errorMessage, int code) {
            interceptor.Invoke("setError$$", "setError(const QString&, int) const", typeof(void), typeof(string), errorMessage, typeof(int), code);
        }
        protected void SetError(string errorMessage) {
            interceptor.Invoke("setError$", "setError(const QString&) const", typeof(void), typeof(string), errorMessage);
        }
        protected new IUnixSocketClientSignals Emit {
            get { return (IUnixSocketClientSignals) Q_EMIT; }
        }
    }

    public interface IUnixSocketClientSignals : IQObjectSignals {
    }
}
