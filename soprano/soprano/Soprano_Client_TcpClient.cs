//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano.Client {
    using Soprano;
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class TcpClient tcpclient.h Soprano/Client/TcpClient
    ///  \brief Creates a connection to the %Soprano server through a TCP connection.
    ///  The %Soprano server supports more than one way of communication. Beside D-Bus (see
    ///  DBusClient) and local socket communication (LocalSocketClient) it can be contacted via
    ///  TCP. For that to work the server has to be listening on some port (Server.ServerCore.Listen).
    ///  \warning The TcpClient does not support signals. Thus, the models created
    ///  by it will not emit signals such as Model.StatementAdded. Also no permission handling or
    ///  any kind of security is implemented at the moment. Thus, if a server is running and is 
    ///  listening on a port, it is open to connections from any client on any computer in the
    ///  network.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///          </remarks>        <short>    \class TcpClient tcpclient.</short>
    [SmokeClass("Soprano::Client::TcpClient")]
    public class TcpClient : QObject, Soprano.Error.IErrorCache, IDisposable {
        protected TcpClient(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(TcpClient), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static TcpClient() {
            staticInterceptor = new SmokeInvocation(typeof(TcpClient), null);
        }
        public static ushort DEFAULT_PORT() {
            return (ushort) staticInterceptor.Invoke("DEFAULT_PORT", "DEFAULT_PORT()", typeof(ushort));
        }
        // Soprano::Model* createModel(const QString& arg1,const QList<Soprano::BackendSetting>& arg2); >>>> NOT CONVERTED
        // Error lastError(); >>>> NOT CONVERTED
        // void setError(const Error& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Create a new Client instance.
        ///              </remarks>        <short>    Create a new Client instance.</short>
        public TcpClient(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("TcpClient#", "TcpClient(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public TcpClient() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("TcpClient", "TcpClient()", typeof(void));
        }
        /// <remarks>
        ///  Tries to connect to the %Soprano server.
        ///  \return <pre>true</pre> on success, <pre>false</pre> if an error occured.
        ///  Check lastError() for details.
        ///              </remarks>        <short>    Tries to connect to the %Soprano server.</short>
        public bool Connect(QHostAddress address, int port) {
            return (bool) interceptor.Invoke("connect#$", "connect(const QHostAddress&, int)", typeof(bool), typeof(QHostAddress), address, typeof(int), port);
        }
        public bool Connect(QHostAddress address) {
            return (bool) interceptor.Invoke("connect#", "connect(const QHostAddress&)", typeof(bool), typeof(QHostAddress), address);
        }
        public bool Connect() {
            return (bool) interceptor.Invoke("connect", "connect()", typeof(bool));
        }
        /// <remarks>
        ///  Check if the client is connected to a server.
        ///  \return <pre>true</pre> if this client is connected to a server, <pre>false</pre>
        ///  otherwise.
        ///              </remarks>        <short>    Check if the client is connected to a server.</short>
        public bool IsConnected() {
            return (bool) interceptor.Invoke("isConnected", "isConnected()", typeof(bool));
        }
        /// <remarks>
        ///  Disconnect from the server. The created model instances are not
        ///  deleted but remain useless; open iterators are closed.
        ///              </remarks>        <short>    Disconnect from the server.</short>
        public new void Disconnect() {
            interceptor.Invoke("disconnect", "disconnect()", typeof(void));
        }
        /// <remarks>
        ///  Creates a new Model instance that wraps a server model.
        ///  %Client models are very light wrappers and creating them is
        ///  very fast.
        ///  \param name The name of the model to access.
        ///  \param settings The settings to send to the server for creating a new model.
        ///  These settings may be ignored by the server if a model with that name has
        ///  already been created.
        ///  \return A new Model instance wrapping the requested server
        ///  model or 0 on error (check lastError() for details.)
        ///              </remarks>        <short>    Creates a new Model instance that wraps a server model.</short>
        public Soprano.Model CreateModel(string name) {
            return (Soprano.Model) interceptor.Invoke("createModel$", "createModel(const QString&)", typeof(Soprano.Model), typeof(string), name);
        }
        /// <remarks>
        ///  Deletes a model including all its data.
        ///  \param name The name of the model to remove.
        ///  \warning Calling this method will remove all data physically. It can not
        ///  be reverted. Use with care.
        ///  \since 2.1
        ///              </remarks>        <short>    Deletes a model including all its data.</short>
        public void RemoveModel(string name) {
            interceptor.Invoke("removeModel$", "removeModel(const QString&)", typeof(void), typeof(string), name);
        }
        ~TcpClient() {
            interceptor.Invoke("~TcpClient", "~TcpClient()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~TcpClient", "~TcpClient()", typeof(void));
        }
        /// <remarks>
        ///  Get the last error that occured in the current thread.
        ///              </remarks>        <short>    Get the last error that occured in the current thread.</short>
        /// <remarks>
        ///  Reset the error for the current thread to no error.
        ///              </remarks>        <short>    Reset the error for the current thread to no error.</short>
        protected void ClearError() {
            interceptor.Invoke("clearError", "clearError() const", typeof(void));
        }
        /// <remarks>
        ///  Set the last occured error. This method is const to allow setting
        ///  of errors in all types of methods. The last error is as such a 
        ///  mutable property.
        ///              </remarks>        <short>    Set the last occured error.</short>
        /// <remarks>
        ///  Convenience method to set simple string error messages with a default
        ///  error code ErrorUnknown.
        ///              </remarks>        <short>    Convenience method to set simple string error messages with a default  error code ErrorUnknown.</short>
        protected void SetError(string errorMessage, int code) {
            interceptor.Invoke("setError$$", "setError(const QString&, int) const", typeof(void), typeof(string), errorMessage, typeof(int), code);
        }
        protected void SetError(string errorMessage) {
            interceptor.Invoke("setError$", "setError(const QString&) const", typeof(void), typeof(string), errorMessage);
        }
        protected new ITcpClientSignals Emit {
            get { return (ITcpClientSignals) Q_EMIT; }
        }
    }

    public interface ITcpClientSignals : IQObjectSignals {
    }
}
