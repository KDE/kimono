//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano {
    using Soprano;
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class FilterModel filtermodel.h Soprano/FilterModel
    ///  \brief A FilterModel is a model that wraps another Model.
    ///  FilterModels can be stacked to provide filtering on each of
    ///  the Model's methods. A FilterModel has a parent model which
    ///  is the data base for this filter. The parent can be an actual
    ///  StorageModel or another FilterModel.
    ///  <b>Error handling:</b>
    ///  The FilterModel "inherits" its parent Model's errors, i.e. FilterModel.LastError()
    ///  always equals FilterModel.Parent().LastError() (If the FilterModel implementations
    ///  are called in subclasses).
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///      </remarks>        <short>    \class FilterModel filtermodel.</short>
    [SmokeClass("Soprano::FilterModel")]
    public class FilterModel : Soprano.Model, IDisposable {
        protected FilterModel(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(FilterModel), this);
        }
        /// <remarks>
        ///  Set the parent Model.
        ///  \param model The Model that this filter will forward any commands to.
        ///          </remarks>        <short>    Set the parent Model.</short>
        [SmokeMethod("setParentModel(Soprano::Model*)")]
        public virtual void SetParentModel(Soprano.Model model) {
            interceptor.Invoke("setParentModel#", "setParentModel(Soprano::Model*)", typeof(void), typeof(Soprano.Model), model);
        }
        /// <remarks>
        ///  Get the parent model.
        ///  \return The parent Model or 0 if none has been set.
        ///          </remarks>        <short>    Get the parent model.</short>
        [SmokeMethod("parentModel() const")]
        public virtual Soprano.Model ParentModel() {
            return (Soprano.Model) interceptor.Invoke("parentModel", "parentModel() const", typeof(Soprano.Model));
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("addStatement(const Soprano::Statement&)")]
        public override Soprano.Error.ErrorCode AddStatement(Soprano.Statement statement) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("addStatement#", "addStatement(const Soprano::Statement&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Reimplemented for convenience. Calls Model.AddStatement(Node,Node,Node,Node)
        ///          </remarks>        <short>    Reimplemented for convenience.</short>
        public new Soprano.Error.ErrorCode AddStatement(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3, Soprano.Node context) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("addStatement####", "addStatement(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&, const Soprano::Node&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3, typeof(Soprano.Node), context);
        }
        public new Soprano.Error.ErrorCode AddStatement(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("addStatement###", "addStatement(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3);
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("removeStatement(const Soprano::Statement&)")]
        public override Soprano.Error.ErrorCode RemoveStatement(Soprano.Statement statement) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("removeStatement#", "removeStatement(const Soprano::Statement&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Reimplemented for convenience. Calls Model.RemoveStatement(Node,Node,Node,Node)
        ///          </remarks>        <short>    Reimplemented for convenience.</short>
        public new Soprano.Error.ErrorCode RemoveStatement(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3, Soprano.Node context) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("removeStatement####", "removeStatement(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&, const Soprano::Node&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3, typeof(Soprano.Node), context);
        }
        public new Soprano.Error.ErrorCode RemoveStatement(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("removeStatement###", "removeStatement(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3);
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("removeAllStatements(const Soprano::Statement&)")]
        public override Soprano.Error.ErrorCode RemoveAllStatements(Soprano.Statement statement) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("removeAllStatements#", "removeAllStatements(const Soprano::Statement&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Reimplemented for convenience. Calls Model.RemoveAllStatements(Node,Node,Node,Node)
        ///          </remarks>        <short>    Reimplemented for convenience.</short>
        public new Soprano.Error.ErrorCode RemoveAllStatements(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3, Soprano.Node context) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("removeAllStatements####", "removeAllStatements(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&, const Soprano::Node&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3, typeof(Soprano.Node), context);
        }
        public new Soprano.Error.ErrorCode RemoveAllStatements(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("removeAllStatements###", "removeAllStatements(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&)", typeof(Soprano.Error.ErrorCode), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3);
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("listStatements(const Soprano::Statement&) const")]
        public override Soprano.StatementIterator ListStatements(Soprano.Statement partial) {
            return (Soprano.StatementIterator) interceptor.Invoke("listStatements#", "listStatements(const Soprano::Statement&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Statement), partial);
        }
        /// <remarks>
        ///  Reimplemented for convenience. Calls Model.ListStatements(Node,Node,Node,Node)
        ///          </remarks>        <short>    Reimplemented for convenience.</short>
        public new Soprano.StatementIterator ListStatements(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3, Soprano.Node context) {
            return (Soprano.StatementIterator) interceptor.Invoke("listStatements####", "listStatements(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&, const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3, typeof(Soprano.Node), context);
        }
        public new Soprano.StatementIterator ListStatements(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3) {
            return (Soprano.StatementIterator) interceptor.Invoke("listStatements###", "listStatements(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3);
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("listContexts() const")]
        public override Soprano.NodeIterator ListContexts() {
            return (Soprano.NodeIterator) interceptor.Invoke("listContexts", "listContexts() const", typeof(Soprano.NodeIterator));
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("executeQuery(const QString&, Soprano::Query::QueryLanguage, const QString&) const")]
        public override Soprano.QueryResultIterator ExecuteQuery(string query, Soprano.Query.QueryLanguage language, string userQueryLanguage) {
            return (Soprano.QueryResultIterator) interceptor.Invoke("executeQuery$$$", "executeQuery(const QString&, Soprano::Query::QueryLanguage, const QString&) const", typeof(Soprano.QueryResultIterator), typeof(string), query, typeof(Soprano.Query.QueryLanguage), language, typeof(string), userQueryLanguage);
        }
        [SmokeMethod("executeQuery(const QString&, Soprano::Query::QueryLanguage) const")]
        public virtual Soprano.QueryResultIterator ExecuteQuery(string query, Soprano.Query.QueryLanguage language) {
            return (Soprano.QueryResultIterator) interceptor.Invoke("executeQuery$$", "executeQuery(const QString&, Soprano::Query::QueryLanguage) const", typeof(Soprano.QueryResultIterator), typeof(string), query, typeof(Soprano.Query.QueryLanguage), language);
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("containsStatement(const Soprano::Statement&) const")]
        public override bool ContainsStatement(Soprano.Statement statement) {
            return (bool) interceptor.Invoke("containsStatement#", "containsStatement(const Soprano::Statement&) const", typeof(bool), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Reimplemented for convenience. Calls Model.ContainsStatement(Node,Node,Node,Node)
        ///          </remarks>        <short>    Reimplemented for convenience.</short>
        public new bool ContainsStatement(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3, Soprano.Node context) {
            return (bool) interceptor.Invoke("containsStatement####", "containsStatement(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&, const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3, typeof(Soprano.Node), context);
        }
        public new bool ContainsStatement(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3) {
            return (bool) interceptor.Invoke("containsStatement###", "containsStatement(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3);
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("containsAnyStatement(const Soprano::Statement&) const")]
        public override bool ContainsAnyStatement(Soprano.Statement statement) {
            return (bool) interceptor.Invoke("containsAnyStatement#", "containsAnyStatement(const Soprano::Statement&) const", typeof(bool), typeof(Soprano.Statement), statement);
        }
        /// <remarks>
        ///  Reimplemented for convenience. Calls Model.ContainsAnyStatement(Node,Node,Node,Node)
        ///          </remarks>        <short>    Reimplemented for convenience.</short>
        public new bool ContainsAnyStatement(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3, Soprano.Node context) {
            return (bool) interceptor.Invoke("containsAnyStatement####", "containsAnyStatement(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&, const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3, typeof(Soprano.Node), context);
        }
        public new bool ContainsAnyStatement(Soprano.Node subject, Soprano.Node predicate, Soprano.Node arg3) {
            return (bool) interceptor.Invoke("containsAnyStatement###", "containsAnyStatement(const Soprano::Node&, const Soprano::Node&, const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), subject, typeof(Soprano.Node), predicate, typeof(Soprano.Node), arg3);
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("isEmpty() const")]
        public override bool IsEmpty() {
            return (bool) interceptor.Invoke("isEmpty", "isEmpty() const", typeof(bool));
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("statementCount() const")]
        public override int StatementCount() {
            return (int) interceptor.Invoke("statementCount", "statementCount() const", typeof(int));
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("write(QTextStream&) const")]
        public override Soprano.Error.ErrorCode Write(QTextStream os) {
            return (Soprano.Error.ErrorCode) interceptor.Invoke("write#", "write(QTextStream&) const", typeof(Soprano.Error.ErrorCode), typeof(QTextStream), os);
        }
        /// <remarks>
        ///  Default implementation simply pipes the call through to the parent model.
        ///          </remarks>        <short>    Default implementation simply pipes the call through to the parent model.</short>
        [SmokeMethod("createBlankNode()")]
        public override Soprano.Node CreateBlankNode() {
            return (Soprano.Node) interceptor.Invoke("createBlankNode", "createBlankNode()", typeof(Soprano.Node));
        }
        /// <remarks>
        ///  Create an empty filter model.
        ///          </remarks>        <short>    Create an empty filter model.</short>
        public FilterModel() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("FilterModel", "FilterModel()", typeof(void));
        }
        /// <remarks>
        ///  Create a new FilterModel which works on parent.
        ///  Calls setParentModel.
        ///  \param parent The parent Model.
        ///          </remarks>        <short>    Create a new FilterModel which works on parent.</short>
        public FilterModel(Soprano.Model parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("FilterModel#", "FilterModel(Soprano::Model*)", typeof(void), typeof(Soprano.Model), parent);
        }
        /// <remarks>
        ///  Handle a statementsAdded() signal from the parent Model.
        ///  The default implementation simply re-emits the signal.
        ///          </remarks>        <short>    Handle a statementsAdded() signal from the parent Model.</short>
        [SmokeMethod("parentStatementsAdded()")]
        protected virtual void ParentStatementsAdded() {
            interceptor.Invoke("parentStatementsAdded", "parentStatementsAdded()", typeof(void));
        }
        /// <remarks>
        ///  Handle a statementsRemoved() signal from the parent Model.
        ///  The default implementation simply re-emits the signal.
        ///          </remarks>        <short>    Handle a statementsRemoved() signal from the parent Model.</short>
        [SmokeMethod("parentStatementsRemoved()")]
        protected virtual void ParentStatementsRemoved() {
            interceptor.Invoke("parentStatementsRemoved", "parentStatementsRemoved()", typeof(void));
        }
        /// <remarks>
        ///  Handle a statementsAdded() signal from the parent Model.
        ///  The default implementation simply re-emits the signal.
        ///          </remarks>        <short>    Handle a statementsAdded() signal from the parent Model.</short>
        [SmokeMethod("parentStatementAdded(const Soprano::Statement&)")]
        protected virtual void ParentStatementAdded(Soprano.Statement arg1) {
            interceptor.Invoke("parentStatementAdded#", "parentStatementAdded(const Soprano::Statement&)", typeof(void), typeof(Soprano.Statement), arg1);
        }
        /// <remarks>
        ///  Handle a statementsRemoved() signal from the parent Model.
        ///  The default implementation simply re-emits the signal.
        ///          </remarks>        <short>    Handle a statementsRemoved() signal from the parent Model.</short>
        [SmokeMethod("parentStatementRemoved(const Soprano::Statement&)")]
        protected virtual void ParentStatementRemoved(Soprano.Statement arg1) {
            interceptor.Invoke("parentStatementRemoved#", "parentStatementRemoved(const Soprano::Statement&)", typeof(void), typeof(Soprano.Statement), arg1);
        }
        ~FilterModel() {
            interceptor.Invoke("~FilterModel", "~FilterModel()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~FilterModel", "~FilterModel()", typeof(void));
        }
        protected new IFilterModelSignals Emit {
            get { return (IFilterModelSignals) Q_EMIT; }
        }
    }

    public interface IFilterModelSignals : Soprano.IModelSignals {
    }
}
