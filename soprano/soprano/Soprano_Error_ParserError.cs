//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano.Error {
    using Soprano;
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class ParserError error.h Soprano/Error/ParserError
    ///  \brief Represents a parser error in %Soprano.
    ///  ParserError represents an error during parsing of either a query string (Soprano.Query.Parser.ParseQuery())
    ///  or an RDF serialization (Soprano.Parser.ParseStream()).
    ///  Error and ParserError can be used together and copied without loosing information.
    ///  The following code is perfectly valid and works:
    ///  <pre>
    ///  ParserError pe( 3, 4 );
    ///  Error e = pe;
    ///  ParserError otherPe = e;
    ///  qDebug() << "Parsing failed at line " << otherPe.line() << " and column " << otherPe.column();
    ///  </pre>
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///  \sa \ref soprano_error_handling
    ///          </remarks>        <short>    \class ParserError error.</short>
    [SmokeClass("Soprano::Error::ParserError")]
    public class ParserError : Soprano.Error.Error, IDisposable {
        protected ParserError(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(ParserError), this);
        }
        // Soprano::Error::ParserError* ParserError(const Soprano::Error::Error& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Create an Error object, representing success, i.e. no error.
        ///              </remarks>        <short>    Create an Error object, representing success, i.</short>
        public ParserError() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ParserError", "ParserError()", typeof(void));
        }
        public ParserError(Soprano.Error.Locator arg1, string message, int code) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ParserError#$$", "ParserError(const Soprano::Error::Locator&, const QString&, int)", typeof(void), typeof(Soprano.Error.Locator), arg1, typeof(string), message, typeof(int), code);
        }
        public ParserError(Soprano.Error.Locator arg1, string message) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ParserError#$", "ParserError(const Soprano::Error::Locator&, const QString&)", typeof(void), typeof(Soprano.Error.Locator), arg1, typeof(string), message);
        }
        public ParserError(Soprano.Error.Locator arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ParserError#", "ParserError(const Soprano::Error::Locator&)", typeof(void), typeof(Soprano.Error.Locator), arg1);
        }
        public Soprano.Error.Locator Locator() {
            return (Soprano.Error.Locator) interceptor.Invoke("locator", "locator() const", typeof(Soprano.Error.Locator));
        }
        ~ParserError() {
            interceptor.Invoke("~ParserError", "~ParserError()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~ParserError", "~ParserError()", typeof(void));
        }
    }
}
