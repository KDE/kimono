//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano {
    using Soprano;
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class RdfSchemaModel rdfschemamodel.h Soprano/RdfSchemaModel
    ///  \brief Provides convenience methods to handle RDFS data.
    ///  Interface based on Sesame's RdfSchemaSource. (Copyright (C) 2002-2006 Aduna BV, GNU LGPL License applies.)
    ///  \warning Backward inferencing has not been implemented yet. Thus, methods like subClassOf() return the same
    ///  as directSubClassOf().
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///      </remarks>        <short>    \class RdfSchemaModel rdfschemamodel.</short>
    [SmokeClass("Soprano::RdfSchemaModel")]
    public class RdfSchemaModel : Soprano.FilterModel, IDisposable {
        protected RdfSchemaModel(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(RdfSchemaModel), this);
        }
        /// <remarks>
        ///  Create a new RDF Schema wrapper model that performs actions
        ///  on <pre>model</pre>
        ///          </remarks>        <short>    Create a new RDF Schema wrapper model that performs actions  on \p model          </short>
        public RdfSchemaModel(Soprano.Model parentModel) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("RdfSchemaModel#", "RdfSchemaModel(Soprano::Model*)", typeof(void), typeof(Soprano.Model), parentModel);
        }
        public RdfSchemaModel() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("RdfSchemaModel", "RdfSchemaModel()", typeof(void));
        }
        /// <remarks>
        ///  Get all defined RDF/S classes.
        ///  \return a StatementIterator that iterates over all statements in the model
        ///  defining an RDF/S class.
        ///          </remarks>        <short>    Get all defined RDF/S classes.</short>
        public Soprano.StatementIterator Classes() {
            return (Soprano.StatementIterator) interceptor.Invoke("classes", "classes() const", typeof(Soprano.StatementIterator));
        }
        /// <remarks>
        ///  Gets all direct subClassOf relations with a specific sub- and/or superclass. 
        ///  A class A is a direct subclass of class B if there is no class C such that A is 
        ///  a subclass of C and C is a subclass of B.
        ///  \param subClass The subclass of the relations that should be returned, 
        ///  or an empty node if relations with any subclass should be returned.
        ///  \param superClass The superclass of the relations that should be returned, 
        ///  or an empty node if relations with any superclass should be returned.
        ///  \return A StatementIterator containing statements of the form
        ///  (subClass, rdfs:subClassOf, superClass).
        ///          </remarks>        <short>    Gets all direct subClassOf relations with a specific sub- and/or superclass.</short>
        public Soprano.StatementIterator DirectSubClassOf(Soprano.Node subClass, Soprano.Node superClass) {
            return (Soprano.StatementIterator) interceptor.Invoke("directSubClassOf##", "directSubClassOf(const Soprano::Node&, const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), subClass, typeof(Soprano.Node), superClass);
        }
        public Soprano.StatementIterator DirectSubClassOf(Soprano.Node subClass) {
            return (Soprano.StatementIterator) interceptor.Invoke("directSubClassOf#", "directSubClassOf(const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), subClass);
        }
        /// <remarks>
        ///  Gets all direct subPropertyOf relations with a specific sub- and/or superproperty.
        ///  A property A is a direct subproperty of property B if there is no property C such
        ///  that A is a subproperty of C and C is a subproperty of B. 
        ///  \param subProperty The subproperty of the relations that should be returned,
        ///  or an empty node if relations with any subproperty should be returned.
        ///  \param superProperty The superproperty of the relations that should be returned,
        ///  or an empty node if relations with any superproperty should be returned.
        ///  \return A StatementIterator containing statements of the form
        ///  (subProperty, rdfs:subPropertyOf, superProperty).
        ///          </remarks>        <short>    Gets all direct subPropertyOf relations with a specific sub- and/or superproperty.</short>
        public Soprano.StatementIterator DirectSubPropertyOf(Soprano.Node subProperty, Soprano.Node superProperty) {
            return (Soprano.StatementIterator) interceptor.Invoke("directSubPropertyOf##", "directSubPropertyOf(const Soprano::Node&, const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), subProperty, typeof(Soprano.Node), superProperty);
        }
        public Soprano.StatementIterator DirectSubPropertyOf(Soprano.Node subProperty) {
            return (Soprano.StatementIterator) interceptor.Invoke("directSubPropertyOf#", "directSubPropertyOf(const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), subProperty);
        }
        /// <remarks>
        ///  Gets all direct type relations with a specific instance and/or class.
        ///  \param someClass The instance of the relations that should be returned,
        ///  or an empty node if relations with any instance should be returned.
        ///  \param someType The class of the relations that should be returned,
        ///  or an empty node if relations with any class should be returned.
        ///  \return A StatementIterator containing statements of the form
        ///  (someClass, rdf:type, someType).
        ///          </remarks>        <short>    Gets all direct type relations with a specific instance and/or class.</short>
        public Soprano.StatementIterator DirectType(Soprano.Node someClass, Soprano.Node someType) {
            return (Soprano.StatementIterator) interceptor.Invoke("directType##", "directType(const Soprano::Node&, const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), someClass, typeof(Soprano.Node), someType);
        }
        /// <remarks>
        ///  Gets all domain relations with a specific property and/or domain class.
        ///  \param prop The property of the relations that should be returned,
        ///  or an empty node if relations with any property should be returned.
        ///  \param domain The domain of the relations that should be returned,
        ///  or an empty node if relations with any domain should be returned.
        ///  \return A StatementIterator containing statements of the form
        ///  (prop, rdfs:domain, domain).
        ///          </remarks>        <short>    Gets all domain relations with a specific property and/or domain class.</short>
        public Soprano.StatementIterator Domain(Soprano.Node prop, Soprano.Node domain) {
            return (Soprano.StatementIterator) interceptor.Invoke("domain##", "domain(const Soprano::Node&, const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), prop, typeof(Soprano.Node), domain);
        }
        /// <remarks>
        ///  Gets all defined properties. 
        ///  \return A StatementIterator containing statements of the form
        ///  (someProperty, rdf:type, rdf:Property).
        ///          </remarks>        <short>    Gets all defined properties.</short>
        public Soprano.StatementIterator Properties() {
            return (Soprano.StatementIterator) interceptor.Invoke("properties", "properties() const", typeof(Soprano.StatementIterator));
        }
        /// <remarks>
        ///  Gets all range relations with a specific property and/or range class.
        ///  \param prop The property of the relations that should be returned,
        ///  or an empty node if relations with any property should be returned.
        ///  \param range The range of the relations that should be returned,
        ///  or an empty node if relations with any range should be returned.
        ///  \return A StatementIterator containing statements of the form
        ///  (prop, rdfs:range, range).
        ///          </remarks>        <short>    Gets all range relations with a specific property and/or range class.</short>
        public Soprano.StatementIterator Range(Soprano.Node prop, Soprano.Node range) {
            return (Soprano.StatementIterator) interceptor.Invoke("range##", "range(const Soprano::Node&, const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), prop, typeof(Soprano.Node), range);
        }
        /// <remarks>
        ///  Gets all subClassOf relations with a specific sub- and/or superclass.
        ///  Note that the subClassOf relation is reflexive: a class is implicitly
        ///  always a subclass of itself.
        ///  Do not use this method if the Soprano backend supports inferencing.
        ///  Use directSubClassOf instead which is much faster.
        ///  \param subClass The subclass of the relations that should be returned,
        ///  or an empty node if relations with any subclass should be returned.
        ///  \param superClass The superclass of the relations that should be returned,
        ///  or an emtpy node if relations with any superclass should be returned.
        ///  \return A StatementIterator containing all valid statements of the form
        ///  (subClass, rdfs:subClassOf, superClass) including those calculated through
        ///  direct inferencing.
        ///          </remarks>        <short>    Gets all subClassOf relations with a specific sub- and/or superclass.</short>
        public Soprano.StatementIterator SubClassOf(Soprano.Node subClass, Soprano.Node superClass) {
            return (Soprano.StatementIterator) interceptor.Invoke("subClassOf##", "subClassOf(const Soprano::Node&, const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), subClass, typeof(Soprano.Node), superClass);
        }
        public Soprano.StatementIterator SubClassOf(Soprano.Node subClass) {
            return (Soprano.StatementIterator) interceptor.Invoke("subClassOf#", "subClassOf(const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), subClass);
        }
        /// <remarks>
        ///  Gets all subPropertyOf relations with a specific sub- and/or superproperty.
        ///  Note that the subPropertyOf relation is reflexive: a property is implicitly
        ///  always a subproperty of itself.
        ///  Do not use this method if the Soprano backend supports inferencing.
        ///  Use directSubPropertyOf instead which is much faster.
        ///  \param subProperty The subproperty of the relations that should be returned,
        ///  or an empty node if relations with any subproperty should be returned.
        ///  \param superProperty The superproperty of the relations that should be returned,
        ///  or an empty node if relations with any superproperty should be returned.
        ///  \return A StatementIterator containing all valid statements of the form
        ///  (subProperty, rdfs:subPropertyOf, superProperty) including those calculated through
        ///  direct inferencing.
        ///          </remarks>        <short>    Gets all subPropertyOf relations with a specific sub- and/or superproperty.</short>
        public Soprano.StatementIterator SubPropertyOf(Soprano.Node subProperty, Soprano.Node superProperty) {
            return (Soprano.StatementIterator) interceptor.Invoke("subPropertyOf##", "subPropertyOf(const Soprano::Node&, const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), subProperty, typeof(Soprano.Node), superProperty);
        }
        public Soprano.StatementIterator SubPropertyOf(Soprano.Node subProperty) {
            return (Soprano.StatementIterator) interceptor.Invoke("subPropertyOf#", "subPropertyOf(const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), subProperty);
        }
        /// <remarks>
        ///  Gets all type relations with a specific instance and/or class.
        ///  Do not use this method if the Soprano backend supports inferencing.
        ///  Use directType instead which is much faster.
        ///  \param someClass The instance of the relations that should be returned,
        ///  or an empty node if relations with any instance should be returned.
        ///  \param someType The class of the relations that should be returned,
        ///  or an empty node if relations with any class should be returned.
        ///  \return A StatementIterator containing all valid statements of the form
        ///  (someClass, rdf:type, someType) including those calculated through
        ///  direct inferencing.
        ///          </remarks>        <short>    Gets all type relations with a specific instance and/or class.</short>
        public Soprano.StatementIterator type(Soprano.Node someClass, Soprano.Node someType) {
            return (Soprano.StatementIterator) interceptor.Invoke("type##", "type(const Soprano::Node&, const Soprano::Node&) const", typeof(Soprano.StatementIterator), typeof(Soprano.Node), someClass, typeof(Soprano.Node), someType);
        }
        /// <remarks>
        ///  Checks whether the supplied resource represents a class.
        ///  \param resource The resource to check.
        ///  \return true if resource is a class, false otherwise.
        ///          </remarks>        <short>    Checks whether the supplied resource represents a class.</short>
        public bool IsClass(Soprano.Node resource) {
            return (bool) interceptor.Invoke("isClass#", "isClass(const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), resource);
        }
        /// <remarks>
        ///  Checks whether the supplied resource represents a property.
        ///  \param resource The resource to check.
        ///  \return true if resource is a property, false otherwise.
        ///          </remarks>        <short>    Checks whether the supplied resource represents a property.</short>
        public bool IsProperty(Soprano.Node resource) {
            return (bool) interceptor.Invoke("isProperty#", "isProperty(const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), resource);
        }
        /// <remarks>
        ///  Checks whether one resource is a direct subclass of another.
        ///  \param subClass A class.
        ///  \param superClass A class.
        ///  \return true if subClass is a direct subclass of superClass, false otherwise.
        ///          </remarks>        <short>    Checks whether one resource is a direct subclass of another.</short>
        public bool IsDirectSubClassOf(Soprano.Node subClass, Soprano.Node superClass) {
            return (bool) interceptor.Invoke("isDirectSubClassOf##", "isDirectSubClassOf(const Soprano::Node&, const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), subClass, typeof(Soprano.Node), superClass);
        }
        /// <remarks>
        ///  Checks whether one resource is a direct subproperty of another.
        ///  \param subProperty A property.
        ///  \param superProperty A property.
        ///  \return true if subProperty is a direct subproperty of superProperty, false otherwise.
        ///          </remarks>        <short>    Checks whether one resource is a direct subproperty of another.</short>
        public bool IsDirectSubPropertyOf(Soprano.Node subProperty, Soprano.Node superProperty) {
            return (bool) interceptor.Invoke("isDirectSubPropertyOf##", "isDirectSubPropertyOf(const Soprano::Node&, const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), subProperty, typeof(Soprano.Node), superProperty);
        }
        /// <remarks>
        ///  Checks whether one resource is a direct instance of another.
        ///  \param someClass An instance.
        ///  \param someType A class.
        ///  \return true if someClass is a direct instance of someType, false otherwise.
        ///          </remarks>        <short>    Checks whether one resource is a direct instance of another.</short>
        public bool IsDirectType(Soprano.Node someClass, Soprano.Node someType) {
            return (bool) interceptor.Invoke("isDirectType##", "isDirectType(const Soprano::Node&, const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), someClass, typeof(Soprano.Node), someType);
        }
        /// <remarks>
        ///  Checks whether one resource is a subclass of another.
        ///  Do not use this method if the Soprano backend supports inferencing.
        ///  Use isDirectSubClassOf instead which is much faster.
        ///  \param subClass A class.
        ///  \param superClass A class.
        ///  \return true if subClass is a subclass of superClass, false otherwise.
        ///          </remarks>        <short>    Checks whether one resource is a subclass of another.</short>
        public bool IsSubClassOf(Soprano.Node subClass, Soprano.Node superClass) {
            return (bool) interceptor.Invoke("isSubClassOf##", "isSubClassOf(const Soprano::Node&, const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), subClass, typeof(Soprano.Node), superClass);
        }
        /// <remarks>
        ///  Checks whether one resource is a subproperty of another.
        ///  Do not use this method if the Soprano backend supports inferencing.
        ///  Use isDirectSubPropertyOf instead which is much faster.
        ///  \param subProperty A property.
        ///  \param superProperty A property.
        ///  \return true if subProperty is a subproperty of superProperty, false otherwise.
        ///          </remarks>        <short>    Checks whether one resource is a subproperty of another.</short>
        public bool IsSubPropertyOf(Soprano.Node subProperty, Soprano.Node superProperty) {
            return (bool) interceptor.Invoke("isSubPropertyOf##", "isSubPropertyOf(const Soprano::Node&, const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), subProperty, typeof(Soprano.Node), superProperty);
        }
        /// <remarks>
        ///  Checks whether one resource is a instance of another.
        ///  Do not use this method if the Soprano backend supports inferencing.
        ///  Use isDirectType instead which is much faster.
        ///  \param someClass An instance.
        ///  \param someType A class.
        ///  \return true if someClass is an instance of someType, false otherwise.
        ///          </remarks>        <short>    Checks whether one resource is a instance of another.</short>
        public bool IsType(Soprano.Node someClass, Soprano.Node someType) {
            return (bool) interceptor.Invoke("isType##", "isType(const Soprano::Node&, const Soprano::Node&) const", typeof(bool), typeof(Soprano.Node), someClass, typeof(Soprano.Node), someType);
        }
        ~RdfSchemaModel() {
            interceptor.Invoke("~RdfSchemaModel", "~RdfSchemaModel()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~RdfSchemaModel", "~RdfSchemaModel()", typeof(void));
        }
        protected new IRdfSchemaModelSignals Emit {
            get { return (IRdfSchemaModelSignals) Q_EMIT; }
        }
    }

    public interface IRdfSchemaModelSignals : Soprano.IFilterModelSignals {
    }
}
