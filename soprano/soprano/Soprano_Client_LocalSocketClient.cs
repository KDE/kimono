//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano.Client {
    using Soprano;
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class LocalSocketClient localsocketclient.h Soprano/Client/LocalSocketClient
    ///  \brief Creates a connection to the %Soprano server through a local socket interface.
    ///  The %Soprano server supports more than one way of communication. Beside D-Bus (see
    ///  DBusClient) it can be contacted via a local socket.
    ///  Models creates by this client are thread-safe and provide faster access to the server
    ///  than D-Bus communication.
    ///  \warning The LocalSocketClient does not support signals. Thus, the models created
    ///  by it will not emit signals such as Model.StatementAdded.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///  \since 2.1
    ///          </remarks>        <short>    \class LocalSocketClient localsocketclient.</short>
    [SmokeClass("Soprano::Client::LocalSocketClient")]
    public class LocalSocketClient : QObject, Soprano.Error.IErrorCache, IDisposable {
        protected LocalSocketClient(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(LocalSocketClient), this);
        }
        // Soprano::Model* createModel(const QString& arg1,const QList<Soprano::BackendSetting>& arg2); >>>> NOT CONVERTED
        // Error lastError(); >>>> NOT CONVERTED
        // void setError(const Error& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Create a new Client instance.
        ///              </remarks>        <short>    Create a new Client instance.</short>
        public LocalSocketClient(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("LocalSocketClient#", "LocalSocketClient(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public LocalSocketClient() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("LocalSocketClient", "LocalSocketClient()", typeof(void));
        }
        /// <remarks>
        ///  Check if the client is connected to a server.
        ///  \return <pre>true</pre> if this client is connected to a server, <pre>false</pre>
        ///  otherwise.
        ///              </remarks>        <short>    Check if the client is connected to a server.</short>
        public bool IsConnected() {
            return (bool) interceptor.Invoke("isConnected", "isConnected() const", typeof(bool));
        }
        /// <remarks>
        ///  Creates a new Model instance that wraps a server model.
        ///  %Client models are very light wrappers and creating them is
        ///  very fast.
        ///  \param name The name of the model to access.
        ///  \param settings The settings to send to the server for creating a new model.
        ///  These settings may be ignored by the server if a model with that name has
        ///  already been created.
        ///  \return A new Model instance wrapping the requested server
        ///  model or 0 on error (check lastError() for details.)
        ///              </remarks>        <short>    Creates a new Model instance that wraps a server model.</short>
        public Soprano.Model CreateModel(string name) {
            return (Soprano.Model) interceptor.Invoke("createModel$", "createModel(const QString&)", typeof(Soprano.Model), typeof(string), name);
        }
        /// <remarks>
        ///  Deletes a model including all its data.
        ///  \param name The name of the model to remove.
        ///  \warning Calling this method will remove all data physically. It can not
        ///  be reverted. Use with care.
        ///              </remarks>        <short>    Deletes a model including all its data.</short>
        public void RemoveModel(string name) {
            interceptor.Invoke("removeModel$", "removeModel(const QString&)", typeof(void), typeof(string), name);
        }
        /// <remarks>
        ///  Tries to connect to the %Soprano server.
        ///  \return <pre>true</pre> on success, <pre>false</pre> if an error occured.
        ///  Check lastError() for details.
        ///              </remarks>        <short>    Tries to connect to the %Soprano server.</short>
        [Q_SLOT("bool connect(QString)")]
        public bool Connect(string name) {
            return (bool) interceptor.Invoke("connect$", "connect(const QString&)", typeof(bool), typeof(string), name);
        }
        [Q_SLOT("bool connect()")]
        public bool Connect() {
            return (bool) interceptor.Invoke("connect", "connect()", typeof(bool));
        }
        /// <remarks>
        ///  Disconnect from the server. The created model instances are not
        ///  deleted but remain useless; open iterators are closed.
        ///              </remarks>        <short>    Disconnect from the server.</short>
        [Q_SLOT("void disconnect()")]
        public new void Disconnect() {
            interceptor.Invoke("disconnect", "disconnect()", typeof(void));
        }
        ~LocalSocketClient() {
            interceptor.Invoke("~LocalSocketClient", "~LocalSocketClient()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~LocalSocketClient", "~LocalSocketClient()", typeof(void));
        }
        /// <remarks>
        ///  Get the last error that occured in the current thread.
        ///              </remarks>        <short>    Get the last error that occured in the current thread.</short>
        /// <remarks>
        ///  Reset the error for the current thread to no error.
        ///              </remarks>        <short>    Reset the error for the current thread to no error.</short>
        protected void ClearError() {
            interceptor.Invoke("clearError", "clearError() const", typeof(void));
        }
        /// <remarks>
        ///  Set the last occured error. This method is const to allow setting
        ///  of errors in all types of methods. The last error is as such a 
        ///  mutable property.
        ///              </remarks>        <short>    Set the last occured error.</short>
        /// <remarks>
        ///  Convenience method to set simple string error messages with a default
        ///  error code ErrorUnknown.
        ///              </remarks>        <short>    Convenience method to set simple string error messages with a default  error code ErrorUnknown.</short>
        protected void SetError(string errorMessage, int code) {
            interceptor.Invoke("setError$$", "setError(const QString&, int) const", typeof(void), typeof(string), errorMessage, typeof(int), code);
        }
        protected void SetError(string errorMessage) {
            interceptor.Invoke("setError$", "setError(const QString&) const", typeof(void), typeof(string), errorMessage);
        }
        protected new ILocalSocketClientSignals Emit {
            get { return (ILocalSocketClientSignals) Q_EMIT; }
        }
    }

    public interface ILocalSocketClientSignals : IQObjectSignals {
    }
}
