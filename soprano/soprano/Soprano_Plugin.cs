//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano {
    using Soprano;
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class Plugin plugin.h Soprano/Plugin
    ///  \brief Base class for all plugins in %Soprano.
    ///  Each %Soprano %Plugin has a name which can be read via
    ///  pluginName().
    ///  \sa Soprano.PluginManager
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///      </remarks>        <short>    \class Plugin plugin.</short>
    [SmokeClass("Soprano::Plugin")]
    public class Plugin : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected Plugin(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Plugin), this);
        }
        public string PluginName() {
            return (string) interceptor.Invoke("pluginName", "pluginName() const", typeof(string));
        }
        /// <remarks>
        ///  This method can be reimplemented by plugins that need
        ///  to do additional run-time checks before they can be used.
        ///  The default implementation returns <pre>true</pre>.
        ///  \return <pre>true</pre> if the plugin can be used.
        ///          </remarks>        <short>    This method can be reimplemented by plugins that need  to do additional run-time checks before they can be used.</short>
        [SmokeMethod("isAvailable() const")]
        public virtual bool IsAvailable() {
            return (bool) interceptor.Invoke("isAvailable", "isAvailable() const", typeof(bool));
        }
        public Plugin(string name) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Plugin$", "Plugin(const QString&)", typeof(void), typeof(string), name);
        }
        ~Plugin() {
            interceptor.Invoke("~Plugin", "~Plugin()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~Plugin", "~Plugin()", typeof(void));
        }
    }
}
