//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano.Error {
    using Soprano;
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class Error error.h Soprano/Error/Error
    ///  \brief Represents an error in %Soprano.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///  \sa \ref soprano_error_handling
    ///          </remarks>        <short>    \class Error error.</short>
    [SmokeClass("Soprano::Error::Error")]
    public class Error : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected Error(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Error), this);
        }
        // Soprano::Error::Error* Error(); >>>> NOT CONVERTED
        // Soprano::Error::Error* Error(const QString& arg1,int arg2); >>>> NOT CONVERTED
        // Soprano::Error::Error* Error(const QString& arg1); >>>> NOT CONVERTED
        // Soprano::Error::Error* Error(const Soprano::Error::Error& arg1); >>>> NOT CONVERTED
        //  operator bool(); >>>> NOT CONVERTED
        // Soprano::Error::Error* Error(Soprano::Error::ErrorData* arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Create an Error object, representing success, i.e. no error.
        ///              </remarks>        <short>    Create an Error object, representing success, i.</short>
        /// <remarks>
        ///  Create an Error object.
        ///  \param message A human-readable error message.
        ///  \param code An optional machine-readable error code. Can be one of Soprano.ErrorCode
        ///  or a user defined value which has to be bigger than ErrorUnknown. The redland backend
        ///  for example uses error codes <i>ErrorUnknown + redlandCode</i>.
        ///              </remarks>        <short>    Create an Error object.</short>
        /// <remarks>
        ///  An %Error evalutes to a boolean, indicating if an %Error is "set".
        ///  \return <pre>false</pre> if code() == #ErrorNone, <pre>true</pre> otherwise.
        ///  Thus, an Error object can easily be checked as follows:
        ///  <pre>
        ///  model.addStatement( s );
        ///  if( model.lastError() ) {
        ///     displayError( model.lastError() );
        ///  }
        ///  </pre>
        ///              </remarks>        <short>    An %Error evalutes to a boolean, indicating if an %Error is "set".</short>
        /// <remarks>
        ///  A string explaining the error in detail.
        ///  This string is not necessarily translated (this
        ///  depends on the plugin implementation).
        ///  \return An error message describing the error or an empty string
        ///  for no-error (i.e. success) instances.
        ///              </remarks>        <short>    A string explaining the error in detail.</short>
        public string Message() {
            return (string) interceptor.Invoke("message", "message() const", typeof(string));
        }
        /// <remarks>
        ///  An error code. If the error code is #ErrorNone the
        ///  Error instance represents success.
        ///  The code can either be one of the values of ErrorCode
        ///  or a value above #ErrorUnknown.
        ///  Example: The redland backend defines the error code
        ///  as:
        ///  <pre>
        ///  ErrorUnknown + librdf_log_message_code()
        ///  </pre>
        ///  \sa ErrorCode
        ///              </remarks>        <short>    An error code.</short>
        public int Code() {
            return (int) interceptor.Invoke("code", "code() const", typeof(int));
        }
        /// <remarks>
        ///  \return <pre>true</pre> if this Error instance represents a parser error.
        ///  In that case the error can be converted to a ParserError.
        ///              </remarks>        <short>    \return \p true if this Error instance represents a parser error.</short>
        public bool IsParserError() {
            return (bool) interceptor.Invoke("isParserError", "isParserError() const", typeof(bool));
        }
        /// <remarks>
        ///  Converts this error into a ParserError.
        ///  This has the same effect as
        ///  <pre>
        ///  Error e;
        ///  ParserError p1( e );
        ///  </pre>
        ///  \return If isParserError() returns true a ParserError
        ///  with a valid Locator value, otherwise a ParserError with
        ///  an empty Locator.
        ///              </remarks>        <short>    Converts this error into a ParserError.</short>
        public Soprano.Error.ParserError ToParserError() {
            return (Soprano.Error.ParserError) interceptor.Invoke("toParserError", "toParserError() const", typeof(Soprano.Error.ParserError));
        }
        ~Error() {
            interceptor.Invoke("~Error", "~Error()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~Error", "~Error()", typeof(void));
        }
    }
}
