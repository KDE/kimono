//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano {
    using Soprano;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  Different types of RDF serialization.
    ///      </remarks>        <short>    Different types of RDF serialization.</short>
    public enum RdfSerialization {
        SerializationUnknown = 0x0,
        SerializationRdfXml = 0x1,
        SerializationN3 = 0x2,
        SerializationNTriples = 0x4,
        SerializationTurtle = 0x8,
        SerializationTrig = 0x10,
        SerializationNQuads = 0x20,
        SerializationUser = 0x0,
    }
    /// <remarks>
    ///  There are two types of backend settings: boolean flags and key/value pairs.
    ///  The boolean flags are identified by BackendFlag.
    ///  \sa BackendSetting, Backend.CreateModel()
    ///      </remarks>        <short>    There are two types of backend settings: boolean flags and key/value pairs.</short>
    public enum BackendOption {
        BackendOptionNone = 0x0,
        BackendOptionStorageMemory = 0x1,
        BackendOptionEnableInference = 0x2,
        BackendOptionStorageDir = 0x4,
        BackendOptionUser = 0x1000,
    }
    /// <remarks>
    ///  Each Backend plugin can support different features. %Soprano defines a list of well-known features
    ///  that each backend implementation should try to realize. In addition user features can be defined.
    ///  For this BackendFeatureUser has to be included in the supported features. Then additional features
    ///  may be reported through Backend.SupportedUserFeatures().
    ///  \sa Backend.SupportedFeatures(), Backend.SupportedUserFeatures()
    ///      </remarks>        <short>    Each Backend plugin can support different features.</short>
    public enum BackendFeature {
        BackendFeatureNone = 0x0,
        BackendFeatureAddStatement = 0x1,
        BackendFeatureRemoveStatements = 0x2,
        BackendFeatureListStatements = 0x4,
        BackendFeatureQuery = 0x8,
        BackendFeatureInference = 0x10,
        BackendFeatureInferenceOptional = 0x20,
        BackendFeatureContext = 0x40,
        BackendFeatureStorageMemory = 0x80,
        BackendFeatureUser = 0x1000,
    }
    /// <remarks> \endcond </remarks>        <short>   \endcond </short>
    [SmokeClass("Soprano")]
    public class Global {
        private static SmokeInvocation staticInterceptor = null;
        static Global() {
            staticInterceptor = new SmokeInvocation(typeof(Global), null);
        }
        // const Soprano::Backend* discoverBackendByName(const QString& arg1); >>>> NOT CONVERTED
        // const Soprano::Backend* discoverBackendByFeatures(Soprano::BackendFeatures arg1,const QStringList& arg2); >>>> NOT CONVERTED
        // const Soprano::Backend* discoverBackendByFeatures(Soprano::BackendFeatures arg1); >>>> NOT CONVERTED
        // void setUsedBackend(const Soprano::Backend* arg1); >>>> NOT CONVERTED
        // const Soprano::Backend* usedBackend(); >>>> NOT CONVERTED
        // Soprano::Model* createModel(const QList<Soprano::BackendSetting>& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Find a backend plugin by its name.
        ///  \return the backend specified by \a name or null if could not
        ///  be found.
        ///      </remarks>        <short>    Find a backend plugin by its name.</short>
        /// <remarks>
        ///  Find a backend plugin by its features.
        ///  \param features The features that are requested.
        ///  \param userFeatures If features contain Soprano.BackendFeatureUser this paramter states the additionally requested user features.
        ///  \return a backend that supports the features defined in \a features.
        ///  \sa PluginManager.DiscoverBackendByFeatures()
        ///      </remarks>        <short>    Find a backend plugin by its features.</short>
        /// <remarks>
        ///  By default and if available backend "redland" is used.
        ///      </remarks>        <short>    By default and if available backend "redland" is used.</short>
        /// <remarks>
        ///  Creates a new RDF storage using the backend set via setUsedBackend.
        ///  The caller takes ownership and has to care about deletion.
        ///  \param settings The settings that should be used to create the Model. Backend implementations
        ///   should never ignore settings but rather return 0 if an option is not supported. Backends can,
        ///  however, define their own default settings.
        ///  \sa Model, Backend.CreateModel
        ///      </remarks>        <short>    Creates a new RDF storage using the backend set via setUsedBackend.</short>
        /// <remarks>
        ///  @brief Returns the major number of Soprano's version, e.g.
        ///  1 for %Soprano 1.0.2.
        /// </remarks>        <return> the major version number at runtime.
        ///      </return>
        ///         <short>    @brief Returns the major number of Soprano's version, e.</short>
        public static uint VersionMajor() {
            return (uint) staticInterceptor.Invoke("versionMajor", "versionMajor()", typeof(uint));
        }
        /// <remarks>
        ///  @brief Returns the minor number of Soprano's version, e.g.
        ///  0 for %Soprano 1.0.2.
        /// </remarks>        <return> the minor version number at runtime.
        ///      </return>
        ///         <short>    @brief Returns the minor number of Soprano's version, e.</short>
        public static uint VersionMinor() {
            return (uint) staticInterceptor.Invoke("versionMinor", "versionMinor()", typeof(uint));
        }
        /// <remarks>
        ///  @brief Returns the release of Soprano's version, e.g.
        ///  2 for %Soprano 1.0.2.
        /// </remarks>        <return> the release number at runtime.
        ///      </return>
        ///         <short>    @brief Returns the release of Soprano's version, e.</short>
        public static uint VersionRelease() {
            return (uint) staticInterceptor.Invoke("versionRelease", "versionRelease()", typeof(uint));
        }
        /// <remarks>
        ///  @brief Returns the %Soprano version as string, e.g. "1.0.2".
        ///  On contrary to the macro SOPRANO_VERSION_STRING this function returns
        ///  the version number of Soprano at runtime.
        /// </remarks>        <return> the %Soprano version. You can keep the string forever
        ///      </return>
        ///         <short>    @brief Returns the %Soprano version as string, e.</short>
        public static string VersionString() {
            return (string) staticInterceptor.Invoke("versionString", "versionString()", typeof(string));
        }
        /// <remarks>
        ///  Get the mimetype string of a serialization.
        ///  \param serialization The serialization the mimetype is wanted for.
        ///  \param userSerialization If <pre>serialization</pre> is SerializationUser then this is the user defined serialization.
        ///         (this parameter is added for convinience to avoid having an additional check before using this method.)
        ///  \return The mimetype of serialization, an empty string is serialization is SerializationUnknown, or 
        ///  <pre>userSerialization</pre> if <pre>serialization</pre> is SerializationUser.
        ///      </remarks>        <short>    Get the mimetype string of a serialization.</short>
        public static string SerializationMimeType(Soprano.RdfSerialization serialization, string userSerialization) {
            return (string) staticInterceptor.Invoke("serializationMimeType$$", "serializationMimeType(Soprano::RdfSerialization, const QString&)", typeof(string), typeof(Soprano.RdfSerialization), serialization, typeof(string), userSerialization);
        }
        public static string SerializationMimeType(Soprano.RdfSerialization serialization) {
            return (string) staticInterceptor.Invoke("serializationMimeType$", "serializationMimeType(Soprano::RdfSerialization)", typeof(string), typeof(Soprano.RdfSerialization), serialization);
        }
        /// <remarks>
        ///  Parse a mimetype and match it to the Soprano.RdfSerialization enum.
        ///  \return the Soprano.RdfSerialization type that matches mimetype or SerializationUnknown if the mimetype 
        ///  could not be parsed. Be aware that Soprano is very lax in parsing the mimetype, i.e. you can use simple
        ///  strings like 'trig' or 'n-quads' instead of the proper mimetype for convenience.
        ///      </remarks>        <short>    Parse a mimetype and match it to the Soprano.RdfSerialization enum.</short>
        public static Soprano.RdfSerialization MimeTypeToSerialization(string mimetype) {
            return (Soprano.RdfSerialization) staticInterceptor.Invoke("mimeTypeToSerialization$", "mimeTypeToSerialization(const QString&)", typeof(Soprano.RdfSerialization), typeof(string), mimetype);
        }
    }
}
