//Auto-generated by kalyptus. DO NOT EDIT.
namespace Soprano.Client {
    using Soprano;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  \class DBusClient dbusclient.h Soprano/Client/DBusClient
    ///  \brief Core class to handle a connection to a Soprano server through the
    ///  DBus interface.
    ///  DBusClient creates a connection to a running Soprano Server via its DBus
    ///  interface. All DBus communication is handled internally.
    ///  See DBusModel for details about thread-safety.
    ///  \author Sebastian Trueg <trueg@kde.org>
    ///  \sa \ref soprano_server_dbus
    ///          </remarks>        <short>    \class DBusClient dbusclient.</short>
    [SmokeClass("Soprano::Client::DBusClient")]
    public class DBusClient : QObject, Soprano.Error.IErrorCache, IDisposable {
        protected DBusClient(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(DBusClient), this);
        }
        // Error lastError(); >>>> NOT CONVERTED
        // void setError(const Error& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Create a new DBus client.
        ///  \param service The DBus service name. If empty the client will use the
        ///  default Soprano service name.
        ///  \param parent The parent object.
        ///              </remarks>        <short>    Create a new DBus client.</short>
        public DBusClient(string service, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("DBusClient$#", "DBusClient(const QString&, QObject*)", typeof(void), typeof(string), service, typeof(QObject), parent);
        }
        public DBusClient(string service) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("DBusClient$", "DBusClient(const QString&)", typeof(void), typeof(string), service);
        }
        public DBusClient() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("DBusClient", "DBusClient()", typeof(void));
        }
        /// <remarks>
        ///  Check if the service is valid and available.
        ///  \return <pre>true</pre> if the Soprano server service could be found and used.
        ///  Otherwise returns <pre>false</pre>.
        ///              </remarks>        <short>    Check if the service is valid and available.</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        ///  Retrive a list of all models that are available.
        ///  \return A list of model names to be used with createModel()
        ///              </remarks>        <short>    Retrive a list of all models that are available.</short>
        public List<string> AllModels() {
            return (List<string>) interceptor.Invoke("allModels", "allModels() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Creates a new Model instance that wraps a dbus server model.
        ///  \param name The name of the model to access.
        ///  \param settings Settings for future extension. Not used yet.
        ///  \return A new Model instance wrapping the requested server
        ///  model or 0 on error (check lastError() for details.)
        ///              </remarks>        <short>    Creates a new Model instance that wraps a dbus server model.</short>
        public Soprano.Client.DBusModel CreateModel(string name, List<Soprano.BackendSetting> settings) {
            return (Soprano.Client.DBusModel) interceptor.Invoke("createModel$?", "createModel(const QString&, const QList<Soprano::BackendSetting>&)", typeof(Soprano.Client.DBusModel), typeof(string), name, typeof(List<Soprano.BackendSetting>), settings);
        }
        public Soprano.Client.DBusModel CreateModel(string name) {
            return (Soprano.Client.DBusModel) interceptor.Invoke("createModel$", "createModel(const QString&)", typeof(Soprano.Client.DBusModel), typeof(string), name);
        }
        /// <remarks>
        ///  Deletes a model including all its data.
        ///  \param name The name of the model to remove.
        ///  \warning Calling this method will remove all data physically. It can not
        ///  be reverted. Use with care.
        ///              </remarks>        <short>    Deletes a model including all its data.</short>
        public void RemoveModel(string name) {
            interceptor.Invoke("removeModel$", "removeModel(const QString&)", typeof(void), typeof(string), name);
        }
        ~DBusClient() {
            interceptor.Invoke("~DBusClient", "~DBusClient()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~DBusClient", "~DBusClient()", typeof(void));
        }
        /// <remarks>
        ///  Get the last error that occured in the current thread.
        ///              </remarks>        <short>    Get the last error that occured in the current thread.</short>
        /// <remarks>
        ///  Reset the error for the current thread to no error.
        ///              </remarks>        <short>    Reset the error for the current thread to no error.</short>
        protected void ClearError() {
            interceptor.Invoke("clearError", "clearError() const", typeof(void));
        }
        /// <remarks>
        ///  Set the last occured error. This method is const to allow setting
        ///  of errors in all types of methods. The last error is as such a 
        ///  mutable property.
        ///              </remarks>        <short>    Set the last occured error.</short>
        /// <remarks>
        ///  Convenience method to set simple string error messages with a default
        ///  error code ErrorUnknown.
        ///              </remarks>        <short>    Convenience method to set simple string error messages with a default  error code ErrorUnknown.</short>
        protected void SetError(string errorMessage, int code) {
            interceptor.Invoke("setError$$", "setError(const QString&, int) const", typeof(void), typeof(string), errorMessage, typeof(int), code);
        }
        protected void SetError(string errorMessage) {
            interceptor.Invoke("setError$", "setError(const QString&) const", typeof(void), typeof(string), errorMessage);
        }
        protected new IDBusClientSignals Emit {
            get { return (IDBusClientSignals) Q_EMIT; }
        }
    }

    public interface IDBusClientSignals : IQObjectSignals {
    }
}
