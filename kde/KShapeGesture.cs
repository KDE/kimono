//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    [SmokeClass("KShapeGesture")]
    public class KShapeGesture : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KShapeGesture(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KShapeGesture), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KShapeGesture() {
            staticInterceptor = new SmokeInvocation(typeof(KShapeGesture), null);
        }
        /// <remarks>
        ///  Create a new invalid shape gesture.
        ///      </remarks>        <short>    Create a new invalid shape gesture.</short>
        public KShapeGesture() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KShapeGesture", "KShapeGesture()", typeof(void));
        }
        /// <remarks>
        ///  Creates a new gesture consisting of given shape.
        ///  If the gesture belongs to a KAction, and the user draws approximately the same shape
        ///  on the screen while holding down the right mouse button, the action will trigger.
        ///  <code>shape</code> must be a "reasonable" polygon. It must contain at least two points
        ///  and it should contain at most 50 for performance reasons. No two consecutive points
        ///  are allowed to be at the same position.
        /// <param> name="shape" shape to draw to trigger this gesture
        ///      </param></remarks>        <short>    Creates a new gesture consisting of given shape.</short>
        public KShapeGesture(QPolygon shape) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KShapeGesture#", "KShapeGesture(const QPolygon&)", typeof(void), typeof(QPolygon), shape);
        }
        /// <remarks>
        ///  Creates a new gesture from a string description.
        /// <param> name="description" create gesture according to this
        ///      </param></remarks>        <short>    Creates a new gesture from a string description.</short>
        public KShapeGesture(string description) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KShapeGesture$", "KShapeGesture(const QString&)", typeof(void), typeof(string), description);
        }
        /// <remarks>
        ///  Copies the given gesture.
        /// <param> name="other" gesture to copy
        ///      </param></remarks>        <short>    Copies the given gesture.</short>
        public KShapeGesture(KShapeGesture other) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KShapeGesture#", "KShapeGesture(const KShapeGesture&)", typeof(void), typeof(KShapeGesture), other);
        }
        /// <remarks>
        ///  Set the shape to draw to trigger this gesture.
        ///      </remarks>        <short>    Set the shape to draw to trigger this gesture.</short>
        public void SetShape(QPolygon shape) {
            interceptor.Invoke("setShape#", "setShape(const QPolygon&)", typeof(void), typeof(QPolygon), shape);
        }
        /// <remarks>
        ///  set a user-visible name for this gesture's shape, like "triangle" or "line".
        ///      </remarks>        <short>    set a user-visible name for this gesture's shape, like "triangle" or "line".</short>
        public void SetShapeName(string friendlyName) {
            interceptor.Invoke("setShapeName$", "setShapeName(const QString&)", typeof(void), typeof(string), friendlyName);
        }
        /// <remarks>
        ///  Return the user-visible name for this gesture's shape, like "triangle" or "line".
        ///      </remarks>        <short>    Return the user-visible name for this gesture's shape, like "triangle" or "line".</short>
        public string ShapeName() {
            return (string) interceptor.Invoke("shapeName", "shapeName() const", typeof(string));
        }
        /// <remarks>
        ///  Return true if this gesture is valid.
        ///      </remarks>        <short>    Return true if this gesture is valid.</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        ///  Return a string representation of this gesture.
        ///  Return empty string if invalid.
        ///  This function is mainly for use with config files.
        /// </remarks>        <short>    Return a string representation of this gesture.</short>
        ///         <see> shapeName</see>
        public new string ToString() {
            return (string) interceptor.Invoke("toString", "toString() const", typeof(string));
        }
        /// <remarks>
        ///  Return an idealized SVG image of this gesture.
        ///  Return an empty image if invalid.
        /// <param> name="attributes" SVG attributes to apply to the SVG "path" element that
        ///  makes up the drawing of the gesture. By default, only a 'fill="none"'
        ///  attribute will be set.
        ///      </param></remarks>        <short>    Return an idealized SVG image of this gesture.</short>
        public QByteArray ToSvg(string attributes) {
            return (QByteArray) interceptor.Invoke("toSvg$", "toSvg(const QString&) const", typeof(QByteArray), typeof(string), attributes);
        }
        public QByteArray ToSvg() {
            return (QByteArray) interceptor.Invoke("toSvg", "toSvg() const", typeof(QByteArray));
        }
        /// <remarks>
        ///  Return a difference measurement betwenn this gesture and the <code>other</code>
        ///  gesture. Abort comparison if difference is larger than <code>abortThreshold</code>
        ///  and return a very large difference in that case.
        ///  Usual return values range from x to y //TODO: fill in x and y
        ///      </remarks>        <short>    Return a difference measurement betwenn this gesture and the <code>other</code>  gesture.</short>
        public float Distance(KShapeGesture other, float abortThreshold) {
            return (float) interceptor.Invoke("distance#$", "distance(const KShapeGesture&, float) const", typeof(float), typeof(KShapeGesture), other, typeof(float), abortThreshold);
        }
        /// <remarks>
        ///  Return whether this gesture is equal to the other gesture.
        ///      </remarks>        <short>    Return whether this gesture is equal to the other gesture.</short>
        public override bool Equals(object o) {
            if (!(o is KShapeGesture)) { return false; }
            return this == (KShapeGesture) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        /// <remarks>
        ///  Return an opaque value for use in hash tables
        ///      </remarks>        <short>    Return an opaque value for use in hash tables      </short>
        public uint Hashable() {
            return (uint) interceptor.Invoke("hashable", "hashable() const", typeof(uint));
        }
        ~KShapeGesture() {
            interceptor.Invoke("~KShapeGesture", "~KShapeGesture()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KShapeGesture", "~KShapeGesture()", typeof(void));
        }
        public static bool operator==(KShapeGesture lhs, KShapeGesture other) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KShapeGesture&) const", typeof(bool), typeof(KShapeGesture), lhs, typeof(KShapeGesture), other);
        }
        public static bool operator!=(KShapeGesture lhs, KShapeGesture other) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KShapeGesture&) const", typeof(bool), typeof(KShapeGesture), lhs, typeof(KShapeGesture), other);
        }
    }
}
