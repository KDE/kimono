//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  The KCursor class extends QCursor with the ability to create an arbitrary
    ///  named cursor from the cursor theme, and provides a set of static
    ///  convenience methods for auto-hiding cursors on widgets.
    /// </remarks>        <author> Kurt Granroth <granroth@kde.org>
    ///  </author>
    ///         <short>    The KCursor class extends QCursor with the ability to create an arbitrary  named cursor from the cursor theme, and provides a set of static  convenience methods for auto-hiding cursors on widgets.</short>
    [SmokeClass("KCursor")]
    public class KCursor : QCursor, IDisposable {
        protected KCursor(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KCursor), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KCursor() {
            staticInterceptor = new SmokeInvocation(typeof(KCursor), null);
        }
        /// <remarks>
        ///  Attempts to load the requested <code>name</code> cursor from the current theme.
        ///  This allows one to access cursors that may be in a theme but not in
        ///  the Qt.CursorShape enum.
        ///  If the specified cursor doesn't exist in the theme, or if KDE was
        ///  built without Xcursor support, the cursor will be loaded from the X11
        ///  cursor font instead. If the cursor doesn't exist in the cursor font,
        ///  it falls back to the Qt.CursorShape provided as the second parameter.
        ///  On platforms other than X11, the fallback shape is always used.
        /// <param> name="name" the name of the cursor to try and load
        /// </param><param> name="fallback" the cursor to load if <code>name</code> cursor can not be loaded
        ///      </param></remarks>        <short>    Attempts to load the requested <code>name</code> cursor from the current theme.</short>
        public KCursor(string name, Qt.CursorShape fallback) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCursor$$", "KCursor(const QString&, Qt::CursorShape)", typeof(void), typeof(string), name, typeof(Qt.CursorShape), fallback);
        }
        public KCursor(string name) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCursor$", "KCursor(const QString&)", typeof(void), typeof(string), name);
        }
        /// <remarks>
        ///  Creates a copy of <code>cursor.</code>
        ///      </remarks>        <short>    Creates a copy of <code>cursor.</code></short>
        public KCursor(QCursor cursor) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCursor#", "KCursor(const QCursor&)", typeof(void), typeof(QCursor), cursor);
        }
        ~KCursor() {
            interceptor.Invoke("~KCursor", "~KCursor()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KCursor", "~KCursor()", typeof(void));
        }
        /// <remarks>
        ///  Sets auto-hiding the cursor for widget <code>w.</code> Enabling it will result in
        ///  the cursor being hidden when
        /// 
        /// <li>
        /// a key-event happens
        /// </li>
        /// 
        /// <li>
        /// there are no key-events for a configured time-frame (see
        ///  setHideCursorDelay())
        /// </li>
        ///  The cursor will be shown again when the focus is lost or a mouse-event
        ///  happens.
        ///  Side effect: when enabling auto-hide, mouseTracking is enabled for the
        ///  specified widget, because it's needed to get mouse-move-events. So
        ///  don't disable mouseTracking for a widget while using auto-hide for it.
        ///  When disabling auto-hide, mouseTracking will be disabled, so if you need
        ///  mouseTracking after disabling auto-hide, you have to reenable
        ///  mouseTracking.
        ///  If you want to use auto-hiding for widgets that don't take focus, e.g.
        ///  a QCanvasView, then you have to pass all key-events that should trigger
        ///  auto-hiding to autoHideEventFilter().
        ///      </remarks>        <short>    Sets auto-hiding the cursor for widget <code>w.</code></short>
        public static void SetAutoHideCursor(QWidget w, bool enable, bool customEventFilter) {
            staticInterceptor.Invoke("setAutoHideCursor#$$", "setAutoHideCursor(QWidget*, bool, bool)", typeof(void), typeof(QWidget), w, typeof(bool), enable, typeof(bool), customEventFilter);
        }
        public static void SetAutoHideCursor(QWidget w, bool enable) {
            staticInterceptor.Invoke("setAutoHideCursor#$", "setAutoHideCursor(QWidget*, bool)", typeof(void), typeof(QWidget), w, typeof(bool), enable);
        }
        /// <remarks>
        ///  Sets the delay time in milliseconds for auto-hiding. When no keyboard
        ///  events arrive for that time-frame, the cursor will be hidden.
        ///  Default is 5000, i.e. 5 seconds.
        ///      </remarks>        <short>    Sets the delay time in milliseconds for auto-hiding.</short>
        public static void SetHideCursorDelay(int ms) {
            staticInterceptor.Invoke("setHideCursorDelay$", "setHideCursorDelay(int)", typeof(void), typeof(int), ms);
        }
        /// <remarks>
        ///  Default is 5000, i.e. 5 seconds.
        ///      </remarks>        <return> the current auto-hide delay time.
        /// </return>
        ///         <short>   </short>
        public static int HideCursorDelay() {
            return (int) staticInterceptor.Invoke("hideCursorDelay", "hideCursorDelay()", typeof(int));
        }
        /// <remarks>
        ///  KCursor has to install an eventFilter over the widget you want to
        ///  auto-hide. If you have an own eventFilter() on that widget and stop
        ///  some events by returning true, you might break auto-hiding, because
        ///  KCursor doesn't get those events.
        ///  In this case, you need to call setAutoHideCursor( widget, true, true );
        ///  to tell KCursor not to install an eventFilter. Then you call this method
        ///  from the beginning of your eventFilter, for example:
        ///  <pre>
        ///  edit = new KEdit( this, "some edit widget" );
        ///  edit.InstallEventFilter( this );
        ///  KCursor.SetAutoHideCursor( edit, true, true );
        ///  [...]
        ///  bool YourClass.EventFilter( QObject o, QEvent e )
        ///  {
        ///      if ( o == edit ) // only that widget where you enabled auto-hide!
        ///          KCursor.AutoHideEventFilter( o, e );
        ///      // now you can do your own event-processing
        ///      [...]
        ///  }
        ///  </pre>
        ///  Note that you must not call KCursor.AutoHideEventFilter() when you
        ///  didn't enable or after disabling auto-hiding.
        ///      </remarks>        <short>    KCursor has to install an eventFilter over the widget you want to  auto-hide.</short>
        public static void AutoHideEventFilter(QObject arg1, QEvent arg2) {
            staticInterceptor.Invoke("autoHideEventFilter##", "autoHideEventFilter(QObject*, QEvent*)", typeof(void), typeof(QObject), arg1, typeof(QEvent), arg2);
        }
    }
}
