//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  This is a convenience class for KService. You can use it if you have
    ///  a KService describing a KDataTool. In this case the KDataToolInfo class
    ///  is more convenient to work with.
    ///  Especially useful is the method createTool which creates the datatool
    ///  described by the service.
    /// </remarks>        <short>    This is a convenience class for KService.</short>
    ///         <see> KDataTool</see>
    [SmokeClass("KDataToolInfo")]
    public class KDataToolInfo : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KDataToolInfo(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KDataToolInfo), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KDataToolInfo() {
            staticInterceptor = new SmokeInvocation(typeof(KDataToolInfo), null);
        }
        /// <remarks>
        ///  Create an invalid KDataToolInfo.
        ///      </remarks>        <short>    Create an invalid KDataToolInfo.</short>
        public KDataToolInfo() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KDataToolInfo", "KDataToolInfo()", typeof(void));
        }
        /// <remarks>
        ///  Create a valid KDataToolInfo.
        /// <param> name="service" the corresponding service
        /// </param><param> name="instance" the instance to use
        ///      </param></remarks>        <short>    Create a valid KDataToolInfo.</short>
        public KDataToolInfo(KService service, KComponentData instance) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KDataToolInfo?#", "KDataToolInfo(const KSharedPtr<KService>&, const KComponentData&)", typeof(void), typeof(KService), service, typeof(KComponentData), instance);
        }
        /// <remarks>
        ///  Copy constructor.
        ///      </remarks>        <short>    Copy constructor.</short>
        public KDataToolInfo(KDataToolInfo info) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KDataToolInfo#", "KDataToolInfo(const KDataToolInfo&)", typeof(void), typeof(KDataToolInfo), info);
        }
        /// <remarks>
        ///  Returns the data type that the DataTool can accept.
        /// </remarks>        <return> the C++ data type that this DataTool accepts.
        ///          For example "string" or "QImage" or something more
        ///          complicated.
        ///      </return>
        ///         <short>    Returns the data type that the DataTool can accept.</short>
        public string DataType() {
            return (string) interceptor.Invoke("dataType", "dataType() const", typeof(string));
        }
        /// <remarks>
        ///  Returns a list of mime type that will be accepted by the DataTool.
        ///  The mimetypes are only used if the dataType can be used to store
        ///  different mimetypes. For example in a "string" you could save "text/plain"
        ///  or "text/html" or "text/xml".
        /// </remarks>        <return> the mime types accepted by this DataTool. For example
        ///          "image/gif" or "text/plain". In some cases the dataType
        ///          determines the accepted type of data perfectly. In this cases
        ///          this list may be empty.
        ///      </return>
        ///         <short>    Returns a list of mime type that will be accepted by the DataTool.</short>
        public List<string> MimeTypes() {
            return (List<string>) interceptor.Invoke("mimeTypes", "mimeTypes() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Checks whether the DataTool is read-only.
        /// </remarks>        <return> true if the DataTool does not modify the data passed to it by KDataTool.Run.
        ///      </return>
        ///         <short>    Checks whether the DataTool is read-only.</short>
        public bool IsReadOnly() {
            return (bool) interceptor.Invoke("isReadOnly", "isReadOnly() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns the icon name for this DataTool.
        /// </remarks>        <return> the name of the icon for the DataTool
        ///      </return>
        ///         <short>    Returns the icon name for this DataTool.</short>
        public string IconName() {
            return (string) interceptor.Invoke("iconName", "iconName() const", typeof(string));
        }
        /// <remarks>
        ///  Returns a list of strings that you can put in a QPopupMenu item, for example to
        ///  offer the DataTools services to the user. The returned value
        ///  is usually something like "Spell checking", "Shrink Image", "Rotate Image"
        ///  or something like that.
        ///  This list comes from the Comment field of the tool's desktop file
        ///  (so that it can be translated).
        ///  Each of the strings returned corresponds to a string in the list returned by
        ///  commands.
        /// </remarks>        <return> a list of strings that you can put in a QPopupMenu item
        ///      </return>
        ///         <short>    Returns a list of strings that you can put in a QPopupMenu item, for example to  offer the DataTools services to the user.</short>
        public List<string> UserCommands() {
            return (List<string>) interceptor.Invoke("userCommands", "userCommands() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Returns the list of commands the DataTool can execute. The application
        ///  passes the command to the KDataTool.Run method.
        ///  This list comes from the Commands field of the tool's desktop file.
        ///  Each of the strings returned corresponds to a string in the list returned by
        ///  userCommands.
        /// </remarks>        <return> the list of commands the DataTool can execute, suitable for
        ///          the KDataTool.Run method.
        ///      </return>
        ///         <short>    Returns the list of commands the DataTool can execute.</short>
        public List<string> Commands() {
            return (List<string>) interceptor.Invoke("commands", "commands() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Creates the data tool described by this KDataToolInfo.
        /// <param> name="parent" the parent of the QObject (or 0 for parent-less KDataTools)
        /// </param></remarks>        <return> a pointer to the created data tool or 0 on error.
        ///      </return>
        ///         <short>    Creates the data tool described by this KDataToolInfo.</short>
        public KDataTool CreateTool(QObject parent) {
            return (KDataTool) interceptor.Invoke("createTool#", "createTool(QObject*) const", typeof(KDataTool), typeof(QObject), parent);
        }
        public KDataTool CreateTool() {
            return (KDataTool) interceptor.Invoke("createTool", "createTool() const", typeof(KDataTool));
        }
        /// <remarks>
        ///  The KDataToolInfo's service that is represented by this class.
        /// </remarks>        <return> the service
        ///      </return>
        ///         <short>    The KDataToolInfo's service that is represented by this class.</short>
        public KService Service() {
            return (KService) interceptor.Invoke("service", "service() const", typeof(KService));
        }
        /// <remarks>
        ///  The instance of the service.
        /// </remarks>        <return> the instance
        ///      </return>
        ///         <short>    The instance of the service.</short>
        public KComponentData ComponentData() {
            return (KComponentData) interceptor.Invoke("componentData", "componentData() const", typeof(KComponentData));
        }
        /// <remarks>
        ///  A DataToolInfo may be invalid if the KService passed to its constructor does
        ///  not feature the service type "KDataTool".
        /// </remarks>        <return> true if valid, false otherwise
        ///      </return>
        ///         <short>    A DataToolInfo may be invalid if the KService passed to its constructor does  not feature the service type "KDataTool".</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        ~KDataToolInfo() {
            interceptor.Invoke("~KDataToolInfo", "~KDataToolInfo()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KDataToolInfo", "~KDataToolInfo()", typeof(void));
        }
        /// <remarks>
        ///  Queries the KServiceTypeTrader about installed KDataTool implementations.
        /// <param> name="datatype" a type that the application can 'export' to the tools (e.g. string)
        /// </param><param> name="mimetype" the mimetype of the data (e.g. text/plain)
        /// </param><param> name="instance" the application (or the part)'s instance (to check if a tool is excluded from this part,
        ///  and also used if the tool wants to read its configuration in the app's config file).
        /// </param></remarks>        <return> the list of results
        ///      </return>
        ///         <short>    Queries the KServiceTypeTrader about installed KDataTool implementations.</short>
        public static List<KDataToolInfo> Query(string datatype, string mimetype, KComponentData instance) {
            return (List<KDataToolInfo>) staticInterceptor.Invoke("query$$#", "query(const QString&, const QString&, const KComponentData&)", typeof(List<KDataToolInfo>), typeof(string), datatype, typeof(string), mimetype, typeof(KComponentData), instance);
        }
    }
}
