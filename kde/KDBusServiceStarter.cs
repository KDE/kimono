//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Text;
    /// <remarks>
    ///  A generic DBUS service starter, using KServiceTypeTrader.
    ///  The default implementation starts new processes, but this interface can
    ///  also be reimplemented by specific applications to provide dlopened in-process DBus objects.
    ///  This interface is similar to the startServiceByName() function found in QDBusBusService, but
    ///  with the added benefit of using KTrader (and, therefore, additional constraints and the
    ///  ability to search the standard KDE dirs).
    /// </remarks>        <author> David Faure <faure@kde.org>
    ///  </author>
    ///         <short>    A generic DBUS service starter, using KServiceTypeTrader.</short>
    [SmokeClass("KDBusServiceStarter")]
    public class KDBusServiceStarter : Object {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KDBusServiceStarter(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KDBusServiceStarter), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KDBusServiceStarter() {
            staticInterceptor = new SmokeInvocation(typeof(KDBusServiceStarter), null);
        }
        /// <remarks>
        ///  Check if a given DBus service is available - from the serviceType it's supposed to implement.
        ///  The trader is queried to find the preferred application for this serviceType,
        ///  with the constraint that its X-DBus-ServiceName property must be defined.
        ///  Then the DBus server is checked. If the service is not available,
        ///  this method will call startServiceFor to start it.
        /// <param> name="serviceType" the type of service we're looking for
        /// </param><param> name="constraint" see KServiceTypeTrader
        /// </param><param> name="error" On failure, <code>error</code> contains a description of the error
        ///          that occurred. If the pointer is 0, the argument will be
        ///          ignored
        /// </param><param> name="dbusService" On success, <code>dbusService</code> contains the DBus service name
        ///          under which this service is available. If the pointer is 0 the argument
        ///          will be ignored
        /// </param><param> name="flags" for future extensions (currently unused)
        /// </param></remarks>        <return> an error code indicating success (== 0) or failure (> 0).
        ///      </return>
        ///         <short>    Check if a given DBus service is available - from the serviceType it's supposed to implement.</short>
        public int FindServiceFor(string serviceType, string constraint, StringBuilder error, StringBuilder dbusService, int flags) {
            return (int) interceptor.Invoke("findServiceFor$$$$$", "findServiceFor(const QString&, const QString&, QString*, QString*, int)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error, typeof(StringBuilder), dbusService, typeof(int), flags);
        }
        public int FindServiceFor(string serviceType, string constraint, StringBuilder error, StringBuilder dbusService) {
            return (int) interceptor.Invoke("findServiceFor$$$$", "findServiceFor(const QString&, const QString&, QString*, QString*)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error, typeof(StringBuilder), dbusService);
        }
        public int FindServiceFor(string serviceType, string constraint, StringBuilder error) {
            return (int) interceptor.Invoke("findServiceFor$$$", "findServiceFor(const QString&, const QString&, QString*)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error);
        }
        public int FindServiceFor(string serviceType, string constraint) {
            return (int) interceptor.Invoke("findServiceFor$$", "findServiceFor(const QString&, const QString&)", typeof(int), typeof(string), serviceType, typeof(string), constraint);
        }
        public int FindServiceFor(string serviceType) {
            return (int) interceptor.Invoke("findServiceFor$", "findServiceFor(const QString&)", typeof(int), typeof(string), serviceType);
        }
        /// <remarks>
        ///  Find an implementation of the given <code>serviceType</code>,
        ///  and start it, to use its DBus interface.
        ///  The default implementation uses KServiceTypeTrader to find the preferred Application,
        ///  and then starts it using KToolInvocation.StartService...
        ///  However applications (like kontact) can reimplement this method, to provide
        ///  an in-process way of loading the implementation for this service type.
        /// <param> name="serviceType" the type of service we're looking for
        /// </param><param> name="constraint" see KServiceTypeTrader
        /// </param><param> name="error" On failure, <code>error</code> contains a description of the error
        ///          that occurred. If the pointer is 0, the argument will be
        ///          ignored
        /// </param><param> name="dbusService" On success, <code>dbusService</code> contains the DBus service name
        ///          under which this service is available. If the pointer is 0 the argument
        ///          will be ignored
        /// </param><param> name="flags" for future extensions (currently unused)
        /// </param></remarks>        <return> an error code indicating success (== 0) or failure (> 0).
        ///      </return>
        ///         <short>    Find an implementation of the given <code>serviceType</code>,  and start it, to use its DBus interface.</short>
        [SmokeMethod("startServiceFor(const QString&, const QString&, QString*, QString*, int)")]
        public virtual int StartServiceFor(string serviceType, string constraint, StringBuilder error, StringBuilder dbusService, int flags) {
            return (int) interceptor.Invoke("startServiceFor$$$$$", "startServiceFor(const QString&, const QString&, QString*, QString*, int)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error, typeof(StringBuilder), dbusService, typeof(int), flags);
        }
        [SmokeMethod("startServiceFor(const QString&, const QString&, QString*, QString*)")]
        public virtual int StartServiceFor(string serviceType, string constraint, StringBuilder error, StringBuilder dbusService) {
            return (int) interceptor.Invoke("startServiceFor$$$$", "startServiceFor(const QString&, const QString&, QString*, QString*)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error, typeof(StringBuilder), dbusService);
        }
        [SmokeMethod("startServiceFor(const QString&, const QString&, QString*)")]
        public virtual int StartServiceFor(string serviceType, string constraint, StringBuilder error) {
            return (int) interceptor.Invoke("startServiceFor$$$", "startServiceFor(const QString&, const QString&, QString*)", typeof(int), typeof(string), serviceType, typeof(string), constraint, typeof(StringBuilder), error);
        }
        [SmokeMethod("startServiceFor(const QString&, const QString&)")]
        public virtual int StartServiceFor(string serviceType, string constraint) {
            return (int) interceptor.Invoke("startServiceFor$$", "startServiceFor(const QString&, const QString&)", typeof(int), typeof(string), serviceType, typeof(string), constraint);
        }
        [SmokeMethod("startServiceFor(const QString&)")]
        public virtual int StartServiceFor(string serviceType) {
            return (int) interceptor.Invoke("startServiceFor$", "startServiceFor(const QString&)", typeof(int), typeof(string), serviceType);
        }
        public KDBusServiceStarter() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KDBusServiceStarter", "KDBusServiceStarter()", typeof(void));
        }
        public static KDBusServiceStarter Self() {
            return (KDBusServiceStarter) staticInterceptor.Invoke("self", "self()", typeof(KDBusServiceStarter));
        }
    }
}
