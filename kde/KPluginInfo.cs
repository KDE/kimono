//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  Information about a plugin.
    ///  This holds all the information about a plugin there is. It's used for the
    ///  user to decide whether he wants to use this plugin or not.
    /// </remarks>        <author> Matthias Kretz <kretz@kde.org>
    ///  </author>
    ///         <short>    Information about a plugin.</short>
    [SmokeClass("KPluginInfo")]
    public class KPluginInfo : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KPluginInfo(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KPluginInfo), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KPluginInfo() {
            staticInterceptor = new SmokeInvocation(typeof(KPluginInfo), null);
        }
        /// <remarks>
        ///  Read plugin info from <code>filename.</code>
        ///  The file should be of the following form:
        ///  <pre>
        ///            [Desktop Entry]
        ///            Encoding=UTF-8
        ///            Icon=mypluginicon
        ///            Type=Service
        ///            ServiceTypes=KPluginInfo
        ///            Name=User Visible Name
        ///            Comment=Description of what the plugin does
        ///            X-KDE-PluginInfo-Author=Author's Name
        ///            X-KDE-PluginInfo-Email=author@foo.bar
        ///            X-KDE-PluginInfo-Name=internalname
        ///            X-KDE-PluginInfo-Version=1.1
        ///            X-KDE-PluginInfo-Website=http://www.plugin.org/
        ///            X-KDE-PluginInfo-Category=playlist
        ///            X-KDE-PluginInfo-Depends=plugin1,plugin3
        ///            X-KDE-PluginInfo-License=GPL
        ///            X-KDE-PluginInfo-EnabledByDefault=true
        ///            </pre>
        ///  The Name and Comment fields must always be present.
        ///  The "X-KDE-PluginInfo" keys you may add further entries which
        ///  will be available using property(). The Website,Category,Require
        ///  keys are optional.
        ///  For EnabledByDefault look at isPluginEnabledByDefault.
        /// <param> name="filename" The filename of the .desktop file.
        /// </param><param> name="resource" If filename is relative, you need to specify a resource type
        ///  (e.g. "service", "apps"... KStandardDirs). Otherwise,
        ///  resource isn't used.
        ///          </param></remarks>        <short>    Read plugin info from <code>filename.</code></short>
        public KPluginInfo(string filename, string resource) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KPluginInfo$$", "KPluginInfo(const QString&, const char*)", typeof(void), typeof(string), filename, typeof(string), resource);
        }
        public KPluginInfo(string filename) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KPluginInfo$", "KPluginInfo(const QString&)", typeof(void), typeof(string), filename);
        }
        /// <remarks>
        ///  Read plugin info from a KService object.
        ///  The .desktop file should look like this:
        ///  <pre>
        ///            [Desktop Entry]
        ///            Encoding=UTF-8
        ///            Icon=mypluginicon
        ///            Type=Service
        ///            ServiceTypes=KPluginInfo
        ///            X-KDE-PluginInfo-Author=Author's Name
        ///            X-KDE-PluginInfo-Email=author@foo.bar
        ///            X-KDE-PluginInfo-Name=internalname
        ///            X-KDE-PluginInfo-Version=1.1
        ///            X-KDE-PluginInfo-Website=http://www.plugin.org/
        ///            X-KDE-PluginInfo-Category=playlist
        ///            X-KDE-PluginInfo-Depends=plugin1,plugin3
        ///            X-KDE-PluginInfo-License=GPL
        ///            X-KDE-PluginInfo-EnabledByDefault=true
        ///            Name=User Visible Name
        ///            Comment=Description of what the plugin does
        ///            </pre>
        ///  In the first three entries the Icon entry is optional.
        ///          </remarks>        <short>    Read plugin info from a KService object.</short>
        public KPluginInfo(KService service) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KPluginInfo?", "KPluginInfo(const KSharedPtr<KService>)", typeof(void), typeof(KService), service);
        }
        /// <remarks>
        ///  Creates an invalid plugin.
        ///  \see isValid
        ///          </remarks>        <short>    Creates an invalid plugin.</short>
        public KPluginInfo() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KPluginInfo", "KPluginInfo()", typeof(void));
        }
        /// <remarks>
        /// </remarks>        <return> Whether the plugin should be hidden.
        ///          </return>
        ///         <short>   </short>
        public bool IsHidden() {
            return (bool) interceptor.Invoke("isHidden", "isHidden() const", typeof(bool));
        }
        /// <remarks>
        ///  Set whether the plugin is currently loaded.
        /// </remarks>        <short>    Set whether the plugin is currently loaded.</short>
        ///         <see> isPluginEnabled</see>
        ///         <see> save</see>
        public void SetPluginEnabled(bool enabled) {
            interceptor.Invoke("setPluginEnabled$", "setPluginEnabled(bool)", typeof(void), typeof(bool), enabled);
        }
        /// <remarks>
        /// </remarks>        <return> Whether the plugin is currently loaded.
        /// </return>
        ///         <short>   </short>
        ///         <see> setPluginEnabled</see>
        ///         <see> load</see>
        public bool IsPluginEnabled() {
            return (bool) interceptor.Invoke("isPluginEnabled", "isPluginEnabled() const", typeof(bool));
        }
        /// <remarks>
        /// </remarks>        <return> The default value whether the plugin is enabled or not.
        ///  Defaults to the value set in the desktop file, or if that isn't set
        ///  to false.
        ///          </return>
        ///         <short>   </short>
        public bool IsPluginEnabledByDefault() {
            return (bool) interceptor.Invoke("isPluginEnabledByDefault", "isPluginEnabledByDefault() const", typeof(bool));
        }
        /// <remarks>
        /// </remarks>        <return> The value associated to the <code>key.</code> You can use it if you
        ///          want to read custom values. To do this you need to define
        ///          your own servicetype and add it to the ServiceTypes keys.
        ///          </return>
        ///         <short>   </short>
        public QVariant Property(string key) {
            return (QVariant) interceptor.Invoke("property$", "property(const QString&) const", typeof(QVariant), typeof(string), key);
        }
        /// <remarks>
        /// </remarks>        <return> The user visible name of the plugin.
        ///          </return>
        ///         <short>   </short>
        public string Name() {
            return (string) interceptor.Invoke("name", "name() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> A comment describing the plugin.
        ///          </return>
        ///         <short>   </short>
        public string Comment() {
            return (string) interceptor.Invoke("comment", "comment() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> The iconname for this plugin
        ///          </return>
        ///         <short>   </short>
        public string Icon() {
            return (string) interceptor.Invoke("icon", "icon() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> The file containing the information about the plugin.
        ///          </return>
        ///         <short>   </short>
        public string EntryPath() {
            return (string) interceptor.Invoke("entryPath", "entryPath() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> The author of this plugin.
        ///          </return>
        ///         <short>   </short>
        public string Author() {
            return (string) interceptor.Invoke("author", "author() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> The email address of the author.
        ///          </return>
        ///         <short>   </short>
        public string Email() {
            return (string) interceptor.Invoke("email", "email() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> The category of this plugin (e.g. playlist/skin).
        ///          </return>
        ///         <short>   </short>
        public string Category() {
            return (string) interceptor.Invoke("category", "category() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> The internal name of the plugin (for KParts Plugins this is
        ///  the same name as set in the .rc file).
        ///          </return>
        ///         <short>   </short>
        public string PluginName() {
            return (string) interceptor.Invoke("pluginName", "pluginName() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> The version of the plugin.
        ///          </return>
        ///         <short>   </short>
        public string Version() {
            return (string) interceptor.Invoke("version", "version() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> The website of the plugin/author.
        ///          </return>
        ///         <short>   </short>
        public string Website() {
            return (string) interceptor.Invoke("website", "website() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> The license keyword of this plugin.
        ///          </return>
        ///         <short>   </short>
        public string License() {
            return (string) interceptor.Invoke("license", "license() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> The full license object, according to the license keyword.
        ///          It can be used to present friendlier and more detailed
        ///          license info to the user, when the license is one of the
        ///          widespread within KDE. For other licenses, the license
        ///          object will state not very useful, "custom license" info
        ///          (this can be identified by KAboutLicense.Key() returning
        ///           KAboutData.License_Custom).
        /// </return>
        ///         <short>   </short>
        ///         <see> KAboutLicense.ByKeyword</see>
        public KAboutLicense FullLicense() {
            return (KAboutLicense) interceptor.Invoke("fullLicense", "fullLicense() const", typeof(KAboutLicense));
        }
        /// <remarks>
        /// </remarks>        <return> A list of plugins required for this plugin to be enabled. Use
        ///          the pluginName in this list.
        ///          </return>
        ///         <short>   </short>
        public List<string> Dependencies() {
            return (List<string>) interceptor.Invoke("dependencies", "dependencies() const", typeof(List<string>));
        }
        /// <remarks>
        /// </remarks>        <return> The KService object for this plugin. You might need it if you
        ///          want to read custom values. To do this you need to define
        ///          your own servicetype and add it to the ServiceTypes keys.
        ///          Then you can use the KService.Property() method to read your
        ///          keys.
        /// </return>
        ///         <short>   </short>
        ///         <see> property</see>
        public KService Service() {
            return (KService) interceptor.Invoke("service", "service() const", typeof(KService));
        }
        /// <remarks>
        /// </remarks>        <return> A list of Service pointers if the plugin installs one or more
        ///          KCModule
        ///          </return>
        ///         <short>   </short>
        public List<KService> KcmServices() {
            return (List<KService>) interceptor.Invoke("kcmServices", "kcmServices() const", typeof(List<KService>));
        }
        /// <remarks>
        ///  Set the KConfigGroup to use for load()ing and save()ing the
        ///  configuration. This will be overridden by the KConfigGroup passed to
        ///  save() or load() (if one is passed).
        ///          </remarks>        <short>    Set the KConfigGroup to use for load()ing and save()ing the  configuration.</short>
        public void SetConfig(KConfigGroup config) {
            interceptor.Invoke("setConfig#", "setConfig(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
        }
        /// <remarks>
        /// </remarks>        <return> If the KPluginInfo object has a KConfig object set return
        ///  it, else returns an invalid KConfigGroup.
        ///          </return>
        ///         <short>   </short>
        public KConfigGroup Config() {
            return (KConfigGroup) interceptor.Invoke("config", "config() const", typeof(KConfigGroup));
        }
        /// <remarks>
        ///  Save state of the plugin - enabled or not.
        /// <param> name="config" The KConfigGroup holding the information whether
        ///                   plugin is enabled.
        ///          </param></remarks>        <short>    Save state of the plugin - enabled or not.</short>
        public void Save(KConfigGroup config) {
            interceptor.Invoke("save#", "save(KConfigGroup)", typeof(void), typeof(KConfigGroup), config);
        }
        public void Save() {
            interceptor.Invoke("save", "save()", typeof(void));
        }
        /// <remarks>
        ///  Load the state of the plugin - enabled or not.
        /// <param> name="config" The KConfigGroup holding the information whether
        ///                   plugin is enabled.
        ///          </param></remarks>        <short>    Load the state of the plugin - enabled or not.</short>
        public void Load(KConfigGroup config) {
            interceptor.Invoke("load#", "load(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
        }
        public void Load() {
            interceptor.Invoke("load", "load()", typeof(void));
        }
        /// <remarks>
        ///  Restore defaults (enabled or not).
        ///          </remarks>        <short>    Restore defaults (enabled or not).</short>
        public void Defaults() {
            interceptor.Invoke("defaults", "defaults()", typeof(void));
        }
        /// <remarks>
        ///  Returns whether the object is valid. Treat invalid KPluginInfo objects like you would
        ///  treat a null pointer.
        ///          </remarks>        <short>    Returns whether the object is valid.</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        ///  Creates a KPluginInfo object that shares the data with <pre>copy</pre>.
        ///          </remarks>        <short>    Creates a KPluginInfo object that shares the data with \p copy.</short>
        public KPluginInfo(KPluginInfo copy) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KPluginInfo#", "KPluginInfo(const KPluginInfo&)", typeof(void), typeof(KPluginInfo), copy);
        }
        /// <remarks>
        ///  Compares two objects whether they share the same data.
        ///          </remarks>        <short>    Compares two objects whether they share the same data.</short>
        public override bool Equals(object o) {
            if (!(o is KPluginInfo)) { return false; }
            return this == (KPluginInfo) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        /// <remarks>
        ///  Less than relation comparing the categories and if they are the same using the names.
        ///          </remarks>        <short>    Less than relation comparing the categories and if they are the same using the names.</short>
        /// <remarks>
        ///  Greater than relation comparing the categories and if they are the same using the names.
        ///          </remarks>        <short>    Greater than relation comparing the categories and if they are the same using the names.</short>
        ~KPluginInfo() {
            interceptor.Invoke("~KPluginInfo", "~KPluginInfo()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KPluginInfo", "~KPluginInfo()", typeof(void));
        }
        public static bool operator==(KPluginInfo lhs, KPluginInfo rhs) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KPluginInfo&) const", typeof(bool), typeof(KPluginInfo), lhs, typeof(KPluginInfo), rhs);
        }
        public static bool operator!=(KPluginInfo lhs, KPluginInfo rhs) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KPluginInfo&) const", typeof(bool), typeof(KPluginInfo), lhs, typeof(KPluginInfo), rhs);
        }
        public static bool operator<(KPluginInfo lhs, KPluginInfo rhs) {
            return (bool) staticInterceptor.Invoke("operator<#", "operator<(const KPluginInfo&) const", typeof(bool), typeof(KPluginInfo), lhs, typeof(KPluginInfo), rhs);
        }
        public static bool operator>(KPluginInfo lhs, KPluginInfo rhs) {
            return (bool) staticInterceptor.Invoke("operator>#", "operator>(const KPluginInfo&) const", typeof(bool), typeof(KPluginInfo), lhs, typeof(KPluginInfo), rhs);
        }
        /// <remarks>
        /// <param> name="services" The list of services to construct the list of KPluginInfo objects from
        /// </param><param> name="config" The config group where to save/load whether the plugin is enabled/disabled
        ///          </param></remarks>        <return> A list of KPluginInfo objects constructed from a list of
        ///  KService objects. If you get a trader offer of the plugins you want
        ///  to use you can just pass them to this function.
        /// </return>
        ///         <short>   </short>
        public static List<KPluginInfo> FromServices(List<KService> services, KConfigGroup config) {
            return (List<KPluginInfo>) staticInterceptor.Invoke("fromServices?#", "fromServices(const QList<KSharedPtr<KService> >&, const KConfigGroup&)", typeof(List<KPluginInfo>), typeof(List<KService>), services, typeof(KConfigGroup), config);
        }
        public static List<KPluginInfo> FromServices(List<KService> services) {
            return (List<KPluginInfo>) staticInterceptor.Invoke("fromServices?", "fromServices(const QList<KSharedPtr<KService> >&)", typeof(List<KPluginInfo>), typeof(List<KService>), services);
        }
        /// <remarks>
        /// <param> name="files" The list of files to construct the list of KPluginInfo objects from
        /// </param><param> name="config" The config group where to save/load whether the plugin is enabled/disabled
        ///          </param></remarks>        <return> A list of KPluginInfo objects constructed from a list of
        ///  filenames. If you make a lookup using, for example,
        ///  KStandardDirs.FindAllResources() you pass the list of files to this
        ///  function.
        /// </return>
        ///         <short>   </short>
        public static List<KPluginInfo> FromFiles(List<string> files, KConfigGroup config) {
            return (List<KPluginInfo>) staticInterceptor.Invoke("fromFiles?#", "fromFiles(const QStringList&, const KConfigGroup&)", typeof(List<KPluginInfo>), typeof(List<string>), files, typeof(KConfigGroup), config);
        }
        public static List<KPluginInfo> FromFiles(List<string> files) {
            return (List<KPluginInfo>) staticInterceptor.Invoke("fromFiles?", "fromFiles(const QStringList&)", typeof(List<KPluginInfo>), typeof(List<string>), files);
        }
        /// <remarks>
        /// <param> name="componentName" Use the component name to look up all KParts plugins for it.
        /// </param><param> name="config" The config group where to save/load whether the plugin is enabled/disabled
        ///          </param></remarks>        <return> A list of KPluginInfo objects for the KParts plugins of a
        ///  component. You only need the name of the component not a pointer to the
        ///  KComponentData object.
        /// </return>
        ///         <short>   </short>
        public static List<KPluginInfo> FromKPartsInstanceName(string componentName, KConfigGroup config) {
            return (List<KPluginInfo>) staticInterceptor.Invoke("fromKPartsInstanceName$#", "fromKPartsInstanceName(const QString&, const KConfigGroup&)", typeof(List<KPluginInfo>), typeof(string), componentName, typeof(KConfigGroup), config);
        }
        public static List<KPluginInfo> FromKPartsInstanceName(string componentName) {
            return (List<KPluginInfo>) staticInterceptor.Invoke("fromKPartsInstanceName$", "fromKPartsInstanceName(const QString&)", typeof(List<KPluginInfo>), typeof(string), componentName);
        }
    }
}
