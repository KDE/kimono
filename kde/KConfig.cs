//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  \class KConfig kconfig.h <KConfig>
    ///  \brief The central class of the KDE configuration data system.
    ///  Quickstart:
    ///  Get the default application config object via KGlobal.Config().
    ///  Load a specific configuration file:
    ///  <pre>
    ///  KConfig config( "/etc/kderc", KConfig.SimpleConfig );
    ///  </pre>
    ///  Load the configuration of a specific component (taking into account
    ///  possible custom dirs in KStandardDirs):
    ///  <pre>
    ///  KConfig config( componentData(), "pluginrc" );
    ///  </pre>
    ///  In general it is recommended to use KSharedConfig instead of
    ///  creating multiple instances of KConfig to avoid the overhead of
    ///  separate objects or concerns about synchronizing writes to disk
    ///  even if the configuration object is updated from multiple code paths.
    ///  KSharedConfig provides a set of open methods as counterparts for the
    ///  KConfig constructors.
    ///  \sa KSharedConfig, KConfigGroup, <a href="http://techbase.kde.org/index.php?title=Development/Tutorials/KConfig">the techbase HOWTO on KConfig</a>.
    ///  </remarks>        <short>    \class KConfig kconfig.</short>
    [SmokeClass("KConfig")]
    public class KConfig : KConfigBase, IDisposable {
        protected KConfig(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KConfig), this);
        }
        public enum OpenFlag {
            IncludeGlobals = 0x01,
            CascadeConfig = 0x02,
            SimpleConfig = 0x00,
            NoCascade = IncludeGlobals,
            NoGlobals = CascadeConfig,
            FullConfig = IncludeGlobals|CascadeConfig,
        }
        // KConfig* KConfig(KConfigPrivate& arg1); >>>> NOT CONVERTED
        public KConfig(string file, uint mode, string resourceType) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KConfig$$$", "KConfig(const QString&, KConfig::OpenFlags, const char*)", typeof(void), typeof(string), file, typeof(uint), mode, typeof(string), resourceType);
        }
        public KConfig(string file, uint mode) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KConfig$$", "KConfig(const QString&, KConfig::OpenFlags)", typeof(void), typeof(string), file, typeof(uint), mode);
        }
        public KConfig(string file) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KConfig$", "KConfig(const QString&)", typeof(void), typeof(string), file);
        }
        public KConfig() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KConfig", "KConfig()", typeof(void));
        }
        public KConfig(KComponentData componentData, string file, uint mode, string resourceType) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KConfig#$$$", "KConfig(const KComponentData&, const QString&, KConfig::OpenFlags, const char*)", typeof(void), typeof(KComponentData), componentData, typeof(string), file, typeof(uint), mode, typeof(string), resourceType);
        }
        public KConfig(KComponentData componentData, string file, uint mode) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KConfig#$$", "KConfig(const KComponentData&, const QString&, KConfig::OpenFlags)", typeof(void), typeof(KComponentData), componentData, typeof(string), file, typeof(uint), mode);
        }
        public KConfig(KComponentData componentData, string file) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KConfig#$", "KConfig(const KComponentData&, const QString&)", typeof(void), typeof(KComponentData), componentData, typeof(string), file);
        }
        public KConfig(KComponentData componentData) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KConfig#", "KConfig(const KComponentData&)", typeof(void), typeof(KComponentData), componentData);
        }
        /// <remarks>
        ///  Creates a KConfig oject using the specified backend. If the backend can not
        ///  be found or loaded, then the standard configuration parser is used as a fallback.
        ///  @arg file the file to be parsed
        ///  @arg backend the backend to load
        ///  @arg resourceType where to look for the file if an absolute path is not provided
        /// </remarks>        <short>   </short>
        public KConfig(string file, string backend, string resourceType) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KConfig$$$", "KConfig(const QString&, const QString&, const char*)", typeof(void), typeof(string), file, typeof(string), backend, typeof(string), resourceType);
        }
        public KConfig(string file, string backend) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KConfig$$", "KConfig(const QString&, const QString&)", typeof(void), typeof(string), file, typeof(string), backend);
        }
        public KComponentData ComponentData() {
            return (KComponentData) interceptor.Invoke("componentData", "componentData() const", typeof(KComponentData));
        }
        /// <remarks>
        ///  Returns the filename passed to the constructor.
        ///      </remarks>        <short>    Returns the filename passed to the constructor.</short>
        public string Name() {
            return (string) interceptor.Invoke("name", "name() const", typeof(string));
        }
        [SmokeMethod("sync()")]
        public override void Sync() {
            interceptor.Invoke("sync", "sync()", typeof(void));
        }
        [SmokeMethod("markAsClean()")]
        public override void MarkAsClean() {
            interceptor.Invoke("markAsClean", "markAsClean()", typeof(void));
        }
        [SmokeMethod("accessMode() const")]
        public override KConfigBase.AccessMode accessMode() {
            return (KConfigBase.AccessMode) interceptor.Invoke("accessMode", "accessMode() const", typeof(KConfigBase.AccessMode));
        }
        /// <remarks>
        ///  Return false if the user cannot write to this KConfig instance,
        ///  for instance because of permission problems.
        /// <param> name="warnUser" if true, show a message box telling the user to
        ///  contact his system administrator for getting this problem fixed.
        ///      </param></remarks>        <short>    Return false if the user cannot write to this KConfig instance,  for instance because of permission problems.</short>
        public bool IsConfigWritable(bool warnUser) {
            return (bool) interceptor.Invoke("isConfigWritable$", "isConfigWritable(bool)", typeof(bool), typeof(bool), warnUser);
        }
        /// <remarks>
        ///  Copies all entries from this config object to a new config
        ///  object that will save itself to <code>file.</code>
        ///  Actual saving to <code>file</code> happens when the returned object is
        ///  destructed or when sync() is called upon it.
        /// <param> name="file" the new config object will save itself to.
        /// </param><param> name="config" optional config object to reuse
        /// </param></remarks>        <return> the same as <code>config</code> if it was set, otherwise a new KConfig object.
        ///  In that case, do not forget to delete it!
        ///      </return>
        ///         <short>    Copies all entries from this config object to a new config  object that will save itself to <code>file.</code></short>
        public KConfig CopyTo(string file, KConfig config) {
            return (KConfig) interceptor.Invoke("copyTo$#", "copyTo(const QString&, KConfig*) const", typeof(KConfig), typeof(string), file, typeof(KConfig), config);
        }
        public KConfig CopyTo(string file) {
            return (KConfig) interceptor.Invoke("copyTo$", "copyTo(const QString&) const", typeof(KConfig), typeof(string), file);
        }
        /// <remarks>
        ///  Checks whether the config file contains the update <code>id</code>
        ///  as contained in <code>updateFile.</code> If not, it runs kconf_update
        ///  to update the config file.
        ///  If you install config update files with critical fixes
        ///  you may wish to use this method to verify that a critical
        ///  update has indeed been performed to catch the case where
        ///  a user restores an old config file from backup that has
        ///  not been updated yet.
        /// <param> name="id" the update to check
        /// </param><param> name="updateFile" the file containing the update
        ///      </param></remarks>        <short>    Checks whether the config file contains the update <code>id</code>  as contained in <code>updateFile.</code></short>
        public void CheckUpdate(string id, string updateFile) {
            interceptor.Invoke("checkUpdate$$", "checkUpdate(const QString&, const QString&)", typeof(void), typeof(string), id, typeof(string), updateFile);
        }
        /// <remarks>
        ///  Clears all internal data structures and then reread
        ///  configuration information from persistent storage.
        ///      </remarks>        <short>    Clears all internal data structures and then reread  configuration information from persistent storage.</short>
        public void ReparseConfiguration() {
            interceptor.Invoke("reparseConfiguration", "reparseConfiguration()", typeof(void));
        }
        /// <remarks>
        ///  Sets the merge stack to the list of files. The stack is last in first out with
        ///  the top of the stack being the most specific config file. The files in the merge
        ///  stack will be read before the file passed to the constructor and any files that
        ///  cascade from that file. This means that the entries read from the files in the
        ///  merge stack will be treated as defaults. This function will automatically call
        ///  reparseConfiguration() for you.
        ///  @note: Most specific config file is relative to this list, the overall
        ///  most specific file of this KConfig object is still the file it was
        ///  created with, no matter which file is passed last into this function.
        ///  This means that writing always goes to the file which was used to
        ///  create the KConfig object.
        /// <param> name="files" A list of extra config files.
        ///      </param></remarks>        <short>    Sets the merge stack to the list of files.</short>
        public void AddConfigSources(List<string> sources) {
            interceptor.Invoke("addConfigSources?", "addConfigSources(const QStringList&)", typeof(void), typeof(List<string>), sources);
        }
        /// <remarks>
        ///  Returns the current locale.
        ///      </remarks>        <short>    Returns the current locale.</short>
        public string Locale() {
            return (string) interceptor.Invoke("locale", "locale() const", typeof(string));
        }
        /// <remarks>
        ///  Sets the locale to <code>aLocale.</code>
        ///  The global locale is used by default.
        ///  @note If set to the empty string, <b></b>o locale will be matched. This effectively disables
        ///  reading translated entries.
        /// </remarks>        <return> @c true if locale was changed and configuration was reparsed.
        ///      </return>
        ///         <short>    Sets the locale to <code>aLocale.</code></short>
        public bool SetLocale(string aLocale) {
            return (bool) interceptor.Invoke("setLocale$", "setLocale(const QString&)", typeof(bool), typeof(string), aLocale);
        }
        /// <remarks>
        ///  When set, all readEntry calls return the system-wide (default) values instead of
        ///  the user's preference.
        ///  This is off by default.
        ///      </remarks>        <short>    When set, all readEntry calls return the system-wide (default) values instead of  the user's preference.</short>
        public void SetReadDefaults(bool b) {
            interceptor.Invoke("setReadDefaults$", "setReadDefaults(bool)", typeof(void), typeof(bool), b);
        }
        public bool ReadDefaults() {
            return (bool) interceptor.Invoke("readDefaults", "readDefaults() const", typeof(bool));
        }
        [SmokeMethod("isImmutable() const")]
        public override bool IsImmutable() {
            return (bool) interceptor.Invoke("isImmutable", "isImmutable() const", typeof(bool));
        }
        [SmokeMethod("groupList() const")]
        public override List<string> GroupList() {
            return (List<string>) interceptor.Invoke("groupList", "groupList() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Returns a map (tree) of entries in a particular group.  Only the actual entry as a string
        ///  is returned.
        /// <param> name="aGroup" The group to get entries from.
        /// </param></remarks>        <return> A map of entries in the group specified, indexed by key.
        ///          The returned map may be empty if the group is empty, or not found.
        /// </return>
        ///         <short>    Returns a map (tree) of entries in a particular group.</short>
        ///         <see> QMap</see>
        public Dictionary<string, string> EntryMap(string aGroup) {
            return (Dictionary<string, string>) interceptor.Invoke("entryMap$", "entryMap(const QString&) const", typeof(Dictionary<string, string>), typeof(string), aGroup);
        }
        public Dictionary<string, string> EntryMap() {
            return (Dictionary<string, string>) interceptor.Invoke("entryMap", "entryMap() const", typeof(Dictionary<string, string>));
        }
        [SmokeMethod("hasGroupImpl(const QByteArray&) const")]
        protected override bool HasGroupImpl(QByteArray group) {
            return (bool) interceptor.Invoke("hasGroupImpl#", "hasGroupImpl(const QByteArray&) const", typeof(bool), typeof(QByteArray), group);
        }
        [SmokeMethod("groupImpl(const QByteArray&)")]
        protected override KConfigGroup GroupImpl(QByteArray b) {
            return (KConfigGroup) interceptor.Invoke("groupImpl#", "groupImpl(const QByteArray&)", typeof(KConfigGroup), typeof(QByteArray), b);
        }
        [SmokeMethod("deleteGroupImpl(const QByteArray&, KConfigBase::WriteConfigFlags)")]
        protected override void DeleteGroupImpl(QByteArray group, uint flags) {
            interceptor.Invoke("deleteGroupImpl#$", "deleteGroupImpl(const QByteArray&, KConfigBase::WriteConfigFlags)", typeof(void), typeof(QByteArray), group, typeof(uint), flags);
        }
        [SmokeMethod("deleteGroupImpl(const QByteArray&)")]
        protected virtual void DeleteGroupImpl(QByteArray group) {
            interceptor.Invoke("deleteGroupImpl#", "deleteGroupImpl(const QByteArray&)", typeof(void), typeof(QByteArray), group);
        }
        [SmokeMethod("isGroupImmutableImpl(const QByteArray&) const")]
        protected override bool IsGroupImmutableImpl(QByteArray aGroup) {
            return (bool) interceptor.Invoke("isGroupImmutableImpl#", "isGroupImmutableImpl(const QByteArray&) const", typeof(bool), typeof(QByteArray), aGroup);
        }
        ~KConfig() {
            interceptor.Invoke("~KConfig", "~KConfig()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KConfig", "~KConfig()", typeof(void));
        }
    }
}
