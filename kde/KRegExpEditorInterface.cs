//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///   A graphical editor for regular expressions.
    ///  The actual editor is located in kdeutils, with an interface in
    ///  kdelibs. This means that it is a bit more comlicated to create an
    ///  instance of the editor, but only a little bit more complicated.
    ///  To check if kregexpeditor in kdeutils is installed and available use this line:
    ///  <pre>
    ///  bool installed=!KTrader.Self().Query("KRegExpEditor/KRegExpEditor").isEmpty();
    ///  </pre>
    ///  The following is a template for what you need to do to create an instance of the
    ///  regular expression dialog:
    ///  <pre>
    ///  QDialog editorDialog = KServiceTypeTrader.CreateInstanceFromQuery<QDialog>( "KRegExpEditor/KRegExpEditor" );
    ///  if ( editorDialog ) {
    ///    // kdeutils was installed, so the dialog was found fetch the editor interface
    ///    KRegExpEditorInterface editor = (KRegExpEditorInterface)( editorDialog.Qt_cast( "KRegExpEditorInterface" ) );
    ///    Q_ASSERT( editor ); // This should not fail!
    ///    // now use the editor.
    ///    editor.SetRegExp("^kde$");
    ///    // Finally exec the dialog
    ///    editorDialog.Exec();
    ///  }
    ///  else {
    ///    // Don't offer the dialog.
    ///  }
    ///  </pre>
    ///  Note: signals and slots must be connected to the editorDialog object, not to the editor object:
    ///  <pre>
    ///  connect( editorDialog, SIGNAL("canUndo( bool )"), undoBut, SLOT("setEnabled( bool )") );
    ///  </pre>
    ///  If you want to create an instance of the editor widget, i.e. not the
    ///  dialog, then you must do it in the following way:
    ///  <pre>
    ///  QWidget editorWidget =
    ///  KServiceTypeTrader.CreateInstanceFromQuery<QWidget>(
    ///      "KRegExpEditor/KRegExpEditor", string(), parent );
    ///  if ( editorWidget ) {
    ///    // kdeutils was installed, so the widget was found fetch the editor interface
    ///    KRegExpEditorInterface editor = (KRegExpEditorInterface)( editorWidget.Qt_cast( "KRegExpEditorInterface" ) );
    ///    Q_ASSERT( editor ); // This should not fail!
    ///    // now use the editor.
    ///    editor.SetRegExp("^kde$");
    ///    // Finally insert the widget into the layout of its parent
    ///    layout.AddWidget( editorWidget );
    ///  }
    ///  else {
    ///    // Don't offer the editor widget.
    ///  }
    ///  </pre>
    ///  </remarks>        <author> Jesper K. Pedersen blackie@kde.org
    /// </author>
    ///         <short>     A graphical editor for regular expressions.</short>
    [SmokeClass("KRegExpEditorInterface")]
    public abstract class KRegExpEditorInterface : Object {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KRegExpEditorInterface(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KRegExpEditorInterface), this);
        }
        // void doSomething(QString arg1,void* arg2); >>>> NOT CONVERTED
        /// <remarks>
        ///  returns the regular expression of the editor in Qt3 QRegExp
        ///  syntax. Note, there is also a 'regexp' Qt property available.
        ///    </remarks>        <short>    returns the regular expression of the editor in Qt3 QRegExp  syntax.</short>
        [SmokeMethod("regExp() const")]
        public abstract string RegExp();
        /// <remarks>
        ///  Set the regular expression for the editor. The syntax must be Qt3
        ///  QRegExp syntax.
        ///   </remarks>        <short>    Set the regular expression for the editor.</short>
        [SmokeMethod("setRegExp(const QString&)")]
        public abstract void SetRegExp(string regexp);
        [SmokeMethod("redo()")]
        public abstract void Redo();
        [SmokeMethod("undo()")]
        public abstract void Undo();
        /// <remarks>
        ///  Set text to use when showing matches. NOT IMPLEMENTED YET!
        ///  This method is not yet implemented. In later version of the widget
        ///  this method will be used to give the widget a text to show matches of
        ///  the regular expression on.
        ///    </remarks>        <short>    Set text to use when showing matches.</short>
        [SmokeMethod("setMatchText(const QString&)")]
        public abstract void SetMatchText(string arg1);
        /// <remarks>
        ///  This method allows for future changes that will not break binary
        ///  compatibility. DO NOT USE!
        ///  KDE has a policy of keeping binary compatibility for all major
        ///  version of KDE. This means that new methods can not be added to this
        ///  API before KDE version 4.0.
        ///  This method is an escape door for that.
        ///  Conclusion: You should not use this method in this version of KDE!
        ///    </remarks>        <short>    This method allows for future changes that will not break binary  compatibility.</short>
        public KRegExpEditorInterface() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KRegExpEditorInterface", "KRegExpEditorInterface()", typeof(void));
        }
        /// <remarks>
        ///  This signal tells whether undo is available.
        ///    </remarks>        <short>    This signal tells whether undo is available.</short>
        [SmokeMethod("canUndo(bool)")]
        protected abstract void CanUndo(bool arg1);
        /// <remarks>
        ///  This signal tells whether redo is available.
        ///    </remarks>        <short>    This signal tells whether redo is available.</short>
        [SmokeMethod("canRedo(bool)")]
        protected abstract void CanRedo(bool arg1);
        /// <remarks>
        ///  This signal is emitted whenever the regular expression changes.
        ///  The argument is true when the regular expression is different from
        ///  the loaded regular expression and false when it is equal to the
        ///  loaded regular expression.
        ///    </remarks>        <short>    This signal is emitted whenever the regular expression changes.</short>
        [SmokeMethod("changes(bool)")]
        protected abstract void Changes(bool arg1);
    }
}
