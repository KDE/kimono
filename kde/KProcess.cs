//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  \class KProcess kprocess.h <KProcess>
    ///  Child process invocation, monitoring and control.
    ///  This class extends QProcess by some useful functionality, overrides
    ///  some defaults with saner values and wraps parts of the API into a more
    ///  accessible one.
    ///  This is the preferred way of spawning child processes in KDE; don't
    ///  use QProcess directly.
    /// </remarks>        <author> Oswald Buddenhagen <ossi@kde.org>
    /// </author>
    ///         <short>    \class KProcess kprocess.</short>
    [SmokeClass("KProcess")]
    public class KProcess : QProcess, IDisposable {
        protected KProcess(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KProcess), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KProcess() {
            staticInterceptor = new SmokeInvocation(typeof(KProcess), null);
        }
        /// <remarks>
        ///  Modes in which the output channels can be opened.
        ///      </remarks>        <short>    Modes in which the output channels can be opened.</short>
        public enum OutputChannelMode {
            SeparateChannels = QProcess.ProcessChannelMode.SeparateChannels,
            MergedChannels = QProcess.ProcessChannelMode.MergedChannels,
            ForwardedChannels = QProcess.ProcessChannelMode.ForwardedChannels,
            OnlyStdoutChannel = 0,
            OnlyStderrChannel = 1,
        }
        // KProcess* KProcess(KProcessPrivate* arg1,QObject* arg2); >>>> NOT CONVERTED
        /// <remarks>
        ///  Constructor
        ///      </remarks>        <short>    Constructor      </short>
        public KProcess(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KProcess#", "KProcess(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public KProcess() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KProcess", "KProcess()", typeof(void));
        }
        /// <remarks>
        ///  Set how to handle the output channels of the child process.
        ///  The default is ForwardedChannels, which is unlike in QProcess.
        ///  Do not request more than you actually handle, as this output is
        ///  simply lost otherwise.
        ///  This function must be called before starting the process.
        /// <param> name="mode" the output channel handling mode
        ///      </param></remarks>        <short>    Set how to handle the output channels of the child process.</short>
        public void SetOutputChannelMode(KProcess.OutputChannelMode mode) {
            interceptor.Invoke("setOutputChannelMode$", "setOutputChannelMode(KProcess::OutputChannelMode)", typeof(void), typeof(KProcess.OutputChannelMode), mode);
        }
        /// <remarks>
        ///  Query how the output channels of the child process are handled.
        /// </remarks>        <return> the output channel handling mode
        ///      </return>
        ///         <short>    Query how the output channels of the child process are handled.</short>
        public KProcess.OutputChannelMode outputChannelMode() {
            return (KProcess.OutputChannelMode) interceptor.Invoke("outputChannelMode", "outputChannelMode() const", typeof(KProcess.OutputChannelMode));
        }
        /// <remarks>
        ///  Set the QIODevice open mode the process will be opened in.
        ///  This function must be called before starting the process, obviously.
        /// <param> name="mode" the open mode. Note that this mode is automatically
        ///    "reduced" according to the channel modes and redirections.
        ///    The default is QIODevice.ReadWrite.
        ///      </param></remarks>        <short>    Set the QIODevice open mode the process will be opened in.</short>
        public void SetNextOpenMode(uint mode) {
            interceptor.Invoke("setNextOpenMode$", "setNextOpenMode(QIODevice::OpenMode)", typeof(void), typeof(uint), mode);
        }
        /// <remarks>
        ///  Adds the variable <code>name</code> to the process' environment.
        ///  This function must be called before starting the process.
        /// <param> name="name" the name of the environment variable
        /// </param><param> name="value" the new value for the environment variable
        /// </param><param> name="overwrite" if <code>false</code> and the environment variable is already
        ///    set, the old value will be preserved
        ///      </param></remarks>        <short>    Adds the variable <code>name</code> to the process' environment.</short>
        public void SetEnv(string name, string value, bool overwrite) {
            interceptor.Invoke("setEnv$$$", "setEnv(const QString&, const QString&, bool)", typeof(void), typeof(string), name, typeof(string), value, typeof(bool), overwrite);
        }
        public void SetEnv(string name, string value) {
            interceptor.Invoke("setEnv$$", "setEnv(const QString&, const QString&)", typeof(void), typeof(string), name, typeof(string), value);
        }
        /// <remarks>
        ///  Removes the variable <code>name</code> from the process' environment.
        ///  This function must be called before starting the process.
        /// <param> name="name" the name of the environment variable
        ///      </param></remarks>        <short>    Removes the variable <code>name</code> from the process' environment.</short>
        public void UnsetEnv(string name) {
            interceptor.Invoke("unsetEnv$", "unsetEnv(const QString&)", typeof(void), typeof(string), name);
        }
        /// <remarks>
        ///  Empties the process' environment.
        ///  Note that LD_LIBRARY_PATH/DYLD_LIBRARY_PATH is automatically added
        ///  on NIX.
        ///  This function must be called before starting the process.
        ///      </remarks>        <short>    Empties the process' environment.</short>
        public void ClearEnvironment() {
            interceptor.Invoke("clearEnvironment", "clearEnvironment()", typeof(void));
        }
        /// <remarks>
        ///  Set the program and the command line arguments.
        ///  This function must be called before starting the process, obviously.
        /// <param> name="exe" the program to execute
        /// </param><param> name="args" the command line arguments for the program,
        ///    one per list element
        ///      </param></remarks>        <short>    Set the program and the command line arguments.</short>
        public void SetProgram(string exe, List<string> args) {
            interceptor.Invoke("setProgram$?", "setProgram(const QString&, const QStringList&)", typeof(void), typeof(string), exe, typeof(List<string>), args);
        }
        public void SetProgram(string exe) {
            interceptor.Invoke("setProgram$", "setProgram(const QString&)", typeof(void), typeof(string), exe);
        }
        /// <remarks>
        ///  @overload
        /// <param> name="argv" the program to execute and the command line arguments
        ///    for the program, one per list element
        ///      </param></remarks>        <short>    @overload </short>
        public void SetProgram(List<string> argv) {
            interceptor.Invoke("setProgram?", "setProgram(const QStringList&)", typeof(void), typeof(List<string>), argv);
        }
        /// <remarks>
        ///  Append an element to the command line argument list for this process.
        ///  If no executable is set yet, it will be set instead.
        ///  For example, doing an "ls -l /usr/local/bin" can be achieved by:
        ///   <pre>
        ///   KProcess p;
        ///   p << "ls" << "-l" << "/usr/local/bin";
        ///   ...
        ///   </pre>
        ///  This function must be called before starting the process, obviously.
        /// <param> name="arg" the argument to add
        /// </param></remarks>        <return> a reference to this KProcess
        ///      </return>
        ///         <short>    Append an element to the command line argument list for this process.</short>
        public KProcess Write(string arg) {
            return (KProcess) interceptor.Invoke("operator<<$", "operator<<(const QString&)", typeof(KProcess), typeof(string), arg);
        }
        /// <remarks>
        ///  @overload
        /// <param> name="args" the arguments to add
        /// </param></remarks>        <return> a reference to this KProcess
        ///      </return>
        ///         <short>    @overload </short>
        public KProcess Write(List<string> args) {
            return (KProcess) interceptor.Invoke("operator<<?", "operator<<(const QStringList&)", typeof(KProcess), typeof(List<string>), args);
        }
        /// <remarks>
        ///  Clear the program and command line argument list.
        ///      </remarks>        <short>    Clear the program and command line argument list.</short>
        public void ClearProgram() {
            interceptor.Invoke("clearProgram", "clearProgram()", typeof(void));
        }
        /// <remarks>
        ///  Set a command to execute through a shell (a POSIX sh on NIX
        ///  and cmd.exe on Windows).
        ///  Using this for anything but user-supplied commands is usually a bad
        ///  idea, as the command's syntax depends on the platform.
        ///  Redirections including pipes, etc. are better handled by the
        ///  respective functions provided by QProcess.
        ///  If KProcess determines that the command does not really need a
        ///  shell, it will trasparently execute it without one for performance
        ///  reasons.
        ///  This function must be called before starting the process, obviously.
        /// <param> name="cmd" the command to execute through a shell.
        ///    The caller must make sure that all filenames etc. are properly
        ///    quoted when passed as argument. Failure to do so often results in
        ///    serious security holes. See KShell.QuoteArg().
        ///      </param></remarks>        <short>    Set a command to execute through a shell (a POSIX sh on  NIX  and cmd.</short>
        public void SetShellCommand(string cmd) {
            interceptor.Invoke("setShellCommand$", "setShellCommand(const QString&)", typeof(void), typeof(string), cmd);
        }
        /// <remarks>
        ///  Obtain the currently set program and arguments.
        /// </remarks>        <return> a list, the first element being the program, the remaining ones
        ///   being command line arguments to the program.
        ///      </return>
        ///         <short>    Obtain the currently set program and arguments.</short>
        public List<string> Program() {
            return (List<string>) interceptor.Invoke("program", "program() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Start the process.
        /// </remarks>        <short>    Start the process.</short>
        ///         <see> QProcess.Start(const</see>
        ///         <see> const</see>
        ///         <see> OpenMode)</see>
        public void Start() {
            interceptor.Invoke("start", "start()", typeof(void));
        }
        /// <remarks>
        ///  Start the process, wait for it to finish, and return the exit code.
        ///  This method is roughly equivalent to the sequence:
        ///  <code>
        ///    start();
        ///    waitForFinished(msecs);
        ///    return exitCode();
        ///  </code>
        ///  Unlike the other execute() variants this method is not static,
        ///  so the process can be parametrized properly and talked to.
        /// <param> name="msecs" time to wait for process to exit before killing it
        /// </param></remarks>        <return> -2 if the process could not be started, -1 if it crashed,
        ///   otherwise its exit code
        ///      </return>
        ///         <short>    Start the process, wait for it to finish, and return the exit code.</short>
        public int Execute(int msecs) {
            return (int) interceptor.Invoke("execute$", "execute(int)", typeof(int), typeof(int), msecs);
        }
        public int Execute() {
            return (int) interceptor.Invoke("execute", "execute()", typeof(int));
        }
        /// <remarks>
        ///  Start the process and detach from it. See QProcess.StartDetached()
        ///  for details.
        ///  Unlike the other startDetached() variants this method is not static,
        ///  so the process can be parametrized properly.
        ///  @note Currently, only the setProgram()/setShellCommand() and
        ///  setWorkingDirectory() parametrizations are supported.
        ///  The KProcess object may be re-used immediately after calling this
        ///  function.
        /// </remarks>        <return> the PID of the started process or 0 on error
        ///      </return>
        ///         <short>    Start the process and detach from it.</short>
        public int StartDetached() {
            return (int) interceptor.Invoke("startDetached", "startDetached()", typeof(int));
        }
        /// <remarks>
        ///  Obtain the process' ID as known to the system.
        ///  Unlike with QProcess.Pid(), this is a real PID also on Windows.
        ///  This function can be called only while the process is running.
        ///  It cannot be applied to detached processes.
        /// </remarks>        <return> the process ID
        ///      </return>
        ///         <short>    Obtain the process' ID as known to the system.</short>
        public new int Pid() {
            return (int) interceptor.Invoke("pid", "pid() const", typeof(int));
        }
        /// <remarks>
        ///      </remarks>        <short>   </short>
        ~KProcess() {
            interceptor.Invoke("~KProcess", "~KProcess()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KProcess", "~KProcess()", typeof(void));
        }
        /// <remarks>
        ///  @overload
        /// <param> name="exe" the program to execute
        /// </param><param> name="args" the command line arguments for the program,
        ///    one per list element
        /// </param><param> name="msecs" time to wait for process to exit before killing it
        /// </param></remarks>        <return> -2 if the process could not be started, -1 if it crashed,
        ///   otherwise its exit code
        ///      </return>
        ///         <short>    @overload </short>
        public static int Execute(string exe, List<string> args, int msecs) {
            return (int) staticInterceptor.Invoke("execute$?$", "execute(const QString&, const QStringList&, int)", typeof(int), typeof(string), exe, typeof(List<string>), args, typeof(int), msecs);
        }
        public static new int Execute(string exe, List<string> args) {
            return (int) staticInterceptor.Invoke("execute$?", "execute(const QString&, const QStringList&)", typeof(int), typeof(string), exe, typeof(List<string>), args);
        }
        public static new int Execute(string exe) {
            return (int) staticInterceptor.Invoke("execute$", "execute(const QString&)", typeof(int), typeof(string), exe);
        }
        /// <remarks>
        ///  @overload
        /// <param> name="argv" the program to execute and the command line arguments
        ///    for the program, one per list element
        /// </param><param> name="msecs" time to wait for process to exit before killing it
        /// </param></remarks>        <return> -2 if the process could not be started, -1 if it crashed,
        ///   otherwise its exit code
        ///      </return>
        ///         <short>    @overload </short>
        public static int Execute(List<string> argv, int msecs) {
            return (int) staticInterceptor.Invoke("execute?$", "execute(const QStringList&, int)", typeof(int), typeof(List<string>), argv, typeof(int), msecs);
        }
        public static int Execute(List<string> argv) {
            return (int) staticInterceptor.Invoke("execute?", "execute(const QStringList&)", typeof(int), typeof(List<string>), argv);
        }
        /// <remarks>
        ///  @overload
        /// <param> name="exe" the program to start
        /// </param><param> name="args" the command line arguments for the program,
        ///    one per list element
        /// </param></remarks>        <return> the PID of the started process or 0 on error
        ///      </return>
        ///         <short>    @overload </short>
        public static new int StartDetached(string exe, List<string> args) {
            return (int) staticInterceptor.Invoke("startDetached$?", "startDetached(const QString&, const QStringList&)", typeof(int), typeof(string), exe, typeof(List<string>), args);
        }
        public static new int StartDetached(string exe) {
            return (int) staticInterceptor.Invoke("startDetached$", "startDetached(const QString&)", typeof(int), typeof(string), exe);
        }
        /// <remarks>
        ///  @overload
        /// <param> name="argv" the program to start and the command line arguments
        ///    for the program, one per list element
        /// </param></remarks>        <return> the PID of the started process or 0 on error
        ///      </return>
        ///         <short>    @overload </short>
        public static int StartDetached(List<string> argv) {
            return (int) staticInterceptor.Invoke("startDetached?", "startDetached(const QStringList&)", typeof(int), typeof(List<string>), argv);
        }
        protected new IKProcessSignals Emit {
            get { return (IKProcessSignals) Q_EMIT; }
        }
    }

    public interface IKProcessSignals : IQProcessSignals {
    }
}
