//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  This class helps applications implement support for KDataTool.
    ///  The steps to follow are simple:
    /// 
    /// <li>
    /// query for the available tools using KDataToolInfo.Query
    /// </li>
    /// 
    /// <li>
    /// pass the result to KDataToolAction.DataToolActionList (with a slot)
    /// </li>
    /// 
    /// <li>
    /// plug the resulting actions, either using KXMLGUIClient.PlugActionList, or by hand.
    /// </li>
    ///  The slot defined for step 2 is called when the action is activated, and
    ///  that's where the tool should be created and run.
    ///   See <see cref="IKDataToolActionSignals"></see> for signals emitted by KDataToolAction
    /// </remarks>        <short>    This class helps applications implement support for KDataTool.</short>
    [SmokeClass("KDataToolAction")]
    public class KDataToolAction : KAction, IDisposable {
        protected KDataToolAction(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KDataToolAction), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KDataToolAction() {
            staticInterceptor = new SmokeInvocation(typeof(KDataToolAction), null);
        }
        /// <remarks>
        ///  Constructs a new KDataToolAction.
        /// <param> name="text" The text that will be displayed
        /// </param><param> name="info" The corresponding KDataToolInfo
        /// </param><param> name="command" The command of the action
        /// </param><param> name="parent" This action's parent
        /// </param><param> name="name" The name of the action
        ///      </param></remarks>        <short>    Constructs a new KDataToolAction.</short>
        public KDataToolAction(string text, KDataToolInfo info, string command, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KDataToolAction$#$#", "KDataToolAction(const QString&, const KDataToolInfo&, const QString&, QObject*)", typeof(void), typeof(string), text, typeof(KDataToolInfo), info, typeof(string), command, typeof(QObject), parent);
        }
        [SmokeMethod("slotActivated()")]
        protected virtual void SlotActivated() {
            interceptor.Invoke("slotActivated", "slotActivated()", typeof(void));
        }
        ~KDataToolAction() {
            interceptor.Invoke("~KDataToolAction", "~KDataToolAction()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KDataToolAction", "~KDataToolAction()", typeof(void));
        }
        /// <remarks>
        ///  Creates a list of actions from a list of information about data-tools.
        ///  The slot must have a signature corresponding to the toolActivated signal.
        ///  Note that it's the caller's responsibility to delete the actions when they're not needed anymore.
        /// <param> name="tools" the list of data tool descriptions
        /// </param><param> name="receiver" the receiver for toolActivated() signals
        /// </param><param> name="slot" the slot that will receive the toolActivated() signals
        /// </param><param> name="parent" the parent action collection for the actions to be created
        /// </param></remarks>        <return> the KActions
        ///      </return>
        ///         <short>    Creates a list of actions from a list of information about data-tools.</short>
        public static List<QAction> DataToolActionList(List<KDataToolInfo> tools, QObject receiver, string slot, KActionCollection parent) {
            return (List<QAction>) staticInterceptor.Invoke("dataToolActionList?#$#", "dataToolActionList(const QList<KDataToolInfo>&, const QObject*, const char*, KActionCollection*)", typeof(List<QAction>), typeof(List<KDataToolInfo>), tools, typeof(QObject), receiver, typeof(string), slot, typeof(KActionCollection), parent);
        }
        protected new IKDataToolActionSignals Emit {
            get { return (IKDataToolActionSignals) Q_EMIT; }
        }
    }

    public interface IKDataToolActionSignals : IKActionSignals {
        /// <remarks>
        ///  Emitted when a tool has been activated.
        /// <param> name="info" a description of the activated tools
        /// </param><param> name="command" the command for the tool
        ///      </param></remarks>        <short>    Emitted when a tool has been activated.</short>
        [Q_SIGNAL("void toolActivated(KDataToolInfo, QString)")]
        void ToolActivated(KDataToolInfo info, string command);
    }
}
