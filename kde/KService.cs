//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Text;
    using System.Collections.Generic;
    /// <remarks>
    ///  Represent a service, like an application or plugin
    ///  bound to one or several mimetypes (or servicetypes) as written
    ///  in its desktop entry file.
    ///  The starting point you need is often the static methods, like createInstance().
    ///  The types of service a plugin provides is taken from the accompanying desktop file
    ///  where the 'ServiceTypes=' field is used.
    ///  For a tutorial on how to build a plugin-loading mechanism and how to write plugins
    ///  in general, see http://developer.kde.org/documentation/tutorials/developing-a-plugin-structure/index.html#developing_plugins
    ///  (todo: port to kde4, create techbase article)
    /// </remarks>        <author> Torben Weis
    ///  </author>
    ///         <short>    Represent a service, like an application or plugin  bound to one or several mimetypes (or servicetypes) as written  in its desktop entry file.</short>
    ///         <see> KServiceType</see>
    ///         <see> KServiceGroup</see>
    [SmokeClass("KService")]
    public partial class KService : KSycocaEntry, IDisposable {
        protected KService(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KService), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KService() {
            staticInterceptor = new SmokeInvocation(typeof(KService), null);
        }
        /// <remarks>
        ///  Describes the DBUS Startup type of the service.
        /// 
        /// <li>
        /// None - This service has no DBUS support
        /// </li>
        /// 
        /// <li>
        /// Unique - This service provides a unique DBUS service.
        ///               The service name is equal to the desktopEntryName.
        /// </li>
        /// 
        /// <li>
        /// Multi - This service provides a DBUS service which can be run
        ///              with multiple instances in parallel. The service name of
        ///              an instance is equal to the desktopEntryName + "-" +
        ///              the PID of the process.
        /// </li>
        /// 
        /// <li>
        /// Wait - This service has no DBUS support, the launcher will wait
        ///             till it is finished.
        ///      
        /// </li></remarks>        <short>    Describes the DBUS Startup type of the service.</short>
        public enum DBusStartupType {
            DBusNone = 0,
            DBusUnique = 1,
            DBusMulti = 2,
            DBusWait = 3,
        }
        // QVector<KService::ServiceTypeAndPreference>& _k_accessServiceTypes(); >>>> NOT CONVERTED
        /// <remarks>
        ///  Construct a temporary service with a given name, exec-line and icon.
        /// <param> name="name" the name of the service
        /// </param><param> name="exec" the executable
        /// </param><param> name="icon" the name of the icon
        ///      </param></remarks>        <short>    Construct a temporary service with a given name, exec-line and icon.</short>
        public KService(string name, string exec, string icon) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KService$$$", "KService(const QString&, const QString&, const QString&)", typeof(void), typeof(string), name, typeof(string), exec, typeof(string), icon);
        }
        /// <remarks>
        ///  Construct a service and take all information from a config file.
        /// <param> name="fullpath" Full path to the config file.
        ///      </param></remarks>        <short>    Construct a service and take all information from a config file.</short>
        public KService(string fullpath) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KService$", "KService(const QString&)", typeof(void), typeof(string), fullpath);
        }
        /// <remarks>
        ///  Construct a service and take all information from a desktop file.
        /// <param> name="config" the desktop file to read
        ///      </param></remarks>        <short>    Construct a service and take all information from a desktop file.</short>
        public KService(KDesktopFile config) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KService#", "KService(const KDesktopFile*)", typeof(void), typeof(KDesktopFile), config);
        }
        /// <remarks>
        ///  Construct a service from a stream.
        ///  The stream must already be positionned at the correct offset.
        ///      </remarks>        <short>   </short>
        public KService(QDataStream str, int offset) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KService#$", "KService(QDataStream&, int)", typeof(void), typeof(QDataStream), str, typeof(int), offset);
        }
        /// <remarks>
        ///  Services are either applications (executables) or dlopened libraries (plugins).
        /// </remarks>        <return> true if this service is an application, i.e. it has Type=Application in its
        ///  .desktop file and exec() will not be empty.
        ///      </return>
        ///         <short>    Services are either applications (executables) or dlopened libraries (plugins).</short>
        public bool IsApplication() {
            return (bool) interceptor.Invoke("isApplication", "isApplication() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns the executable.
        /// </remarks>        <return> the command that the service executes,
        ///          or string() if not set
        ///      </return>
        ///         <short>    Returns the executable.</short>
        public string Exec() {
            return (string) interceptor.Invoke("exec", "exec() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the name of the service's library.
        /// </remarks>        <return> the name of the library that contains the service's
        ///          implementation, or string() if not set
        ///      </return>
        ///         <short>    Returns the name of the service's library.</short>
        public string Library() {
            return (string) interceptor.Invoke("library", "library() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the name of the icon.
        /// </remarks>        <return> the icon associated with the service,
        ///          or string() if not set
        ///      </return>
        ///         <short>    Returns the name of the icon.</short>
        public string Icon() {
            return (string) interceptor.Invoke("icon", "icon() const", typeof(string));
        }
        /// <remarks>
        ///  Checks whethe the service should be run in a terminal.
        /// </remarks>        <return> true if the service is to be run in a terminal.
        ///      </return>
        ///         <short>    Checks whethe the service should be run in a terminal.</short>
        public bool Terminal() {
            return (bool) interceptor.Invoke("terminal", "terminal() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns any options associated with the terminal the service
        ///  runs in, if it requires a terminal.
        ///  The service must be a tty-oriented program.
        /// </remarks>        <return> the terminal options,
        ///          or string() if not set
        ///      </return>
        ///         <short>    Returns any options associated with the terminal the service  runs in, if it requires a terminal.</short>
        public string TerminalOptions() {
            return (string) interceptor.Invoke("terminalOptions", "terminalOptions() const", typeof(string));
        }
        /// <remarks>
        ///  Checks whether the service runs with a different user id.
        /// </remarks>        <return> true if the service has to be run under a different uid.
        /// </return>
        ///         <short>    Checks whether the service runs with a different user id.</short>
        ///         <see> username</see>
        public bool SubstituteUid() {
            return (bool) interceptor.Invoke("substituteUid", "substituteUid() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns the user name, if the service runs with a
        ///  different user id.
        /// </remarks>        <return> the username under which the service has to be run,
        ///          or string() if not set
        /// </return>
        ///         <short>    Returns the user name, if the service runs with a  different user id.</short>
        ///         <see> substututeUida</see>
        public string Username() {
            return (string) interceptor.Invoke("username", "username() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the filename of the service desktop entry without any
        ///  extension. E.g. "kppp"
        /// </remarks>        <return> the name of the desktop entry without path or extension,
        ///          or string() if not set
        ///      </return>
        ///         <short>    Returns the filename of the service desktop entry without any  extension.</short>
        public string DesktopEntryName() {
            return (string) interceptor.Invoke("desktopEntryName", "desktopEntryName() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the menu ID of the service desktop entry.
        ///  The menu ID is used to add or remove the entry to a menu.
        /// </remarks>        <return> the menu ID
        ///      </return>
        ///         <short>    Returns the menu ID of the service desktop entry.</short>
        public string MenuId() {
            return (string) interceptor.Invoke("menuId", "menuId() const", typeof(string));
        }
        /// <remarks>
        ///  Returns a normalized ID suitable for storing in configuration files.
        ///  It will be based on the menu-id when available and otherwise falls
        ///  back to entryPath()
        /// </remarks>        <return> the storage ID
        ///      </return>
        ///         <short>    Returns a normalized ID suitable for storing in configuration files.</short>
        public string StorageId() {
            return (string) interceptor.Invoke("storageId", "storageId() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the DBUSStartupType supported by this service.
        /// </remarks>        <return> the DBUSStartupType supported by this service
        ///      </return>
        ///         <short>    Returns the DBUSStartupType supported by this service.</short>
        public KService.DBusStartupType DbusStartupType() {
            return (KService.DBusStartupType) interceptor.Invoke("dbusStartupType", "dbusStartupType() const", typeof(KService.DBusStartupType));
        }
        /// <remarks>
        ///  Returns the working directory to run the program in.
        /// </remarks>        <return> the working directory to run the program in,
        ///          or string() if not set
        ///      </return>
        ///         <short>    Returns the working directory to run the program in.</short>
        public string Path() {
            return (string) interceptor.Invoke("path", "path() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the descriptive comment for the service, if there is one.
        /// </remarks>        <return> the descriptive comment for the service, or string()
        ///          if not set
        ///      </return>
        ///         <short>    Returns the descriptive comment for the service, if there is one.</short>
        public string Comment() {
            return (string) interceptor.Invoke("comment", "comment() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the generic name for the service, if there is one
        ///  (e.g. "Mail Client").
        /// </remarks>        <return> the generic name,
        ///          or string() if not set
        ///      </return>
        ///         <short>    Returns the generic name for the service, if there is one  (e.</short>
        public string GenericName() {
            return (string) interceptor.Invoke("genericName", "genericName() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the untranslated (US English) generic name
        ///  for the service, if there is one
        ///  (e.g. "Mail Client").
        /// </remarks>        <return> the generic name,
        ///          or string() if not set
        ///      </return>
        ///         <short>    Returns the untranslated (US English) generic name  for the service, if there is one  (e.</short>
        public string UntranslatedGenericName() {
            return (string) interceptor.Invoke("untranslatedGenericName", "untranslatedGenericName() const", typeof(string));
        }
        /// <remarks>
        ///  Returns a list of descriptive keywords the service, if there are any.
        /// </remarks>        <return> the list of keywords
        ///      </return>
        ///         <short>    Returns a list of descriptive keywords the service, if there are any.</short>
        public List<string> Keywords() {
            return (List<string>) interceptor.Invoke("keywords", "keywords() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Returns a list of VFolder categories.
        /// </remarks>        <return> the list of VFolder categories
        ///      </return>
        ///         <short>    Returns a list of VFolder categories.</short>
        public List<string> Categories() {
            return (List<string>) interceptor.Invoke("categories", "categories() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Returns the service types that this service supports.
        /// </remarks>        <return> the list of service types that are supported
        ///  Note that this doesn't include inherited servicetypes or mimetypes,
        ///  only the service types listed in the .desktop file.
        ///      </return>
        ///         <short>    Returns the service types that this service supports.</short>
        public List<string> ServiceTypes() {
            return (List<string>) interceptor.Invoke("serviceTypes", "serviceTypes() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Checks whether the service supports this service type
        /// <param> name="serviceTypePtr" The name of the service type you are
        ///         interested in determining whether this service supports.
        /// </param></remarks>        <return> true if the service type you specified is supported, otherwise false.
        ///      </return>
        ///         <short>    Checks whether the service supports this service type </short>
        public bool HasServiceType(string serviceTypePtr) {
            return (bool) interceptor.Invoke("hasServiceType$", "hasServiceType(const QString&) const", typeof(bool), typeof(string), serviceTypePtr);
        }
        /// <remarks>
        ///  Checks whether the mime supports this mime type
        /// <param> name="mimeTypePtr" The name of the mime type you are
        ///         interested in determining whether this service supports.
        /// </param> Note that if you only have the name of the mime type, you have to look it up
        ///  with KMimeType.MimeType( mimetype ) and use .data() on the result (this is
        ///  because KService doesn't know KMimeType for dependency reasons)
        ///  Warning this method will fail to return true if this KService isn't from ksycoca
        ///  (i.e. it was created with a full path or a KDesktopFile) and the mimetype
        ///  isn't explicited listed in the .desktop file but a parent mimetype is.
        ///  For this reason you should generally get KServices with KMimeTypeTrader
        ///  or one of the KService.ServiceBy methods.
        /// </remarks>        <return> true if the mime type you specified is supported, otherwise false.
        ///      </return>
        ///         <short>    Checks whether the mime supports this mime type </short>
        public bool HasMimeType(KServiceType mimeTypePtr) {
            return (bool) interceptor.Invoke("hasMimeType#", "hasMimeType(const KServiceType*) const", typeof(bool), typeof(KServiceType), mimeTypePtr);
        }
        /// <remarks>
        ///  Set to true if it is allowed to use this service as the default (main)
        ///  action for the files it supports (e.g. Left Click in a file manager, or KRun in general).
        ///  If not, then this service is only available in RMB popups, so it must
        ///  be selected explicitly by the user in order to be used.
        ///  Note that servicemenus supersede this functionality though, at least in konqueror.
        /// </remarks>        <return> true if the service may be used as the default (main) handler
        ///      </return>
        ///         <short>    Set to true if it is allowed to use this service as the default (main)  action for the files it supports (e.</short>
        public bool AllowAsDefault() {
            return (bool) interceptor.Invoke("allowAsDefault", "allowAsDefault() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns the actions defined in this desktop file
        ///      </remarks>        <short>    Returns the actions defined in this desktop file      </short>
        public List<KServiceAction> Actions() {
            return (List<KServiceAction>) interceptor.Invoke("actions", "actions() const", typeof(List<KServiceAction>));
        }
        /// <remarks>
        ///  Checks whether this service can handle several files as
        ///  startup arguments.
        /// </remarks>        <return> true if multiple files may be passed to this service at
        ///  startup. False if only one file at a time may be passed.
        ///      </return>
        ///         <short>    Checks whether this service can handle several files as  startup arguments.</short>
        public bool AllowMultipleFiles() {
            return (bool) interceptor.Invoke("allowMultipleFiles", "allowMultipleFiles() const", typeof(bool));
        }
        /// <remarks>
        ///  What preference to associate with this service initially (before
        ///  the user has had any chance to define a profile for it).
        ///  The bigger the value, the most preferred the service is.
        /// </remarks>        <return> the service preference level of the service
        ///      </return>
        ///         <short>    What preference to associate with this service initially (before  the user has had any chance to define a profile for it).</short>
        public int InitialPreference() {
            return (int) interceptor.Invoke("initialPreference", "initialPreference() const", typeof(int));
        }
        /// <remarks>
        ///  Whether the entry should be suppressed in menus.
        /// </remarks>        <return> true to suppress this service
        ///      </return>
        ///         <short>    Whether the entry should be suppressed in menus.</short>
        public bool NoDisplay() {
            return (bool) interceptor.Invoke("noDisplay", "noDisplay() const", typeof(bool));
        }
        /// <remarks>
        ///  Name of the application this service belongs to.
        ///  (Useful for e.g. plugins)
        /// </remarks>        <return> the parent application, or string() if not set
        ///      </return>
        ///         <short>    Name of the application this service belongs to.</short>
        public string ParentApp() {
            return (string) interceptor.Invoke("parentApp", "parentApp() const", typeof(string));
        }
        /// <remarks>
        ///  The keyword to be used when constructing the plugin using KPluginFactory. The keyword is
        ///  defined with X-KDE-PluginKeyword in the .desktop file and with K_REGISTER_PLUGIN_WITH_KEYWORD
        ///  when implementing the plugin.
        ///      </remarks>        <short>    The keyword to be used when constructing the plugin using KPluginFactory.</short>
        public string PluginKeyword() {
            return (string) interceptor.Invoke("pluginKeyword", "pluginKeyword() const", typeof(string));
        }
        /// <remarks>
        ///  The path to the documentation for this service.
        /// </remarks>        <return> the documentation path, or string() if not set
        ///      </return>
        ///         <short>    The path to the documentation for this service.</short>
        public string DocPath() {
            return (string) interceptor.Invoke("docPath", "docPath() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the requested property.
        /// <param> name="_name" the name of the property
        /// </param><param> name="t" the assumed type of the property
        /// </param></remarks>        <return> the property, or invalid if not found
        /// </return>
        ///         <short>    Returns the requested property.</short>
        ///         <see> KServiceType</see>
        public QVariant Property(string _name, QVariant.TypeOf t) {
            return (QVariant) interceptor.Invoke("property$$", "property(const QString&, QVariant::Type) const", typeof(QVariant), typeof(string), _name, typeof(QVariant.TypeOf), t);
        }
        /// <remarks>
        ///  Returns a path that can be used for saving changes to this
        ///  service
        /// </remarks>        <return> path that can be used for saving changes to this service
        ///      </return>
        ///         <short>    Returns a path that can be used for saving changes to this  service </short>
        public string LocateLocal() {
            return (string) interceptor.Invoke("locateLocal", "locateLocal() const", typeof(string));
        }
        /// <remarks>
        ///  Set the menu id
        ///      </remarks>        <short>   </short>
        public void SetMenuId(string menuId) {
            interceptor.Invoke("setMenuId$", "setMenuId(const QString&)", typeof(void), typeof(string), menuId);
        }
        /// <remarks>
        ///  Sets whether to use a terminal or not
        ///      </remarks>        <short>   </short>
        public void SetTerminal(bool b) {
            interceptor.Invoke("setTerminal$", "setTerminal(bool)", typeof(void), typeof(bool), b);
        }
        /// <remarks>
        ///  Sets the terminal options to use
        ///      </remarks>        <short>   </short>
        public void SetTerminalOptions(string options) {
            interceptor.Invoke("setTerminalOptions$", "setTerminalOptions(const QString&)", typeof(void), typeof(string), options);
        }
        ~KService() {
            interceptor.Invoke("~KService", "~KService()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KService", "~KService()", typeof(void));
        }
        /// <remarks>
        ///  Find a service by name, i.e. the translated Name field. You should
        ///  never use this method with a literal name as argument, since the name
        ///  is translated Name field of the desktop file. See serviceByStorageId instead.
        /// <param> name="_name" the name to search
        /// </param></remarks>        <return> a pointer to the requested service or 0 if the service is
        ///          unknown.
        ///  @em Very @em important: Don't store the result in a KService* !
        ///      </return>
        ///         <short>    Find a service by name, i.</short>
        public static KService ServiceByName(string _name) {
            return (KService) staticInterceptor.Invoke("serviceByName$", "serviceByName(const QString&)", typeof(KService), typeof(string), _name);
        }
        /// <remarks>
        ///  Find a service based on its path as returned by entryPath().
        ///  It's usually better to use serviceByStorageId() instead.
        /// <param> name="_path" the path of the configuration file
        /// </param></remarks>        <return> a pointer to the requested service or 0 if the service is
        ///          unknown.
        ///  @em Very @em important: Don't store the result in a KService* !
        ///      </return>
        ///         <short>    Find a service based on its path as returned by entryPath().</short>
        public static KService ServiceByDesktopPath(string _path) {
            return (KService) staticInterceptor.Invoke("serviceByDesktopPath$", "serviceByDesktopPath(const QString&)", typeof(KService), typeof(string), _path);
        }
        /// <remarks>
        ///  Find a service by the name of its desktop file, not depending on
        ///  its actual location (as long as it's under the applnk or service
        ///  directories). For instance "konqbrowser" or "kcookiejar". Note that
        ///  the ".desktop" extension is implicit.
        ///  This is the recommended method (safe even if the user moves stuff)
        ///  but note that it assumes that no two entries have the same filename.
        /// <param> name="_name" the name of the configuration file
        /// </param></remarks>        <return> a pointer to the requested service or 0 if the service is
        ///          unknown.
        ///  @em Very @em important: Don't store the result in a KService* !
        ///      </return>
        ///         <short>    Find a service by the name of its desktop file, not depending on  its actual location (as long as it's under the applnk or service  directories).</short>
        public static KService ServiceByDesktopName(string _name) {
            return (KService) staticInterceptor.Invoke("serviceByDesktopName$", "serviceByDesktopName(const QString&)", typeof(KService), typeof(string), _name);
        }
        /// <remarks>
        ///  Find a service by its menu-id
        /// <param> name="_menuId" the menu id of the service
        /// </param></remarks>        <return> a pointer to the requested service or 0 if the service is
        ///          unknown.
        ///  @em Very @em important: Don't store the result in a KService* !
        ///      </return>
        ///         <short>    Find a service by its menu-id </short>
        public static KService ServiceByMenuId(string _menuId) {
            return (KService) staticInterceptor.Invoke("serviceByMenuId$", "serviceByMenuId(const QString&)", typeof(KService), typeof(string), _menuId);
        }
        /// <remarks>
        ///  Find a service by its storage-id or desktop-file path. This
        ///  function will try very hard to find a matching service.
        /// <param> name="_storageId" the storage id or desktop-file path of the service
        /// </param></remarks>        <return> a pointer to the requested service or 0 if the service is
        ///          unknown.
        ///  @em Very @em important: Don't store the result in a KService* !
        ///      </return>
        ///         <short>    Find a service by its storage-id or desktop-file path.</short>
        public static KService ServiceByStorageId(string _storageId) {
            return (KService) staticInterceptor.Invoke("serviceByStorageId$", "serviceByStorageId(const QString&)", typeof(KService), typeof(string), _storageId);
        }
        /// <remarks>
        ///  Returns the whole list of services.
        ///   Useful for being able to
        ///  to display them in a list box, for example.
        ///  More memory consuming than the ones above, don't use unless
        ///  really necessary.
        /// </remarks>        <return> the list of all services
        ///      </return>
        ///         <short>    Returns the whole list of services.</short>
        public static List<KService> AllServices() {
            return (List<KService>) staticInterceptor.Invoke("allServices", "allServices()", typeof(List<KService>));
        }
        /// <remarks>
        ///  Returns a path that can be used to create a new KService based
        ///  on <code>suggestedName.</code>
        /// <param> name="showInMenu" true, if the service should be shown in the KDE menu
        ///         false, if the service should be hidden from the menu
        ///         This argument isn't used anymore, use NoDisplay=true to hide the service.
        /// </param><param> name="suggestedName" name to base the file on, if a service with such
        ///         name already exists, a prefix will be added to make it unique.
        /// </param><param> name="menuId" If provided, menuId will be set to the menu id to use for
        ///         the KService
        /// </param><param> name="reservedMenuIds" If provided, the path and menu id will be chosen
        ///         in such a way that the new menu id does not conflict with any
        ///         of the reservedMenuIds
        /// </param></remarks>        <return> The path to use for the new KService.
        ///      </return>
        ///         <short>    Returns a path that can be used to create a new KService based  on <code>suggestedName.</code></short>
        public static string NewServicePath(bool showInMenu, string suggestedName, StringBuilder menuId, List<string> reservedMenuIds) {
            return (string) staticInterceptor.Invoke("newServicePath$$$?", "newServicePath(bool, const QString&, QString*, const QStringList*)", typeof(string), typeof(bool), showInMenu, typeof(string), suggestedName, typeof(StringBuilder), menuId, typeof(List<string>), reservedMenuIds);
        }
        public static string NewServicePath(bool showInMenu, string suggestedName, StringBuilder menuId) {
            return (string) staticInterceptor.Invoke("newServicePath$$$", "newServicePath(bool, const QString&, QString*)", typeof(string), typeof(bool), showInMenu, typeof(string), suggestedName, typeof(StringBuilder), menuId);
        }
        public static string NewServicePath(bool showInMenu, string suggestedName) {
            return (string) staticInterceptor.Invoke("newServicePath$$", "newServicePath(bool, const QString&)", typeof(string), typeof(bool), showInMenu, typeof(string), suggestedName);
        }
    }
}
