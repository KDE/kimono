//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  This dialog only works if your application uses the XML UI
    ///  framework for creating menus and toolbars.  It depends on the XML
    ///  files to describe the toolbar layouts and it requires the actions
    ///  to determine which buttons are active.
    ///  Typically you do not need to use it directly as KXmlGuiWindow.SetupGUI
    ///  takes care of it.
    ///  If you use plugListAction you need to overload saveNewToolbarConfig()
    ///  to plug actions again:
    ///  <pre>
    ///  void MyClass.SaveNewToolbarConfig()
    ///  {
    ///    KXmlGuiWindow.SaveNewToolbarConfig();
    ///    plugActionList( "list1", list1Actions );
    ///    plugActionList( "list2", list2Actions );
    ///  }
    ///  </pre>
    ///  When created, KEditToolBar takes a KXMLGUIFactory object, and uses it to
    ///  find all of the action collections and XML files (there is one of each for the
    ///  mainwindow, but there could be more, when adding other XMLGUI clients like
    ///  KParts or plugins). The editor aims to be semi-intelligent about where it
    ///  assigns any modifications. In other words, it will not write out part specific
    ///  changes to your application's main XML file.
    ///  KXmlGuiWindow and KParts.MainWindow take care of creating KEditToolBar correctly
    ///  and connecting to its newToolBarConfig slot, but if you really really want to do it
    ///  yourself, see the KXmlGuiWindow.ConfigureToolbars() and KXmlGuiWindow.SaveNewToolbarConfig() code.
    ///  See <see cref="IKEditToolBarSignals"></see> for signals emitted by KEditToolBar
    /// </remarks>        <author> Kurt Granroth <granroth@kde.org>
    ///  @maintainer David Faure <faure@kde.org>
    ///  </author>
    ///         <short> A dialog used to customize or configure toolbars. </short>
    [SmokeClass("KEditToolBar")]
    public class KEditToolBar : KDialog, IDisposable {
        protected KEditToolBar(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KEditToolBar), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KEditToolBar() {
            staticInterceptor = new SmokeInvocation(typeof(KEditToolBar), null);
        }
        /// <remarks>
        ///  Old constructor for apps that do not use components.
        ///  This constructor is somewhat deprecated, since it doesn't work
        ///  with any KXMLGuiClient being added to the mainwindow.
        ///  You really want to use the other constructor.
        ///  You <b>must</b> pass along your collection of actions (some of which appear in your toolbars).
        ///  The other two parameters are optional.
        /// <param> name="collection" The collection of actions to work on.
        /// </param><param> name="parent" The parent of the dialog.
        ///    </param></remarks>        <short>    Old constructor for apps that do not use components.</short>
        public KEditToolBar(KActionCollection collection, QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KEditToolBar##", "KEditToolBar(KActionCollection*, QWidget*)", typeof(void), typeof(KActionCollection), collection, typeof(QWidget), parent);
        }
        public KEditToolBar(KActionCollection collection) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KEditToolBar#", "KEditToolBar(KActionCollection*)", typeof(void), typeof(KActionCollection), collection);
        }
        /// <remarks>
        ///  Main constructor.
        ///  The main parameter, factory(), is a pointer to the
        ///  XML GUI factory object for your application.  It contains a list
        ///  of all of the GUI clients (along with the action collections and
        ///  xml files) and the toolbar editor uses that.
        ///  Use this like so:
        ///  <pre>
        ///  KEditToolBar edit(factory());
        ///  if (edit.exec())
        ///  ...
        ///  </pre>
        /// <param> name="factory" Your application's factory object
        /// </param><param> name="parent" The usual parent for the dialog.
        ///    </param></remarks>        <short>    Main constructor.</short>
        public KEditToolBar(KXMLGUIFactory factory, QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KEditToolBar##", "KEditToolBar(KXMLGUIFactory*, QWidget*)", typeof(void), typeof(KXMLGUIFactory), factory, typeof(QWidget), parent);
        }
        public KEditToolBar(KXMLGUIFactory factory) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KEditToolBar#", "KEditToolBar(KXMLGUIFactory*)", typeof(void), typeof(KXMLGUIFactory), factory);
        }
        /// <remarks>
        ///  Sets the default toolbar that will be selected when the dialog is shown.
        ///  If not set, or string() is passed in, the global default tool bar name
        ///  will be used.
        /// <param> name="toolBarName" the name of the tool bar
        /// </param></remarks>        <short>    Sets the default toolbar that will be selected when the dialog is shown.</short>
        ///         <see> setGlobalDefaultToolBar</see>
        public void SetDefaultToolBar(string toolBarName) {
            interceptor.Invoke("setDefaultToolBar$", "setDefaultToolBar(const QString&)", typeof(void), typeof(string), toolBarName);
        }
        /// <remarks>
        ///  The name (absolute or relative) of your application's UI resource file
        ///  is assumed to be share/apps/appname/appnameui.rc though this can be
        ///  overridden by calling this method.
        ///  The global parameter controls whether or not the
        ///  global resource file is used.  If this is <code>true</code>, then you may
        ///  edit all of the actions in your toolbars -- global ones and
        ///  local one.  If it is <code>false</code>, then you may edit only your
        ///  application's entries.  The only time you should set this to
        ///  false is if your application does not use the global resource
        ///  file at all (very rare).
        /// <param> name="xmlfile" The application's local resource file.
        /// </param><param> name="global" If <code>true</code>, then the global resource file will also
        ///                be parsed.
        ///    </param></remarks>        <short>    The name (absolute or relative) of your application's UI resource file  is assumed to be share/apps/appname/appnameui.</short>
        public void SetResourceFile(string file, bool global) {
            interceptor.Invoke("setResourceFile$$", "setResourceFile(const QString&, bool)", typeof(void), typeof(string), file, typeof(bool), global);
        }
        public void SetResourceFile(string file) {
            interceptor.Invoke("setResourceFile$", "setResourceFile(const QString&)", typeof(void), typeof(string), file);
        }
        [SmokeMethod("showEvent(QShowEvent*)")]
        protected override void ShowEvent(QShowEvent arg1) {
            interceptor.Invoke("showEvent#", "showEvent(QShowEvent*)", typeof(void), typeof(QShowEvent), arg1);
        }
        [SmokeMethod("hideEvent(QHideEvent*)")]
        protected override void HideEvent(QHideEvent arg1) {
            interceptor.Invoke("hideEvent#", "hideEvent(QHideEvent*)", typeof(void), typeof(QHideEvent), arg1);
        }
        ~KEditToolBar() {
            interceptor.Invoke("~KEditToolBar", "~KEditToolBar()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KEditToolBar", "~KEditToolBar()", typeof(void));
        }
        /// <remarks>
        ///  Sets the default toolbar which will be auto-selected for all
        ///  KEditToolBar instances. Can be overridden on a per-dialog basis
        ///  by calling setDefaultToolBar( string ) on the dialog.
        /// <param> name="toolbarName" the name of the tool bar
        ///    </param></remarks>        <short>    Sets the default toolbar which will be auto-selected for all  KEditToolBar instances.</short>
        public static void SetGlobalDefaultToolBar(string toolBarName) {
            staticInterceptor.Invoke("setGlobalDefaultToolBar$", "setGlobalDefaultToolBar(const char*)", typeof(void), typeof(string), toolBarName);
        }
        protected new IKEditToolBarSignals Emit {
            get { return (IKEditToolBarSignals) Q_EMIT; }
        }
    }

    public interface IKEditToolBarSignals : IKDialogSignals {
        /// <remarks>
        ///  Signal emitted when 'apply' or 'ok' is clicked or toolbars were reset.
        ///  Connect to it, to plug action lists and to call applyMainWindowSettings
        ///  (see sample code in this class's documentation)
        ///    </remarks>        <short>    Signal emitted when 'apply' or 'ok' is clicked or toolbars were reset.</short>
        [Q_SIGNAL("void newToolBarConfig()")]
        void NewToolBarConfig();
        [Q_SIGNAL("void newToolbarConfig()")]
        void NewToolbarConfig();
    }
}
