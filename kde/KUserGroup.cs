//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  \class KUserGroup kuser.h <KUserGroup>
    ///  This class represents a group on your system. You can either get
    ///  information about the group of the current user, of fetch information about
    ///  a group on the system. Instances of this class will be explicitly shared,
    ///  so copying objects is very cheap and you can safely pass objects by value.
    /// </remarks>        <author> Jan Schaefer <j_schaef@informatik.uni-kl.de>
    ///  </author>
    ///         <short> Represents a group on your system.</short>
    [SmokeClass("KUserGroup")]
    public class KUserGroup : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KUserGroup(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KUserGroup), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KUserGroup() {
            staticInterceptor = new SmokeInvocation(typeof(KUserGroup), null);
        }
        // KUserGroup* KUserGroup(K_GID arg1); >>>> NOT CONVERTED
        // KUserGroup* KUserGroup(const group* arg1); >>>> NOT CONVERTED
        // K_GID gid(); >>>> NOT CONVERTED
        /// <remarks>
        ///  Create an object from a group name.
        ///  If the group does not exist, isValid() will return false.
        /// <param> name="name" the name of the group
        ///    </param></remarks>        <short>    Create an object from a group name.</short>
        public KUserGroup(string name) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KUserGroup$", "KUserGroup(const QString&)", typeof(void), typeof(string), name);
        }
        /// <remarks>
        ///  Create an object from the group of the current user.
        /// <param> name="mode" if #KUser.UseEffectiveUID is passed the effective user
        ///         will be used. If #KUser.UseRealUserID is passed the real user
        ///         will be used.
        ///         The real UID will be different than the effective UID in setuid
        ///         programs; in  such a case use the effective UID for checking
        ///         permissions, and the real UID for displaying information about
        ///         the group associated with the user.
        ///    </param></remarks>        <short>    Create an object from the group of the current user.</short>
        public KUserGroup(KUser.UIDMode mode) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KUserGroup$", "KUserGroup(KUser::UIDMode)", typeof(void), typeof(KUser.UIDMode), mode);
        }
        public KUserGroup() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KUserGroup", "KUserGroup()", typeof(void));
        }
        /// <remarks>
        ///  Creates a new KUserGroup instance from another KUserGroup object
        /// <param> name="group" the KUserGroup to copy
        ///    </param></remarks>        <short>    Creates a new KUserGroup instance from another KUserGroup object </short>
        public KUserGroup(KUserGroup group) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KUserGroup#", "KUserGroup(const KUserGroup&)", typeof(void), typeof(KUserGroup), group);
        }
        /// <remarks>
        ///  Two KUserGroup objects are equal if their gid()s are identical.
        ///  Invalid groups never compare equal.
        /// </remarks>        <return> true if the groups are identical
        ///    </return>
        ///         <short>    Two KUserGroup objects are equal if their gid()s are identical.</short>
        public override bool Equals(object o) {
            if (!(o is KUserGroup)) { return false; }
            return this == (KUserGroup) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        /// <remarks>
        ///  Returns whether the group is valid.
        ///  A KUserGroup object can be invalid if it is
        ///  created with a non-existing gid or name.
        /// </remarks>        <return> true if the group is valid
        ///    </return>
        ///         <short>    Returns whether the group is valid.</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns the group id of the group.
        /// </remarks>        <return> the group id of the group or -1 if the group is invalid
        ///    </return>
        ///         <short>    Returns the group id of the group.</short>
        /// <remarks>
        ///  The name of the group.
        /// </remarks>        <return> the name of the group
        ///    </return>
        ///         <short>    The name of the group.</short>
        public string Name() {
            return (string) interceptor.Invoke("name", "name() const", typeof(string));
        }
        /// <remarks>
        ///  Returns a list of all users of the group.
        /// </remarks>        <return> a list of all users of the group
        ///    </return>
        ///         <short>    Returns a list of all users of the group.</short>
        public List<KUser> Users() {
            return (List<KUser>) interceptor.Invoke("users", "users() const", typeof(List<KUser>));
        }
        /// <remarks>
        ///  Returns a list of all user login names of the group.
        /// </remarks>        <return> a list of all user login names of the group
        ///    </return>
        ///         <short>    Returns a list of all user login names of the group.</short>
        public List<string> UserNames() {
            return (List<string>) interceptor.Invoke("userNames", "userNames() const", typeof(List<string>));
        }
        ~KUserGroup() {
            interceptor.Invoke("~KUserGroup", "~KUserGroup()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KUserGroup", "~KUserGroup()", typeof(void));
        }
        public static bool operator==(KUserGroup lhs, KUserGroup group) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KUserGroup&) const", typeof(bool), typeof(KUserGroup), lhs, typeof(KUserGroup), group);
        }
        public static bool operator!=(KUserGroup lhs, KUserGroup group) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KUserGroup&) const", typeof(bool), typeof(KUserGroup), lhs, typeof(KUserGroup), group);
        }
        /// <remarks>
        ///  Returns a list of all groups on this system
        ///    </remarks>        <short>    Returns a list of all groups on this system    </short>
        public static List<KUserGroup> AllGroups() {
            return (List<KUserGroup>) staticInterceptor.Invoke("allGroups", "allGroups()", typeof(List<KUserGroup>));
        }
        /// <remarks>
        ///  Returns a list of all group names on this system
        ///    </remarks>        <short>    Returns a list of all group names on this system    </short>
        public static List<string> AllGroupNames() {
            return (List<string>) staticInterceptor.Invoke("allGroupNames", "allGroupNames()", typeof(List<string>));
        }
    }
}
