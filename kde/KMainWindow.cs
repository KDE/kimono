//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  Top level widget that provides toolbars, a status line and a frame.
    ///  It should be used as a top level (parent-less) widget.
    ///  It manages the geometry for all its children, including your
    ///  main widget.
    ///  Normally, you will inherit from KMainWindow,
    ///  then construct (or use some existing) widget as
    ///  your main view. You can set only one main view.
    ///  You can add as many toolbars as you like. There can be only one menubar
    ///  and only one statusbar.
    ///  The toolbars, menubar, and statusbar can be created by the
    ///  KMainWindow and - unlike the old KMainWindow - may, but do not
    ///  have to, be deleted by you. KMainWindow will handle that internally.
    ///  Height and width can be operated independently from each other. Simply
    ///  define the minimum/maximum height/width of your main widget and
    ///  KMainWindow will take this into account. For fixed size windows set
    ///  your main widget to a fixed size.
    ///  Fixed aspect ratios (heightForWidth()) and fixed width widgets are
    ///  not supported.
    ///  KMainWindow will set icon, mini icon and caption, which it gets
    ///  from KApplication. It provides full session management, and
    ///  will save its position, geometry and positions of toolbars and
    ///  menubar on logout. If you want to save additional data, reimplement
    ///  saveProperties() and (to read them again on next login)
    ///  readProperties(). To save special data about your data, reimplement
    ///  saveGlobalProperties(). To warn user that application or
    ///  windows have unsaved data on close or logout, reimplement
    ///  queryClose() and/or queryExit().
    ///  There are also kRestoreMainWindows convenience functions which
    ///  can restore all your windows on next login.
    ///  Note that KMainWindow uses KGlobal.Ref() and KGlobal.Deref() so that closing
    ///  the last mainwindow will quit the application unless there is still something
    ///  that holds a ref in KGlobal - like a KIO job, or a systray icon.
    /// </remarks>        <author> Reginald Stadlbauer (reggie@kde.org) Stephan Kulow (coolo@kde.org), Matthias Ettrich (ettrich@kde.org), Chris Schlaeger (cs@kde.org), Sven Radej (radej@kde.org). Maintained by David Faure (faure@kde.org)
    ///  </author>
    ///         <short> %KDE top level main window.</short>
    ///         <see> KApplication</see>
    [SmokeClass("KMainWindow")]
    public class KMainWindow : QMainWindow, IDisposable {
        protected KMainWindow(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KMainWindow), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KMainWindow() {
            staticInterceptor = new SmokeInvocation(typeof(KMainWindow), null);
        }
        [Q_PROPERTY("bool", "hasMenuBar")]
        public bool HasMenuBar {
            get { return (bool) interceptor.Invoke("hasMenuBar", "hasMenuBar()", typeof(bool)); }
        }
        [Q_PROPERTY("bool", "autoSaveSettings")]
        public bool AutoSaveSettings {
            get { return (bool) interceptor.Invoke("autoSaveSettings", "autoSaveSettings()", typeof(bool)); }
        }
        [Q_PROPERTY("QString", "autoSaveGroup")]
        public string AutoSaveGroup {
            get { return (string) interceptor.Invoke("autoSaveGroup", "autoSaveGroup()", typeof(string)); }
        }
        [Q_PROPERTY("bool", "initialGeometrySet")]
        public bool InitialGeometrySet {
            get { return (bool) interceptor.Invoke("initialGeometrySet", "initialGeometrySet()", typeof(bool)); }
        }
        // KMainWindow* KMainWindow(KMainWindowPrivate& arg1,QWidget* arg2,Qt::WindowFlags arg3); >>>> NOT CONVERTED
        /// <remarks>
        ///  Construct a main window.
        /// <param> name="parent" The widget parent. This is usually 0 but it may also be the window
        ///  group leader. In that case, the KMainWindow becomes sort of a
        ///  secondary window.
        /// </param><param> name="f" Specify the window flags. The default is none.
        /// </param> Note that a KMainWindow per-default is created with the
        ///  WA_DeleteOnClose attribute, i.e. it is automatically destroyed when the
        ///  window is closed. If you do not want this behavior, call
        ///  setAttribute(Qt.WA_DeleteOnClose, false);
        ///  KMainWindows must be created on the heap with 'new', like:
        ///  <pre>
        ///  KMainWindow kmw = new KMainWindow(...);
        ///  kmw.SetObjectName(...);
        ///  </pre>
        ///  IMPORTANT: For session management and window management to work
        ///  properly, all main windows in the application should have a
        ///  different name. If you don't do it, KMainWindow will create
        ///  a unique name, but it's recommended to explicitly pass a window name that will
        ///  also describe the type of the window. If there can be several windows of the same
        ///  type, append '#' (hash) to the name, and KMainWindow will replace it with numbers to make
        ///  the names unique. For example, for a mail client which has one main window showing
        ///  the mails and folders, and which can also have one or more windows for composing
        ///  mails, the name for the folders window should be e.g. "mainwindow" and
        ///  for the composer windows "composer#".
        ///      </remarks>        <short>    Construct a main window.</short>
        public KMainWindow(QWidget parent, uint f) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KMainWindow#$", "KMainWindow(QWidget*, Qt::WindowFlags)", typeof(void), typeof(QWidget), parent, typeof(uint), f);
        }
        public KMainWindow(QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KMainWindow#", "KMainWindow(QWidget*)", typeof(void), typeof(QWidget), parent);
        }
        public KMainWindow() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KMainWindow", "KMainWindow()", typeof(void));
        }
        /// <remarks>
        ///  Retrieve the standard help menu.
        ///  It contains entries for the
        ///  help system (activated by F1), an optional "What's This?" entry
        ///  (activated by Shift F1), an application specific dialog box,
        ///  and an "About KDE" dialog box.
        ///  Example (adding a standard help menu to your application):
        ///  <pre>
        ///  KMenu help = helpMenu( <myTextString> );
        ///  menuBar().AddMenu( help );
        ///  </pre>
        /// <param> name="aboutAppText" The string that is used in the application
        ///         specific dialog box. If you leave this string empty the
        ///         information in the global KAboutData of the
        ///         application will be used to make a standard dialog box.
        /// </param><param> name="showWhatsThis" Set this to false if you do not want to include
        ///         the "What's This" menu entry.
        /// </param></remarks>        <return> A standard help menu.
        ///      </return>
        ///         <short>    Retrieve the standard help menu.</short>
        public KMenu HelpMenu(string aboutAppText, bool showWhatsThis) {
            return (KMenu) interceptor.Invoke("helpMenu$$", "helpMenu(const QString&, bool)", typeof(KMenu), typeof(string), aboutAppText, typeof(bool), showWhatsThis);
        }
        public KMenu HelpMenu(string aboutAppText) {
            return (KMenu) interceptor.Invoke("helpMenu$", "helpMenu(const QString&)", typeof(KMenu), typeof(string), aboutAppText);
        }
        public KMenu HelpMenu() {
            return (KMenu) interceptor.Invoke("helpMenu", "helpMenu()", typeof(KMenu));
        }
        /// <remarks>
        ///  Returns the help menu. Creates a standard help menu if none exists yet.
        ///  It contains entries for the
        ///  help system (activated by F1), an optional "What's This?" entry
        ///  (activated by Shift F1), an application specific dialog box,
        ///  and an "About KDE" dialog box. You must create the application
        ///  specific dialog box yourself. When the "About application"
        ///  menu entry is activated, a signal will trigger the
        ///  showAboutApplication slot. See showAboutApplication for more
        ///  information.
        ///  Example (adding a help menu to your application):
        ///  <pre>
        ///  menuBar().AddMenu( customHelpMenu() );
        ///  </pre>
        /// <param> name="showWhatsThis" Set this to <code>false</code> if you do not want to include
        ///         the "What's This" menu entry.
        /// </param></remarks>        <return> A standard help menu.
        ///      </return>
        ///         <short>    Returns the help menu.</short>
        public KMenu CustomHelpMenu(bool showWhatsThis) {
            return (KMenu) interceptor.Invoke("customHelpMenu$", "customHelpMenu(bool)", typeof(KMenu), typeof(bool), showWhatsThis);
        }
        public KMenu CustomHelpMenu() {
            return (KMenu) interceptor.Invoke("customHelpMenu", "customHelpMenu()", typeof(KMenu));
        }
        /// <remarks>
        ///  Restore the session specified by <code>number.</code>
        ///  Returns <code>false</code> if this
        ///  fails, otherwise returns <code>true</code> and shows the window.
        ///  You should call canBeRestored() first.
        ///  If <code>show</code> is true (default), this widget will be shown automatically.
        ///      </remarks>        <short>    Restore the session specified by <code>number.</code></short>
        public bool Restore(int number, bool show) {
            return (bool) interceptor.Invoke("restore$$", "restore(int, bool)", typeof(bool), typeof(int), number, typeof(bool), show);
        }
        public bool Restore(int number) {
            return (bool) interceptor.Invoke("restore$", "restore(int)", typeof(bool), typeof(int), number);
        }
        /// <remarks>
        ///  Returns a pointer to the menu bar.
        ///  If there is no menu bar yet one will be created.
        /// </remarks>        <short>    Returns a pointer to the menu bar.</short>
        public KMenuBar MenuBar() {
            return (KMenuBar) interceptor.Invoke("menuBar", "menuBar()", typeof(KMenuBar));
        }
        /// <remarks>
        ///  Returns a pointer to the status bar.
        ///  If there is no status bar yet, one will be created.
        ///  Note that tooltips for kactions in actionCollection() are not
        ///  automatically connected to this statusBar.
        ///  See the KActionCollection documentation for more details.
        /// </remarks>        <short>    Returns a pointer to the status bar.</short>
        ///         <see> KActionCollection</see>
        public KStatusBar StatusBar() {
            return (KStatusBar) interceptor.Invoke("statusBar", "statusBar()", typeof(KStatusBar));
        }
        /// <remarks>
        ///  Returns a pointer to the toolbar with the specified name.
        ///  This refers to toolbars created dynamically from the XML UI
        ///  framework.  If the toolbar does not exist one will be created.
        /// <param> name="name" The internal name of the toolbar. If no name is
        ///              specified "mainToolBar" is assumed.
        /// </param></remarks>        <return> A pointer to the toolbar
        /// </return>
        ///         <short>    Returns a pointer to the toolbar with the specified name.</short>
        public KToolBar ToolBar(string name) {
            return (KToolBar) interceptor.Invoke("toolBar$", "toolBar(const QString&)", typeof(KToolBar), typeof(string), name);
        }
        public KToolBar ToolBar() {
            return (KToolBar) interceptor.Invoke("toolBar", "toolBar()", typeof(KToolBar));
        }
        /// <remarks>
        /// </remarks>        <return> A list of all toolbars for this window
        ///      </return>
        ///         <short>   </short>
        public List<KToolBar> ToolBars() {
            return (List<KToolBar>) interceptor.Invoke("toolBars", "toolBars() const", typeof(List<KToolBar>));
        }
        /// <remarks>
        ///  Call this to enable "auto-save" of toolbar/menubar/statusbar settings
        ///  (and optionally window size).
        ///  If the bars were moved around/shown/hidden when the window is closed,
        ///  saveMainWindowSettings( KConfigGroup(KGlobal.Config(), groupName) ) will be called.
        /// <param> name="groupName" a name that identifies this "type of window".
        ///  You can have several types of window in the same application.
        /// </param><param> name="saveWindowSize" set it to true to include the window size
        ///  when saving.
        /// </param> Typically, you will call setAutoSaveSettings() in your
        ///  KMainWindow-inherited class constructor, and it will take care
        ///  of restoring and saving automatically. Make sure you call this
        ///  _after all_ your bars have been created.
        ///  To make sure that KMainWindow propertly obtains the default
        ///  size of the window you should do the following:
        ///  - Remove hard coded resize() calls in the constructor or main, they
        ///    should be removed in favor of letting the automatic resizing
        ///    determine the default window size.  Hard coded window sizes will
        ///    be wrong for users that have big fonts, use different styles,
        ///    long/small translations, large toolbars, and other factors.
        ///  - Put the setAutoSaveSettings ( or setupGUI() ) call after all widgets
        ///    have been created and placed inside the main window (i.e. for 99% of
        ///    apps setCentralWidget())
        ///  - Widgets that inherit from QWidget (like game boards) should overload
        ///    "QSize sizeHint() const;" to specify a default size rather
        ///    than letting QWidget.Adjust use the default size of 0x0.
        ///      </remarks>        <short>    Call this to enable "auto-save" of toolbar/menubar/statusbar settings  (and optionally window size).</short>
        public void SetAutoSaveSettings(string groupName, bool saveWindowSize) {
            interceptor.Invoke("setAutoSaveSettings$$", "setAutoSaveSettings(const QString&, bool)", typeof(void), typeof(string), groupName, typeof(bool), saveWindowSize);
        }
        public void SetAutoSaveSettings(string groupName) {
            interceptor.Invoke("setAutoSaveSettings$", "setAutoSaveSettings(const QString&)", typeof(void), typeof(string), groupName);
        }
        public void SetAutoSaveSettings() {
            interceptor.Invoke("setAutoSaveSettings", "setAutoSaveSettings()", typeof(void));
        }
        /// <remarks>
        ///  Overload that lets you specify a KConfigGroup.
        ///  This allows the settings to be saved into another file than KGlobal.Config().
        /// </remarks>        <short>    Overload that lets you specify a KConfigGroup.</short>
        public void SetAutoSaveSettings(KConfigGroup group, bool saveWindowSize) {
            interceptor.Invoke("setAutoSaveSettings#$", "setAutoSaveSettings(const KConfigGroup&, bool)", typeof(void), typeof(KConfigGroup), group, typeof(bool), saveWindowSize);
        }
        public void SetAutoSaveSettings(KConfigGroup group) {
            interceptor.Invoke("setAutoSaveSettings#", "setAutoSaveSettings(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), group);
        }
        /// <remarks>
        ///  Disable the auto-save-settings feature.
        ///  You don't normally need to call this, ever.
        ///      </remarks>        <short>    Disable the auto-save-settings feature.</short>
        public void ResetAutoSaveSettings() {
            interceptor.Invoke("resetAutoSaveSettings", "resetAutoSaveSettings()", typeof(void));
        }
        /// <remarks>
        /// </remarks>        <return> the group used for setting-autosaving.
        ///  Only meaningful if setAutoSaveSettings() was called.
        ///  This can be useful for forcing an apply, e.g. after using KEditToolbar.
        /// </return>
        ///         <short>   </short>
        public KConfigGroup AutoSaveConfigGroup() {
            return (KConfigGroup) interceptor.Invoke("autoSaveConfigGroup", "autoSaveConfigGroup() const", typeof(KConfigGroup));
        }
        /// <remarks>
        ///  Read settings for statusbar, menubar and toolbar from their respective
        ///  groups in the config file and apply them.
        /// <param> name="config" Config group to read the settings from.
        /// </param><param> name="force" if set, even default settings are re-applied
        ///      </param></remarks>        <short>    Read settings for statusbar, menubar and toolbar from their respective  groups in the config file and apply them.</short>
        [SmokeMethod("applyMainWindowSettings(const KConfigGroup&, bool)")]
        public virtual void ApplyMainWindowSettings(KConfigGroup config, bool force) {
            interceptor.Invoke("applyMainWindowSettings#$", "applyMainWindowSettings(const KConfigGroup&, bool)", typeof(void), typeof(KConfigGroup), config, typeof(bool), force);
        }
        [SmokeMethod("applyMainWindowSettings(const KConfigGroup&)")]
        public virtual void ApplyMainWindowSettings(KConfigGroup config) {
            interceptor.Invoke("applyMainWindowSettings#", "applyMainWindowSettings(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
        }
        /// <remarks>
        ///  Save settings for statusbar, menubar and toolbar to their respective
        ///  groups in the config group <code>config.</code>
        /// <param> name="config" Config group to save the settings to.
        ///      </param></remarks>        <short>    Save settings for statusbar, menubar and toolbar to their respective  groups in the config group <code>config.</code></short>
        public void SaveMainWindowSettings(KConfigGroup config) {
            interceptor.Invoke("saveMainWindowSettings#", "saveMainWindowSettings(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
        }
        /// <remarks>
        ///  Used from Konqueror when reusing the main window.
        ///      </remarks>        <short>   </short>
        public void IgnoreInitialGeometry() {
            interceptor.Invoke("ignoreInitialGeometry", "ignoreInitialGeometry()", typeof(void));
        }
        /// <remarks>
        ///  Returns the path under which this window's D-Bus object is exported.
        /// </remarks>        <short>    Returns the path under which this window's D-Bus object is exported.</short>
        public string DbusName() {
            return (string) interceptor.Invoke("dbusName", "dbusName() const", typeof(string));
        }
        /// <remarks>
        ///  Makes a KDE compliant caption (window title).
        /// <param> name="caption" Your caption. <b>Do</b> <b>not</b> include the application name
        ///  in this string. It will be added automatically according to the KDE
        ///  standard.
        ///      </param></remarks>        <short>    Makes a KDE compliant caption (window title).</short>
        [Q_SLOT("void setCaption(QString)")]
        [SmokeMethod("setCaption(const QString&)")]
        public virtual void SetCaption(string caption) {
            interceptor.Invoke("setCaption$", "setCaption(const QString&)", typeof(void), typeof(string), caption);
        }
        /// <remarks>
        ///  Makes a KDE compliant caption.
        /// <param> name="caption" Your caption. <b>Do</b> <b>not</b> include the application name
        ///  in this string. It will be added automatically according to the KDE
        ///  standard.
        /// </param><param> name="modified" Specify whether the document is modified. This displays
        ///  an additional sign in the title bar, usually "**".
        ///      </param></remarks>        <short>    Makes a KDE compliant caption.</short>
        [Q_SLOT("void setCaption(QString, bool)")]
        [SmokeMethod("setCaption(const QString&, bool)")]
        public virtual void SetCaption(string caption, bool modified) {
            interceptor.Invoke("setCaption$$", "setCaption(const QString&, bool)", typeof(void), typeof(string), caption, typeof(bool), modified);
        }
        /// <remarks>
        ///  Make a plain caption without any modifications.
        /// <param> name="caption" Your caption. This is the string that will be
        ///  displayed in the window title.
        ///      </param></remarks>        <short>    Make a plain caption without any modifications.</short>
        [Q_SLOT("void setPlainCaption(QString)")]
        [SmokeMethod("setPlainCaption(const QString&)")]
        public virtual void SetPlainCaption(string caption) {
            interceptor.Invoke("setPlainCaption$", "setPlainCaption(const QString&)", typeof(void), typeof(string), caption);
        }
        /// <remarks>
        ///  Open the help page for the application.
        ///   The application name is
        ///  used as a key to determine what to display and the system will attempt
        ///  to open \<appName\>/index.html.
        ///  This method is intended for use by a help button in the toolbar or
        ///  components outside the regular help menu. Use helpMenu() when you
        ///  want to provide access to the help system from the help menu.
        ///  Example (adding a help button to the first toolbar):
        ///  <pre>
        ///  toolBar(0).AddAction(KIcon("help-contents"), i18n("Help"),
        ///                        this, SLOT("appHelpActivated()"));
        ///  </pre>
        ///      </remarks>        <short>    Open the help page for the application.</short>
        [Q_SLOT("void appHelpActivated()")]
        public void AppHelpActivated() {
            interceptor.Invoke("appHelpActivated", "appHelpActivated()", typeof(void));
        }
        /// <remarks>
        ///  Tell the main window that it should save its settings when being closed.
        ///  This is part of the auto-save-settings feature.
        ///  For everything related to toolbars this happens automatically,
        ///  but you have to call setSettingsDirty() in the slot that toggles
        ///  the visibility of the statusbar.
        ///      </remarks>        <short>    Tell the main window that it should save its settings when being closed.</short>
        [Q_SLOT("void setSettingsDirty()")]
        public void SetSettingsDirty() {
            interceptor.Invoke("setSettingsDirty", "setSettingsDirty()", typeof(void));
        }
        /// <remarks>
        ///  Reimplemented to catch QEvent.Polish in order to adjust the object name
        ///  if needed, once all constructor code for the main window has run.
        ///  Also reimplemented to catch when a QDockWidget is added or removed.
        ///      </remarks>        <short>    Reimplemented to catch QEvent.Polish in order to adjust the object name  if needed, once all constructor code for the main window has run.</short>
        [SmokeMethod("event(QEvent*)")]
        protected override bool Event(QEvent arg1) {
            return (bool) interceptor.Invoke("event#", "event(QEvent*)", typeof(bool), typeof(QEvent), arg1);
        }
        /// <remarks>
        ///  Reimplemented to call the queryClose() and queryExit() handlers.
        ///  We recommend that you reimplement the handlers rather than closeEvent().
        ///  If you do it anyway, ensure to call the base implementation to keep
        ///  queryExit() running.
        ///      </remarks>        <short>    Reimplemented to call the queryClose() and queryExit() handlers.</short>
        [SmokeMethod("closeEvent(QCloseEvent*)")]
        protected override void CloseEvent(QCloseEvent arg1) {
            interceptor.Invoke("closeEvent#", "closeEvent(QCloseEvent*)", typeof(void), typeof(QCloseEvent), arg1);
        }
        /// <remarks>
        ///        Called before the very last window is closed, either by the
        ///        user or indirectly by the session manager.
        ///        It is not recommended to do any user interaction in this
        ///        function other than indicating severe errors. Better ask the
        ///        user on queryClose() (see below).
        ///        A typical usage of queryExit() is to write configuration data back.
        ///        Note that the application may continue to run after queryExit()
        ///        (the user may have canceled a shutdown), so you should not do any cleanups
        ///        here. The purpose of queryExit() is purely to prepare the application
        ///        (with possible user interaction) so it can safely be closed later (without
        ///        user interaction).
        ///        If you need to do serious things on exit (like shutting a
        ///        dial-up connection down), connect to the signal
        ///  QCoreApplication.AboutToQuit().
        ///        Default implementation returns <code>true.</code> Returning <code>false</code> will
        ///        cancel the exiting. In the latter case, the last window will
        ///        remain visible. If KApplication.SessionSaving() is true, refusing
        ///        the exit will also cancel KDE logout.
        /// </remarks>        <short>          Called before the very last window is closed, either by the        user or indirectly by the session manager.</short>
        ///         <see> queryClose</see>
        ///         <see> KApplication.SessionSaving</see>
        [SmokeMethod("queryExit()")]
        protected virtual bool QueryExit() {
            return (bool) interceptor.Invoke("queryExit", "queryExit()", typeof(bool));
        }
        /// <remarks>
        ///        Called before the window is closed, either by the user or indirectly by
        ///        the session manager.
        ///        The purpose of this function is to prepare the window in a way that it is
        ///        safe to close it, i.e. without the user losing some data.
        ///        Default implementation returns true. Returning <code>false</code> will cancel
        ///        the closing, and, if KApplication.SessionSaving() is true, it will also
        ///        cancel KDE logout.
        ///        Reimplement this function to prevent the user from losing data.
        ///        Example:
        ///        <pre>
        ///        switch ( KMessageBox.WarningYesNoCancel( this,
        ///                 i18n("Save changes to document foo?")) ) {
        ///        case KMessageBox.Yes :
        ///          // save document here. If saving fails, return false;
        ///          return true;
        ///        case KMessageBox.No :
        ///          return true;
        ///        default: // cancel
        ///          return false;
        ///        </pre>
        ///        Note that you should probably <b>not</b> actually close the document from
        ///        within this method, as it may be called by the session manager before the
        ///        session is saved. If the document is closed before the session save occurs,
        ///        its location might not be properly saved. In addition, the session shutdown
        ///        may be canceled, in which case the document should remain open.
        /// </remarks>        <short>          Called before the window is closed, either by the user or indirectly by        the session manager.</short>
        ///         <see> queryExit</see>
        ///         <see> KApplication.SessionSaving</see>
        [SmokeMethod("queryClose()")]
        protected virtual bool QueryClose() {
            return (bool) interceptor.Invoke("queryClose", "queryClose()", typeof(bool));
        }
        /// <remarks>
        ///  Save your instance-specific properties. The function is
        ///  invoked when the session manager requests your application
        ///  to save its state.
        ///  Please reimplement these function in childclasses.
        ///  Note: No user interaction is allowed
        ///  in this function!
        ///      </remarks>        <short>    Save your instance-specific properties.</short>
        [SmokeMethod("saveProperties(KConfigGroup&)")]
        protected virtual void SaveProperties(KConfigGroup arg1) {
            interceptor.Invoke("saveProperties#", "saveProperties(KConfigGroup&)", typeof(void), typeof(KConfigGroup), arg1);
        }
        /// <remarks>
        ///  Read your instance-specific properties.
        ///     </remarks>        <short>    Read your instance-specific properties.</short>
        [SmokeMethod("readProperties(const KConfigGroup&)")]
        protected virtual void ReadProperties(KConfigGroup arg1) {
            interceptor.Invoke("readProperties#", "readProperties(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), arg1);
        }
        /// <remarks>
        ///  Save your application-wide properties. The function is
        ///  invoked when the session manager requests your application
        ///  to save its state.
        ///  This function is similar to saveProperties() but is only called for
        ///  the very first main window, regardless how many main window are open.
        ///  Override it if you need to save other data about your documents on
        ///  session end. sessionConfig is a config to which that data should be
        ///  saved. Normally, you don't need this function. But if you want to save
        ///  data about your documents that are not in opened windows you might need
        ///  it.
        ///  Default implementation does nothing.
        ///      </remarks>        <short>    Save your application-wide properties.</short>
        [SmokeMethod("saveGlobalProperties(KConfig*)")]
        protected virtual void SaveGlobalProperties(KConfig sessionConfig) {
            interceptor.Invoke("saveGlobalProperties#", "saveGlobalProperties(KConfig*)", typeof(void), typeof(KConfig), sessionConfig);
        }
        /// <remarks>
        ///  The counterpart of saveGlobalProperties().
        ///  Read the application-specific properties in again.
        ///      </remarks>        <short>    The counterpart of saveGlobalProperties().</short>
        [SmokeMethod("readGlobalProperties(KConfig*)")]
        protected virtual void ReadGlobalProperties(KConfig sessionConfig) {
            interceptor.Invoke("readGlobalProperties#", "readGlobalProperties(KConfig*)", typeof(void), typeof(KConfig), sessionConfig);
        }
        protected void SavePropertiesInternal(KConfig arg1, int arg2) {
            interceptor.Invoke("savePropertiesInternal#$", "savePropertiesInternal(KConfig*, int)", typeof(void), typeof(KConfig), arg1, typeof(int), arg2);
        }
        protected bool ReadPropertiesInternal(KConfig arg1, int arg2) {
            return (bool) interceptor.Invoke("readPropertiesInternal#$", "readPropertiesInternal(KConfig*, int)", typeof(bool), typeof(KConfig), arg1, typeof(int), arg2);
        }
        /// <remarks>
        ///  For inherited classes
        ///      </remarks>        <short>    For inherited classes      </short>
        protected bool SettingsDirty() {
            return (bool) interceptor.Invoke("settingsDirty", "settingsDirty() const", typeof(bool));
        }
        /// <remarks>
        ///  For inherited classes
        ///      </remarks>        <short>    For inherited classes      </short>
        protected void SaveWindowSize(KConfigGroup config) {
            interceptor.Invoke("saveWindowSize#", "saveWindowSize(const KConfigGroup&) const", typeof(void), typeof(KConfigGroup), config);
        }
        /// <remarks>
        ///  For inherited classes
        ///  Note that a -geometry on the command line has priority.
        ///      </remarks>        <short>    For inherited classes  Note that a -geometry on the command line has priority.</short>
        protected void RestoreWindowSize(KConfigGroup config) {
            interceptor.Invoke("restoreWindowSize#", "restoreWindowSize(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
        }
        protected void ParseGeometry(bool parsewidth) {
            interceptor.Invoke("parseGeometry$", "parseGeometry(bool)", typeof(void), typeof(bool), parsewidth);
        }
        /// <remarks>
        ///  This slot does nothing.
        ///  It must be reimplemented if you want
        ///  to use a custom About Application dialog box. This slot is
        ///  connected to the About Application entry in the menu returned
        ///  by customHelpMenu.
        ///  Example:
        ///  <pre>
        ///  void MyMainLevel.SetupInterface()
        ///  {
        ///    ..
        ///    menuBar().AddMenu( customHelpMenu() );
        ///    ..
        ///  }
        ///  void MyMainLevel.ShowAboutApplication()
        ///  {
        ///    <activate your custom dialog>
        ///  }
        ///  </pre>
        ///     </remarks>        <short>    This slot does nothing.</short>
        [Q_SLOT("void showAboutApplication()")]
        [SmokeMethod("showAboutApplication()")]
        protected virtual void ShowAboutApplication() {
            interceptor.Invoke("showAboutApplication", "showAboutApplication()", typeof(void));
        }
        /// <remarks>
        ///  This slot should only be called in case you reimplement closeEvent() and
        ///  if you are using the "auto-save" feature. In all other cases,
        ///  setSettingsDirty() should be called instead to benefit from the delayed
        ///  saving.
        ///  Example:
        ///  <pre>
        ///  void MyMainWindow.CloseEvent( QCloseEvent e )
        ///  {
        ///    // Save settings if auto-save is enabled, and settings have changed
        ///    if ( settingsDirty() && autoSaveSettings() )
        ///      saveAutoSaveSettings();
        ///    ..
        ///  }
        ///  </pre>
        ///     </remarks>        <short>    This slot should only be called in case you reimplement closeEvent() and  if you are using the "auto-save" feature.</short>
        ///         <see> setAutoSaveSettings</see>
        ///         <see> setSettingsDirty</see>
        [Q_SLOT("void saveAutoSaveSettings()")]
        protected void SaveAutoSaveSettings() {
            interceptor.Invoke("saveAutoSaveSettings", "saveAutoSaveSettings()", typeof(void));
        }
        ~KMainWindow() {
            interceptor.Invoke("~KMainWindow", "~KMainWindow()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KMainWindow", "~KMainWindow()", typeof(void));
        }
        /// <remarks>
        ///  <b>Session Management</b>
        ///  Try to restore the toplevel widget as defined by the number (1..X).
        ///  If the session did not contain so high a number, the configuration
        ///  is not changed and <code>false</code> returned.
        ///  That means clients could simply do the following:
        ///  <pre>
        ///  if (qApp.IsSessionRestored()){
        ///    int n = 1;
        ///    while (KMainWindow.CanBeRestored(n)){
        ///      (new childMW).Restore(n);
        ///      n++;
        ///    }
        ///  } else {
        ///    // create default application as usual
        ///  }
        ///  </pre>
        ///  Note that QWidget.Show() is called implicitly in restore.
        ///  With this you can easily restore all toplevel windows of your
        ///  application.
        ///  If your application uses different kinds of toplevel
        ///  windows, then you can use KMainWindow.ClassNameOfToplevel(n)
        ///  to determine the exact type before calling the childMW
        ///  constructor in the example from above.
        ///  If your client has only one kind of toplevel widgets (which
        ///  should be pretty usual) then you should use the RESTORE-macro
        ///  for backwards compatibility with 3.1 and 3.0 branches:
        ///  <pre>
        ///  if (qApp.IsSessionRestored())
        ///    RESTORE(childMW)
        ///  else {
        ///    // create default application as usual
        ///  }
        ///  </pre>
        ///  The macro expands to the term above but is easier to use and
        ///  less code to write.
        ///  For new code or if you have more than one kind of toplevel
        ///  widget (each derived from KMainWindow, of course), you can
        ///  use the templated kRestoreMainWindows global functions:
        ///  <pre>
        ///  if (qApp.IsSessionRestored())
        ///    kRestoreMainWindows< childMW1, childMW2, childMW3 >();
        ///  else {
        ///    // create default application as usual
        ///  }
        ///  </pre>
        ///  Currently, these functions are provided for up to three
        ///  template arguments. If you need more, tell us. To help you in
        ///  deciding whether or not you can use kRestoreMainWindows, a
        ///  define KDE_RESTORE_MAIN_WINDOWS_NUM_TEMPLATE_ARGS is provided.
        /// </remarks>        <short>    <b>Session Management</b> </short>
        ///         <see> restore</see>
        ///         <see> classNameOfToplevel</see>
        public static bool CanBeRestored(int number) {
            return (bool) staticInterceptor.Invoke("canBeRestored$", "canBeRestored(int)", typeof(bool), typeof(int), number);
        }
        /// <remarks>
        ///  Returns the className() of the <code>number</code> of the toplevel window which
        ///  should be restored.
        ///  This is only useful if your application uses
        ///  different kinds of toplevel windows.
        ///      </remarks>        <short>    Returns the className() of the <code>number</code> of the toplevel window which  should be restored.</short>
        public static string ClassNameOfToplevel(int number) {
            return (string) staticInterceptor.Invoke("classNameOfToplevel$", "classNameOfToplevel(int)", typeof(string), typeof(int), number);
        }
        /// <remarks>
        ///  List of members of KMainWindow class.
        ///      </remarks>        <short>    List of members of KMainWindow class.</short>
        public static List<KMainWindow> MemberList() {
            return (List<KMainWindow>) staticInterceptor.Invoke("memberList", "memberList()", typeof(List<KMainWindow>));
        }
        protected new IKMainWindowSignals Emit {
            get { return (IKMainWindowSignals) Q_EMIT; }
        }
    }

    public interface IKMainWindowSignals : IQMainWindowSignals {
    }
}
