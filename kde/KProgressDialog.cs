//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  KProgressDialog provides a dialog with a text label, a progress bar
    ///  and an optional cancel button with a KDE look 'n feel.
    ///  Since knowing how long it can take to complete an action and it is
    ///  undesirable to show a dialog for a split second before hiding it,
    ///  there are a few ways to control the timing behavior of KProgressDialog.
    ///  There is a time out that can be set before showing the dialog as well
    ///  as an option to autohide or keep displaying the dialog once complete.
    ///  All the functionality of QProgressBar is available through direct access
    ///  to the progress bar widget via progressBar();
    /// </remarks>        <author> Urs Wolfer uwolfer @ kde.org
    ///  </author>
    ///         <short> A dialog with a progress bar.</short>
    [SmokeClass("KProgressDialog")]
    public class KProgressDialog : KDialog, IDisposable {
        protected KProgressDialog(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KProgressDialog), this);
        }
        /// <remarks>
        ///  Constructs a KProgressDialog
        /// <param> name="parent" Parent of the widget
        /// </param><param> name="caption" Text to display in window title bar
        /// </param><param> name="text" Text to display in the dialog
        /// </param><param> name="flags" The widget flags
        ///          </param></remarks>        <short>    Constructs a KProgressDialog </short>
        public KProgressDialog(QWidget parent, string caption, string text, uint flags) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KProgressDialog#$$$", "KProgressDialog(QWidget*, const QString&, const QString&, Qt::WindowFlags)", typeof(void), typeof(QWidget), parent, typeof(string), caption, typeof(string), text, typeof(uint), flags);
        }
        public KProgressDialog(QWidget parent, string caption, string text) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KProgressDialog#$$", "KProgressDialog(QWidget*, const QString&, const QString&)", typeof(void), typeof(QWidget), parent, typeof(string), caption, typeof(string), text);
        }
        public KProgressDialog(QWidget parent, string caption) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KProgressDialog#$", "KProgressDialog(QWidget*, const QString&)", typeof(void), typeof(QWidget), parent, typeof(string), caption);
        }
        public KProgressDialog(QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KProgressDialog#", "KProgressDialog(QWidget*)", typeof(void), typeof(QWidget), parent);
        }
        public KProgressDialog() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KProgressDialog", "KProgressDialog()", typeof(void));
        }
        /// <remarks>
        ///  Returns the QProgressBar used in this dialog.
        ///  To set the number of steps or other progress bar related
        ///  settings, access the QProgressBar object directly via this method.
        ///          </remarks>        <short>    Returns the QProgressBar used in this dialog.</short>
        public QProgressBar ProgressBar() {
            return (QProgressBar) interceptor.Invoke("progressBar", "progressBar()", typeof(QProgressBar));
        }
        /// <remarks>
        ///  Sets the text in the dialog
        /// <param> name="text" the text to display
        ///          </param></remarks>        <short>    Sets the text in the dialog </short>
        public void SetLabelText(string text) {
            interceptor.Invoke("setLabelText$", "setLabelText(const QString&)", typeof(void), typeof(string), text);
        }
        /// <remarks>
        ///  Returns the current dialog text
        ///          </remarks>        <short>    Returns the current dialog text          </short>
        public string LabelText() {
            return (string) interceptor.Invoke("labelText", "labelText() const", typeof(string));
        }
        /// <remarks>
        ///  Sets whether or not the user can cancel the process.
        ///  If the dialog is cancellable, the Cancel button will be shown
        ///  and the user can close the window using the window decorations.
        ///  If the process is not (or should not be) interuptable,
        ///  set the dialog to be modal and not cancellable.
        ///  The default is true.
        /// <param> name="allowCancel" Set to true to make the dialog non-closable
        ///          </param></remarks>        <short>    Sets whether or not the user can cancel the process.</short>
        public void SetAllowCancel(bool allowCancel) {
            interceptor.Invoke("setAllowCancel$", "setAllowCancel(bool)", typeof(void), typeof(bool), allowCancel);
        }
        /// <remarks>
        ///  Returns true if the dialog can be canceled, false otherwise
        ///          </remarks>        <short>    Returns true if the dialog can be canceled, false otherwise          </short>
        public bool AllowCancel() {
            return (bool) interceptor.Invoke("allowCancel", "allowCancel() const", typeof(bool));
        }
        /// <remarks>
        ///  Sets whether the cancel button is visible. setAllowCancel(false)
        ///  implies showCancelButton(false)
        ///  The default is true.
        /// <param> name="show" Whether or not the cancel button should be shown
        ///          </param></remarks>        <short>    Sets whether the cancel button is visible.</short>
        public void ShowCancelButton(bool show) {
            interceptor.Invoke("showCancelButton$", "showCancelButton(bool)", typeof(void), typeof(bool), show);
        }
        /// <remarks>
        ///  Sets whether the dialog should close automagically when
        ///  all the steps in the QProgressBar have been completed.
        ///  The default is true.
        ///          </remarks>        <short>    Sets whether the dialog should close automagically when  all the steps in the QProgressBar have been completed.</short>
        public void SetAutoClose(bool close) {
            interceptor.Invoke("setAutoClose$", "setAutoClose(bool)", typeof(void), typeof(bool), close);
        }
        /// <remarks>
        ///  Returns true if the dialog will close upon completion,
        ///  or false otherwise
        ///          </remarks>        <short>    Returns true if the dialog will close upon completion,  or false otherwise          </short>
        public bool AutoClose() {
            return (bool) interceptor.Invoke("autoClose", "autoClose() const", typeof(bool));
        }
        /// <remarks>
        ///  Sets whether the dialog should reset the QProgressBar dialog
        ///  back to 0 steps compelete when all steps have been completed.
        ///  This is useful for KProgressDialogs that will be reused.
        ///  The default is false.
        ///          </remarks>        <short>    Sets whether the dialog should reset the QProgressBar dialog  back to 0 steps compelete when all steps have been completed.</short>
        public void SetAutoReset(bool autoReset) {
            interceptor.Invoke("setAutoReset$", "setAutoReset(bool)", typeof(void), typeof(bool), autoReset);
        }
        /// <remarks>
        ///  Returns true if the QProgressBar widget will be reset
        ///  upon completion, or false otherwise
        ///          </remarks>        <short>    Returns true if the QProgressBar widget will be reset  upon completion, or false otherwise          </short>
        public bool AutoReset() {
            return (bool) interceptor.Invoke("autoReset", "autoReset() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns true if the dialog was closed or canceled
        ///  before completion. If the dialog is not cancellable
        ///  it will always return false.
        ///          </remarks>        <short>    Returns true if the dialog was closed or canceled  before completion.</short>
        public bool WasCancelled() {
            return (bool) interceptor.Invoke("wasCancelled", "wasCancelled() const", typeof(bool));
        }
        /// <remarks>
        ///  Ignores the last cancel action if the cancel button was 
        ///  pressed. Useful for kdialog when combined with a KMessageBox
        ///  to display a message like "Are you sure you want to cancel?" 
        ///          </remarks>        <short>    Ignores the last cancel action if the cancel button was   pressed.</short>
        public void IgnoreCancel() {
            interceptor.Invoke("ignoreCancel", "ignoreCancel()", typeof(void));
        }
        /// <remarks>
        ///  Sets the text to appear on the cancel button.
        ///          </remarks>        <short>    Sets the text to appear on the cancel button.</short>
        public void SetButtonText(string text) {
            interceptor.Invoke("setButtonText$", "setButtonText(const QString&)", typeof(void), typeof(string), text);
        }
        /// <remarks>
        ///  Returns the text on the cancel button
        ///          </remarks>        <short>    Returns the text on the cancel button          </short>
        public string ButtonText() {
            return (string) interceptor.Invoke("buttonText", "buttonText() const", typeof(string));
        }
        /// <remarks>
        ///  Set the minimum number of milliseconds to wait before
        ///  actually showing the dialog
        ///          </remarks>        <short>    Set the minimum number of milliseconds to wait before  actually showing the dialog          </short>
        public void SetMinimumDuration(int ms) {
            interceptor.Invoke("setMinimumDuration$", "setMinimumDuration(int)", typeof(void), typeof(int), ms);
        }
        /// <remarks>
        ///  Returns the wait duration in milliseconds
        ///          </remarks>        <short>    Returns the wait duration in milliseconds          </short>
        public int MinimumDuration() {
            return (int) interceptor.Invoke("minimumDuration", "minimumDuration() const", typeof(int));
        }
        [SmokeMethod("reject()")]
        public override void Reject() {
            interceptor.Invoke("reject", "reject()", typeof(void));
        }
        [SmokeMethod("showEvent(QShowEvent*)")]
        protected override void ShowEvent(QShowEvent arg1) {
            interceptor.Invoke("showEvent#", "showEvent(QShowEvent*)", typeof(void), typeof(QShowEvent), arg1);
        }
        ~KProgressDialog() {
            interceptor.Invoke("~KProgressDialog", "~KProgressDialog()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KProgressDialog", "~KProgressDialog()", typeof(void));
        }
        protected new IKProgressDialogSignals Emit {
            get { return (IKProgressDialogSignals) Q_EMIT; }
        }
    }

    public interface IKProgressDialogSignals : IKDialogSignals {
    }
}
