//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  KSelector is the base class for other widgets which
    ///  provides the ability to choose from a one-dimensional
    ///  range of values. An example is the KGradientSelector
    ///  which allows to choose from a range of colors.
    ///  A custom drawing routine for the widget surface has
    ///  to be provided by the subclass.
    ///  </remarks>        <short>    KSelector is the base class for other widgets which  provides the ability to choose from a one-dimensional  range of values.</short>
    [SmokeClass("KSelector")]
    public class KSelector : QAbstractSlider, IDisposable {
        protected KSelector(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KSelector), this);
        }
        [Q_PROPERTY("int", "value")]
        public new int Value {
            get { return (int) interceptor.Invoke("value", "value()", typeof(int)); }
            set { interceptor.Invoke("setValue$", "setValue(int)", typeof(void), typeof(int), value); }
        }
        [Q_PROPERTY("int", "minValue")]
        public int MinValue {
            get { return (int) interceptor.Invoke("minimum", "minimum()", typeof(int)); }
            set { interceptor.Invoke("setMinimum$", "setMinimum(int)", typeof(void), typeof(int), value); }
        }
        [Q_PROPERTY("int", "maxValue")]
        public int MaxValue {
            get { return (int) interceptor.Invoke("maximum", "maximum()", typeof(int)); }
            set { interceptor.Invoke("setMaximum$", "setMaximum(int)", typeof(void), typeof(int), value); }
        }
        /// <remarks>
        ///  Constructs a horizontal one-dimensional selection widget.
        ///    </remarks>        <short>    Constructs a horizontal one-dimensional selection widget.</short>
        public KSelector(QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KSelector#", "KSelector(QWidget*)", typeof(void), typeof(QWidget), parent);
        }
        public KSelector() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KSelector", "KSelector()", typeof(void));
        }
        /// <remarks>
        ///  Constructs a one-dimensional selection widget with
        ///  a given orientation.
        ///    </remarks>        <short>    Constructs a one-dimensional selection widget with  a given orientation.</short>
        public KSelector(Qt.Orientation o, QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KSelector$#", "KSelector(Qt::Orientation, QWidget*)", typeof(void), typeof(Qt.Orientation), o, typeof(QWidget), parent);
        }
        public KSelector(Qt.Orientation o) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KSelector$", "KSelector(Qt::Orientation)", typeof(void), typeof(Qt.Orientation), o);
        }
        /// <remarks>
        /// </remarks>        <return> the rectangle on which subclasses should draw.
        ///    </return>
        ///         <short>   </short>
        public new QRect ContentsRect() {
            return (QRect) interceptor.Invoke("contentsRect", "contentsRect() const", typeof(QRect));
        }
        /// <remarks>
        ///  Sets the indent option of the widget to i.
        ///  This determines whether a shaded frame is drawn.
        ///    </remarks>        <short>    Sets the indent option of the widget to i.</short>
        public void SetIndent(bool i) {
            interceptor.Invoke("setIndent$", "setIndent(bool)", typeof(void), typeof(bool), i);
        }
        /// <remarks>
        /// </remarks>        <return> whether the indent option is set.
        ///    </return>
        ///         <short>   </short>
        public bool Indent() {
            return (bool) interceptor.Invoke("indent", "indent() const", typeof(bool));
        }
        /// <remarks>
        ///  Sets the arrow direction.
        ///    </remarks>        <short>    Sets the arrow direction.</short>
        public void SetArrowDirection(Qt.ArrowType direction) {
            interceptor.Invoke("setArrowDirection$", "setArrowDirection(Qt::ArrowType)", typeof(void), typeof(Qt.ArrowType), direction);
        }
        /// <remarks>
        /// </remarks>        <return> the current arrow direction
        ///    </return>
        ///         <short>   </short>
        public Qt.ArrowType ArrowDirection() {
            return (Qt.ArrowType) interceptor.Invoke("arrowDirection", "arrowDirection() const", typeof(Qt.ArrowType));
        }
        /// <remarks>
        ///  Override this function to draw the contents of the control.
        ///  The default implementation does nothing.
        ///  Draw only within contentsRect().
        ///    </remarks>        <short>    Override this function to draw the contents of the control.</short>
        [SmokeMethod("drawContents(QPainter*)")]
        protected virtual void DrawContents(QPainter arg1) {
            interceptor.Invoke("drawContents#", "drawContents(QPainter*)", typeof(void), typeof(QPainter), arg1);
        }
        /// <remarks>
        ///  Override this function to draw the cursor which
        ///  indicates the current value.
        ///    </remarks>        <short>    Override this function to draw the cursor which  indicates the current value.</short>
        [SmokeMethod("drawArrow(QPainter*, const QPoint&)")]
        protected virtual void DrawArrow(QPainter painter, QPoint pos) {
            interceptor.Invoke("drawArrow##", "drawArrow(QPainter*, const QPoint&)", typeof(void), typeof(QPainter), painter, typeof(QPoint), pos);
        }
        [SmokeMethod("paintEvent(QPaintEvent*)")]
        protected override void PaintEvent(QPaintEvent arg1) {
            interceptor.Invoke("paintEvent#", "paintEvent(QPaintEvent*)", typeof(void), typeof(QPaintEvent), arg1);
        }
        [SmokeMethod("mousePressEvent(QMouseEvent*)")]
        protected override void MousePressEvent(QMouseEvent e) {
            interceptor.Invoke("mousePressEvent#", "mousePressEvent(QMouseEvent*)", typeof(void), typeof(QMouseEvent), e);
        }
        [SmokeMethod("mouseMoveEvent(QMouseEvent*)")]
        protected override void MouseMoveEvent(QMouseEvent e) {
            interceptor.Invoke("mouseMoveEvent#", "mouseMoveEvent(QMouseEvent*)", typeof(void), typeof(QMouseEvent), e);
        }
        [SmokeMethod("mouseReleaseEvent(QMouseEvent*)")]
        protected override void MouseReleaseEvent(QMouseEvent e) {
            interceptor.Invoke("mouseReleaseEvent#", "mouseReleaseEvent(QMouseEvent*)", typeof(void), typeof(QMouseEvent), e);
        }
        [SmokeMethod("wheelEvent(QWheelEvent*)")]
        protected override void WheelEvent(QWheelEvent arg1) {
            interceptor.Invoke("wheelEvent#", "wheelEvent(QWheelEvent*)", typeof(void), typeof(QWheelEvent), arg1);
        }
        ~KSelector() {
            interceptor.Invoke("~KSelector", "~KSelector()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KSelector", "~KSelector()", typeof(void));
        }
        protected new IKSelectorSignals Emit {
            get { return (IKSelectorSignals) Q_EMIT; }
        }
    }

    public interface IKSelectorSignals : IQAbstractSliderSignals {
    }
}
