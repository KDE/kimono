//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  A class that provides information about a KCModule
    ///  KCModuleInfo provides various technical information, such as icon, library
    ///  etc. about a KCModule.n
    ///  @note Any values set with the set functions is not
    ///  written back with KCModuleInfo it only reads value from the desktop file.
    ///  </remarks>        <author> Daniel Molkentin <molkentin@kde.org>
    /// </author>
    ///         <short>    A class that provides information about a KCModule </short>
    [SmokeClass("KCModuleInfo")]
    public class KCModuleInfo : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KCModuleInfo(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KCModuleInfo), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KCModuleInfo() {
            staticInterceptor = new SmokeInvocation(typeof(KCModuleInfo), null);
        }
        /// <remarks>
        ///  Constructs a KCModuleInfo.
        ///  @note a KCModuleInfo object will have to be manually deleted, it is not
        ///  done automatically for you.
        /// <param> name="desktopFile" the desktop file representing the module, or
        ///  the name of the module.
        ///    </param></remarks>        <short>    Constructs a KCModuleInfo.</short>
        public KCModuleInfo(string desktopFile) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCModuleInfo$", "KCModuleInfo(const QString&)", typeof(void), typeof(string), desktopFile);
        }
        /// <remarks>
        ///  Same as above but takes a KService.Ptr as argument.
        ///  @note <code>moduleInfo</code> must be a valid pointer.
        /// <param> name="moduleInfo" specifies the module
        ///    </param></remarks>        <short>    Same as above but takes a KService.Ptr as argument.</short>
        public KCModuleInfo(KService moduleInfo) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCModuleInfo?", "KCModuleInfo(KSharedPtr<KService>)", typeof(void), typeof(KService), moduleInfo);
        }
        /// <remarks>
        ///  Same as above but takes a KCModuleInfo as argument.
        /// <param> name="rhs" specifies the module
        ///    </param></remarks>        <short>    Same as above but takes a KCModuleInfo as argument.</short>
        public KCModuleInfo(KCModuleInfo rhs) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCModuleInfo#", "KCModuleInfo(const KCModuleInfo&)", typeof(void), typeof(KCModuleInfo), rhs);
        }
        /// <remarks>
        ///  Same as above but creates an empty KCModuleInfo.
        ///  You should not normally call this.
        ///    </remarks>        <short>    Same as above but creates an empty KCModuleInfo.</short>
        public KCModuleInfo() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCModuleInfo", "KCModuleInfo()", typeof(void));
        }
        /// <remarks>
        ///  Returns true if <code>rhs</code> describes the same KCModule as this object.
        ///      </remarks>        <short>    Returns true if <code>rhs</code> describes the same KCModule as this object.</short>
        public override bool Equals(object o) {
            if (!(o is KCModuleInfo)) { return false; }
            return this == (KCModuleInfo) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        /// <remarks>
        /// </remarks>        <return> the filename of the .desktop file that describes the KCM
        ///    </return>
        ///         <short>   </short>
        public string FileName() {
            return (string) interceptor.Invoke("fileName", "fileName() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> the keywords associated with this KCM.
        ///    </return>
        ///         <short>   </short>
        public List<string> Keywords() {
            return (List<string>) interceptor.Invoke("keywords", "keywords() const", typeof(List<string>));
        }
        /// <remarks>
        /// </remarks>        <return> the module\'s (translated) name
        ///    </return>
        ///         <short>   </short>
        public string ModuleName() {
            return (string) interceptor.Invoke("moduleName", "moduleName() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> a KSharedPtr to KService created from the modules .desktop file
        ///    </return>
        ///         <short>   </short>
        public KService Service() {
            return (KService) interceptor.Invoke("service", "service() const", typeof(KService));
        }
        /// <remarks>
        /// </remarks>        <return> the module's (translated) comment field
        ///    </return>
        ///         <short>   </short>
        public string Comment() {
            return (string) interceptor.Invoke("comment", "comment() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> the module's icon name
        ///    </return>
        ///         <short>   </short>
        public string Icon() {
            return (string) interceptor.Invoke("icon", "icon() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> the path of the module's documentation
        ///    </return>
        ///         <short>   </short>
        public string DocPath() {
            return (string) interceptor.Invoke("docPath", "docPath() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> the library name
        ///    </return>
        ///         <short>   </short>
        public string Library() {
            return (string) interceptor.Invoke("library", "library() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> the weight of the module which determines the order of the pages in
        ///  the KCMultiDialog. It's set by the X-KDE-Weight field.
        ///    </return>
        ///         <short>   </short>
        public int Weight() {
            return (int) interceptor.Invoke("weight", "weight() const", typeof(int));
        }
        ~KCModuleInfo() {
            interceptor.Invoke("~KCModuleInfo", "~KCModuleInfo()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KCModuleInfo", "~KCModuleInfo()", typeof(void));
        }
        public static bool operator==(KCModuleInfo lhs, KCModuleInfo rhs) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KCModuleInfo&) const", typeof(bool), typeof(KCModuleInfo), lhs, typeof(KCModuleInfo), rhs);
        }
        public static bool operator!=(KCModuleInfo lhs, KCModuleInfo rhs) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KCModuleInfo&) const", typeof(bool), typeof(KCModuleInfo), lhs, typeof(KCModuleInfo), rhs);
        }
    }
}
