//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///   Action for selecting one of several items.
    ///   This action shows up a submenu with a list of items.
    ///   One of them can be checked. If the user clicks on an item
    ///   this item will automatically be checked,
    ///   the formerly checked item becomes unchecked.
    ///   There can be only one item checked at a time.
    ///   See <see cref="IKSelectActionSignals"></see> for signals emitted by KSelectAction
    /// </remarks>        <short> Action for selecting one of several items.</short>
    [SmokeClass("KSelectAction")]
    public class KSelectAction : KAction, IDisposable {
        protected KSelectAction(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KSelectAction), this);
        }
        public enum ToolBarMode {
            MenuMode = 0,
            ComboBoxMode = 1,
        }
        [Q_PROPERTY("QAction*", "currentAction")]
        public QAction CurrentAction {
            get { return (QAction) interceptor.Invoke("currentAction", "currentAction()", typeof(QAction)); }
            set { interceptor.Invoke("setCurrentAction#", "setCurrentAction(QAction*)", typeof(void), typeof(QAction), value); }
        }
        [Q_PROPERTY("bool", "editable")]
        public bool Editable {
            get { return (bool) interceptor.Invoke("isEditable", "isEditable()", typeof(bool)); }
            set { interceptor.Invoke("setEditable$", "setEditable(bool)", typeof(void), typeof(bool), value); }
        }
        [Q_PROPERTY("int", "comboWidth")]
        public int ComboWidth {
            get { return (int) interceptor.Invoke("comboWidth", "comboWidth()", typeof(int)); }
            set { interceptor.Invoke("setComboWidth$", "setComboWidth(int)", typeof(void), typeof(int), value); }
        }
        [Q_PROPERTY("QString", "currentText")]
        public string CurrentText {
            get { return (string) interceptor.Invoke("currentText", "currentText()", typeof(string)); }
        }
        [Q_PROPERTY("KSelectAction::ToolBarMode", "toolBarMode")]
        public KSelectAction.ToolBarMode toolBarMode {
            get { return (KSelectAction.ToolBarMode) interceptor.Invoke("toolBarMode", "toolBarMode()", typeof(KSelectAction.ToolBarMode)); }
            set { interceptor.Invoke("setToolBarMode$", "setToolBarMode(KSelectAction::ToolBarMode)", typeof(void), typeof(KSelectAction.ToolBarMode), value); }
        }
        [Q_PROPERTY("QToolButton::ToolButtonPopupMode", "toolButtonPopupMode")]
        public QToolButton.ToolButtonPopupMode ToolButtonPopupMode {
            get { return (QToolButton.ToolButtonPopupMode) interceptor.Invoke("toolButtonPopupMode", "toolButtonPopupMode()", typeof(QToolButton.ToolButtonPopupMode)); }
            set { interceptor.Invoke("setToolButtonPopupMode$", "setToolButtonPopupMode(QToolButton::ToolButtonPopupMode)", typeof(void), typeof(QToolButton.ToolButtonPopupMode), value); }
        }
        [Q_PROPERTY("int", "currentItem")]
        public int CurrentItem {
            get { return (int) interceptor.Invoke("currentItem", "currentItem()", typeof(int)); }
            set { interceptor.Invoke("setCurrentItem$", "setCurrentItem(int)", typeof(void), typeof(int), value); }
        }
        [Q_PROPERTY("QStringList", "items")]
        public List<string> Items {
            get { return (List<string>) interceptor.Invoke("items", "items()", typeof(List<string>)); }
            set { interceptor.Invoke("setItems?", "setItems(QStringList)", typeof(void), typeof(List<string>), value); }
        }
        // KSelectAction* KSelectAction(KSelectActionPrivate& arg1,QObject* arg2); >>>> NOT CONVERTED
        /// <remarks>
        ///  Constructs a selection action with the specified parent.
        /// <param> name="parent" The action's parent object.
        ///      </param></remarks>        <short>    Constructs a selection action with the specified parent.</short>
        public KSelectAction(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KSelectAction#", "KSelectAction(QObject*)", typeof(void), typeof(QObject), parent);
        }
        /// <remarks>
        ///  Constructs a selection action with text; a shortcut may be specified by
        ///  the ampersand character (e.g. "&amp;Option" creates a shortcut with key \e O )
        ///  This is the most common KSelectAction used when you do not have a
        ///  corresponding icon (note that it won't appear in the current version
        ///  of the "Edit ToolBar" dialog, because an action needs an icon to be
        ///  plugged in a toolbar...).
        /// <param> name="text" The text that will be displayed.
        /// </param><param> name="parent" The action's parent object.
        ///      </param></remarks>        <short>    Constructs a selection action with text; a shortcut may be specified by  the ampersand character (e.</short>
        public KSelectAction(string text, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KSelectAction$#", "KSelectAction(const QString&, QObject*)", typeof(void), typeof(string), text, typeof(QObject), parent);
        }
        /// <remarks>
        ///  Constructs a selection action with text and an icon; a shortcut may be specified by
        ///  the ampersand character (e.g. "&amp;Option" creates a shortcut with key \e O )
        ///  This is the other common KSelectAction used.  Use it when you
        ///  \e do have a corresponding icon.
        /// <param> name="icon" The icon to display.
        /// </param><param> name="text" The text that will be displayed.
        /// </param><param> name="parent" The action's parent object.
        ///      </param></remarks>        <short>    Constructs a selection action with text and an icon; a shortcut may be specified by  the ampersand character (e.</short>
        public KSelectAction(KIcon icon, string text, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KSelectAction#$#", "KSelectAction(const KIcon&, const QString&, QObject*)", typeof(void), typeof(KIcon), icon, typeof(string), text, typeof(QObject), parent);
        }
        /// <remarks>
        ///  The action group used to create exclusivity between the actions associated with this action.
        ///      </remarks>        <short>    The action group used to create exclusivity between the actions associated with this action.</short>
        public QActionGroup SelectableActionGroup() {
            return (QActionGroup) interceptor.Invoke("selectableActionGroup", "selectableActionGroup() const", typeof(QActionGroup));
        }
        /// <remarks>
        ///  Returns the list of selectable actions
        ///      </remarks>        <short>    Returns the list of selectable actions      </short>
        public List<QAction> Actions() {
            return (List<QAction>) interceptor.Invoke("actions", "actions() const", typeof(List<QAction>));
        }
        /// <remarks>
        ///  Returns the action at \a index, if one exists.
        ///      </remarks>        <short>    Returns the action at \a index, if one exists.</short>
        public QAction Action(int index) {
            return (QAction) interceptor.Invoke("action$", "action(int) const", typeof(QAction), typeof(int), index);
        }
        /// <remarks>
        ///  Searches for an action with the specified \a text, using a search whose
        ///  case sensitivity is defined by \a cs.
        ///      </remarks>        <short>    Searches for an action with the specified \a text, using a search whose  case sensitivity is defined by \a cs.</short>
        public QAction Action(string text, Qt.CaseSensitivity cs) {
            return (QAction) interceptor.Invoke("action$$", "action(const QString&, Qt::CaseSensitivity) const", typeof(QAction), typeof(string), text, typeof(Qt.CaseSensitivity), cs);
        }
        public QAction Action(string text) {
            return (QAction) interceptor.Invoke("action$", "action(const QString&) const", typeof(QAction), typeof(string), text);
        }
        /// <remarks>
        ///  \overload setCurrentAction(QAction)
        ///  Convenience function to set the currently checked action to be the action
        ///  which has <pre>text</pre> as its text().
        ///  If there is no action at that index, the currently checked action (if any) will
        ///  be deselected.
        ///  \return \e true if a corresponding action was found, otherwise \e false
        ///      </remarks>        <short>    \overload setCurrentAction(QAction ) </short>
        public bool SetCurrentAction(string text, Qt.CaseSensitivity cs) {
            return (bool) interceptor.Invoke("setCurrentAction$$", "setCurrentAction(const QString&, Qt::CaseSensitivity)", typeof(bool), typeof(string), text, typeof(Qt.CaseSensitivity), cs);
        }
        public bool SetCurrentAction(string text) {
            return (bool) interceptor.Invoke("setCurrentAction$", "setCurrentAction(const QString&)", typeof(bool), typeof(string), text);
        }
        /// <remarks>
        ///  Add \a action to the list of selectable actions.
        ///      </remarks>        <short>    Add \a action to the list of selectable actions.</short>
        [SmokeMethod("addAction(QAction*)")]
        public virtual void AddAction(QAction action) {
            interceptor.Invoke("addAction#", "addAction(QAction*)", typeof(void), typeof(QAction), action);
        }
        /// <remarks>
        ///  \overload addAction(QAction action)
        ///  Convenience function which creates an action from \a text and inserts it into
        ///  the list of selectable actions.
        ///  The newly created action is checkable and not user configurable.
        ///      </remarks>        <short>    \overload addAction(QAction  action) </short>
        public KAction AddAction(string text) {
            return (KAction) interceptor.Invoke("addAction$", "addAction(const QString&)", typeof(KAction), typeof(string), text);
        }
        /// <remarks>
        ///  \overload addAction(QAction action)
        ///  Convenience function which creates an action from \a text and \a icon and inserts it into
        ///  the list of selectable actions.
        ///  The newly created action is checkable and not user configurable.
        ///      </remarks>        <short>    \overload addAction(QAction  action) </short>
        public KAction AddAction(KIcon icon, string text) {
            return (KAction) interceptor.Invoke("addAction#$", "addAction(const KIcon&, const QString&)", typeof(KAction), typeof(KIcon), icon, typeof(string), text);
        }
        /// <remarks>
        ///  Remove the specified \a action from this action selector.
        ///  You take ownership here, so save or delete it in order to not leak the action.
        ///      </remarks>        <short>    Remove the specified \a action from this action selector.</short>
        [SmokeMethod("removeAction(QAction*)")]
        public virtual QAction RemoveAction(QAction action) {
            return (QAction) interceptor.Invoke("removeAction#", "removeAction(QAction*)", typeof(QAction), typeof(QAction), action);
        }
        /// <remarks>
        ///  Sets the maximum items that are visible at once if the action
        ///  is a combobox, that is the number of items in the combobox's viewport
        ///      </remarks>        <short>    Sets the maximum items that are visible at once if the action  is a combobox, that is the number of items in the combobox's viewport      </short>
        public void SetMaxComboViewCount(int n) {
            interceptor.Invoke("setMaxComboViewCount$", "setMaxComboViewCount(int)", typeof(void), typeof(int), n);
        }
        /// <remarks>
        ///  Clears up all the items in this action.
        ///  \warning The actions will be deleted for backwards compatibility with KDE3.
        ///           If you just want to remove all actions, use removeAllActions()
        ///      </remarks>        <short>    Clears up all the items in this action.</short>
        public void Clear() {
            interceptor.Invoke("clear", "clear()", typeof(void));
        }
        public void RemoveAllActions() {
            interceptor.Invoke("removeAllActions", "removeAllActions()", typeof(void));
        }
        /// <remarks>
        ///  Sets whether any occurrence of the ampersand character ( &amp; ) in items
        ///  should be interpreted as keyboard accelerator for items displayed in a
        ///  menu or not.  Only applies to (overloaded) methods dealing with strings,
        ///  not those dealing with QActions.
        ///  Defaults to true.
        ///  \param b true if ampersands indicate a keyboard accelerator, otherwise false.
        ///      </remarks>        <short>    Sets whether any occurrence of the ampersand character ( &amp; ) in items  should be interpreted as keyboard accelerator for items displayed in a  menu or not.</short>
        public void SetMenuAccelsEnabled(bool b) {
            interceptor.Invoke("setMenuAccelsEnabled$", "setMenuAccelsEnabled(bool)", typeof(void), typeof(bool), b);
        }
        /// <remarks>
        ///  Returns whether ampersands passed to methods using strings are interpreted
        ///  as keyboard accelerator indicators or as literal ampersands.
        ///      </remarks>        <short>    Returns whether ampersands passed to methods using strings are interpreted  as keyboard accelerator indicators or as literal ampersands.</short>
        public bool MenuAccelsEnabled() {
            return (bool) interceptor.Invoke("menuAccelsEnabled", "menuAccelsEnabled() const", typeof(bool));
        }
        /// <remarks>
        ///  Changes the text of item @param index to @param text .
        ///      </remarks>        <short>    Changes the text of item @param index to @param text .</short>
        public void ChangeItem(int index, string text) {
            interceptor.Invoke("changeItem$$", "changeItem(int, const QString&)", typeof(void), typeof(int), index, typeof(string), text);
        }
        /// <remarks>
        ///  Reimplemented from @see QWidgetAction.
        ///      </remarks>        <short>    Reimplemented from @see QWidgetAction.</short>
        [SmokeMethod("createWidget(QWidget*)")]
        protected override QWidget CreateWidget(QWidget parent) {
            return (QWidget) interceptor.Invoke("createWidget#", "createWidget(QWidget*)", typeof(QWidget), typeof(QWidget), parent);
        }
        /// <remarks>
        ///  Reimplemented from @see QWidgetAction.
        ///      </remarks>        <short>    Reimplemented from @see QWidgetAction.</short>
        [SmokeMethod("deleteWidget(QWidget*)")]
        protected override void DeleteWidget(QWidget widget) {
            interceptor.Invoke("deleteWidget#", "deleteWidget(QWidget*)", typeof(void), typeof(QWidget), widget);
        }
        [SmokeMethod("eventFilter(QObject*, QEvent*)")]
        protected override bool EventFilter(QObject watched, QEvent arg2) {
            return (bool) interceptor.Invoke("eventFilter##", "eventFilter(QObject*, QEvent*)", typeof(bool), typeof(QObject), watched, typeof(QEvent), arg2);
        }
        /// <remarks>
        ///  Creates a new KSelectAction object.
        /// <param> name="dd" the private d member
        /// </param><param> name="parent" The action's parent object.
        ///      </param></remarks>        <short>   </short>
        /// <remarks>
        ///  This function is called whenever an action from the selections is triggered.
        ///      </remarks>        <short>    This function is called whenever an action from the selections is triggered.</short>
        [Q_SLOT("void actionTriggered(QAction*)")]
        [SmokeMethod("actionTriggered(QAction*)")]
        protected virtual void ActionTriggered(QAction action) {
            interceptor.Invoke("actionTriggered#", "actionTriggered(QAction*)", typeof(void), typeof(QAction), action);
        }
        /// <remarks>
        ///  For structured menu building. Deselects all items if the action was unchecked by the top menu
        ///      </remarks>        <short>    For structured menu building.</short>
        [Q_SLOT("void slotToggled(bool)")]
        protected void SlotToggled(bool arg1) {
            interceptor.Invoke("slotToggled$", "slotToggled(bool)", typeof(void), typeof(bool), arg1);
        }
        ~KSelectAction() {
            interceptor.Invoke("~KSelectAction", "~KSelectAction()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KSelectAction", "~KSelectAction()", typeof(void));
        }
        protected new IKSelectActionSignals Emit {
            get { return (IKSelectActionSignals) Q_EMIT; }
        }
    }

    public interface IKSelectActionSignals : IKActionSignals {
        /// <remarks>
        ///  This signal is emitted when an item is selected; @param action 
        ///  indicates the item selected.
        ///      </remarks>        <short>    This signal is emitted when an item is selected; @param action   indicates the item selected.</short>
        [Q_SIGNAL("void triggered(QAction*)")]
        void Triggered(QAction action);
        /// <remarks>
        ///  This signal is emitted when an item is selected; @param index indicates
        ///  the item selected.
        ///      </remarks>        <short>    This signal is emitted when an item is selected; @param index indicates  the item selected.</short>
        [Q_SIGNAL("void triggered(int)")]
        void Triggered(int index);
        /// <remarks>
        ///  This signal is emitted when an item is selected; @param text indicates
        ///  the item selected.
        ///      </remarks>        <short>    This signal is emitted when an item is selected; @param text indicates  the item selected.</short>
        [Q_SIGNAL("void triggered(QString)")]
        void Triggered(string text);
    }
}
