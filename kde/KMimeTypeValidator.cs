//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Runtime.InteropServices;
    using System.Text;
    /// <remarks>
    ///  This validator allows you to validate mimetype names
    ///  (e.g. text/plain, image/jpeg). Note that the validation is only
    ///  syntactically. It will e.g. not reject "foo/bar", although that
    ///  particular mime type isn't yet registered. It suffices for the name
    ///  to adhere to the production
    ///  <pre>
    ///  mime-type := token "/" token ; 'token' is defined in rfc2045
    ///  </pre>
    ///  The fixup will simply remove all non-token characters.
    /// </remarks>        <author> Marc Mutz <mutz@kde.org>
    /// </author>
    ///         <short> A QValidator for mime types. </short>
    [SmokeClass("KMimeTypeValidator")]
    public class KMimeTypeValidator : QValidator, IDisposable {
        protected KMimeTypeValidator(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KMimeTypeValidator), this);
        }
        /// <remarks>
        ///  Creates a new mime type validator.
        ///      </remarks>        <short>    Creates a new mime type validator.</short>
        public KMimeTypeValidator(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KMimeTypeValidator#", "KMimeTypeValidator(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public KMimeTypeValidator() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KMimeTypeValidator", "KMimeTypeValidator()", typeof(void));
        }
        /// <remarks>
        ///  Checks for well-formed mimetype. Returns
        /// 
        /// <li>
        /// Acceptable iff input ~= /^[:allowed chars:]+\/[:allowed chars:]+$/
        /// </li>
        /// 
        /// <li>
        /// Intermediate iff input ~= /^[:allowed chars:]\/?[:allowed chars:]$/
        /// </li>
        /// 
        /// <li>
        /// Invalid else
        ///      
        /// </li></remarks>        <short>    Checks for well-formed mimetype.</short>
        [SmokeMethod("validate(QString&, int&) const")]
        public override QValidator.State Validate(StringBuilder input, ref int pos) {
            StackItem[] stack = new StackItem[3];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(input);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(input);
#endif
            stack[2].s_int = pos;
            interceptor.Invoke("validate$$", "validate(QString&, int&) const", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
            pos = stack[2].s_int;
            return (QValidator.State) Enum.ToObject(typeof(QValidator.State), stack[0].s_int);
        }
        /// <remarks>
        ///  Removes all characters that are forbidden in mimetypes.
        ///      </remarks>        <short>    Removes all characters that are forbidden in mimetypes.</short>
        [SmokeMethod("fixup(QString&) const")]
        public override void Fixup(StringBuilder input) {
            interceptor.Invoke("fixup$", "fixup(QString&) const", typeof(void), typeof(StringBuilder), input);
        }
        ~KMimeTypeValidator() {
            interceptor.Invoke("~KMimeTypeValidator", "~KMimeTypeValidator()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KMimeTypeValidator", "~KMimeTypeValidator()", typeof(void));
        }
        protected new IKMimeTypeValidatorSignals Emit {
            get { return (IKMimeTypeValidatorSignals) Q_EMIT; }
        }
    }

    public interface IKMimeTypeValidatorSignals : IQValidatorSignals {
    }
}
