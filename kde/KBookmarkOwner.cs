//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  The KBookmarkMenu and KBookmarkBar classes gives the user
    ///  the ability to either edit bookmarks or add their own.  In the
    ///  first case, the app may want to open the bookmark in a special way.
    ///  In the second case, the app <em>must</em> supply the name and the
    ///  URL for the bookmark.
    ///  This class gives the app this callback-like ability.
    ///  If your app does not give the user the ability to add bookmarks and
    ///  you don't mind using the default bookmark editor to edit your
    ///  bookmarks, then you don't need to overload this class at all.
    ///  Rather, just use something like:
    ///  <CODE>
    ///  bookmarks = new KBookmarkMenu( mgr, 0, menu, actioncollec  )
    ///  </CODE>
    ///  If you wish to use your own editor or allow the user to add
    ///  bookmarks, you must overload this class.
    ///  </remarks>        <short>    The KBookmarkMenu and KBookmarkBar classes gives the user  the ability to either edit bookmarks or add their own.</short>
    [SmokeClass("KBookmarkOwner")]
    public abstract class KBookmarkOwner : Object {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KBookmarkOwner(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KBookmarkOwner), this);
        }
        public enum BookmarkOption {
            ShowAddBookmark = 0,
            ShowEditBookmark = 1,
        }
        // KBookmarkDialog* bookmarkDialog(KBookmarkManager* arg1,QWidget* arg2); >>>> NOT CONVERTED
        /// <remarks>
        ///  This function is called whenever the user wants to add the
        ///  current page to the bookmarks list.  The title will become the
        ///  "name" of the bookmark.  You must overload this function if you
        ///  wish to give your users the ability to add bookmarks.
        /// </remarks>        <return> the title of the current page.
        ///    </return>
        ///         <short>    This function is called whenever the user wants to add the  current page to the bookmarks list.</short>
        [SmokeMethod("currentTitle() const")]
        public virtual string CurrentTitle() {
            return (string) interceptor.Invoke("currentTitle", "currentTitle() const", typeof(string));
        }
        /// <remarks>
        ///  This function is called whenever the user wants to add the
        ///  current page to the bookmarks list.  The URL will become the URL
        ///  of the bookmark.  You must overload this function if you wish to
        ///  give your users the ability to add bookmarks.
        /// </remarks>        <return> the URL of the current page.
        ///    </return>
        ///         <short>    This function is called whenever the user wants to add the  current page to the bookmarks list.</short>
        [SmokeMethod("currentUrl() const")]
        public virtual string CurrentUrl() {
            return (string) interceptor.Invoke("currentUrl", "currentUrl() const", typeof(string));
        }
        /// <remarks>
        ///  This function returns whether the owner supports tabs.
        ///    </remarks>        <short>    This function returns whether the owner supports tabs.</short>
        [SmokeMethod("supportsTabs() const")]
        public virtual bool SupportsTabs() {
            return (bool) interceptor.Invoke("supportsTabs", "supportsTabs() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns a list of title, URL pairs of the open tabs.
        ///    </remarks>        <short>    Returns a list of title, URL pairs of the open tabs.</short>
        [SmokeMethod("currentBookmarkList() const")]
        public virtual List<QPair<string, string>> CurrentBookmarkList() {
            return (List<QPair<string, string>>) interceptor.Invoke("currentBookmarkList", "currentBookmarkList() const", typeof(List<QPair<string, string>>));
        }
        /// <remarks> Returns true if <pre>action</pre> should be shown in the menu
        ///   The default is to show both a add and editBookmark Entry
        ///   //TODO ContextMenuAction? to disable the contextMenu?
        ///          Delete and Propeties to disable those in the
        ///          context menu?
        ///    </remarks>        <short>   Returns true if \p action should be shown in the menu   The default is to show both a add and editBookmark Entry   //TODO ContextMenuAction? to disable the contextMenu?          Delete and Propeties to disable those in the          context menu?    </short>
        [SmokeMethod("enableOption(KBookmarkOwner::BookmarkOption) const")]
        public virtual bool EnableOption(KBookmarkOwner.BookmarkOption option) {
            return (bool) interceptor.Invoke("enableOption$", "enableOption(KBookmarkOwner::BookmarkOption) const", typeof(bool), typeof(KBookmarkOwner.BookmarkOption), option);
        }
        /// <remarks>
        ///  Called if a bookmark is selected. You need to override this.
        ///    </remarks>        <short>    Called if a bookmark is selected.</short>
        [SmokeMethod("openBookmark(const KBookmark&, Qt::MouseButtons, Qt::KeyboardModifiers)")]
        public abstract void OpenBookmark(KBookmark bm, uint mb, uint km);
        /// <remarks>
        ///  Called if the user wants to open every bookmark in this folder in a new tab.
        ///  The default implementation does nothing.
        ///  This is only called if supportsTabs() returns true
        ///   </remarks>        <short>    Called if the user wants to open every bookmark in this folder in a new tab.</short>
        [SmokeMethod("openFolderinTabs(const KBookmarkGroup&)")]
        public virtual void OpenFolderinTabs(KBookmarkGroup bm) {
            interceptor.Invoke("openFolderinTabs#", "openFolderinTabs(const KBookmarkGroup&)", typeof(void), typeof(KBookmarkGroup), bm);
        }
        public KBookmarkOwner() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KBookmarkOwner", "KBookmarkOwner()", typeof(void));
        }
    }
}
