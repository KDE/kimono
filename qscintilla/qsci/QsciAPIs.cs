//Auto-generated by kalyptus. DO NOT EDIT.
namespace QScintilla {

	using System;
	using Qyoto;
	using System.Runtime.InteropServices;
	using System.Collections.Generic;

	/// <remarks> See <see cref="IQsciAPIsSignals"></see> for signals emitted by QsciAPIs
	/// </remarks>

	[SmokeClass("QsciAPIs")]
	public class QsciAPIs : QObject, IDisposable {
 		protected QsciAPIs(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(QsciAPIs), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static QsciAPIs() {
			staticInterceptor = new SmokeInvocation(typeof(QsciAPIs), null);
		}
		public QsciAPIs(QsciLexer lexer) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QsciAPIs#", "QsciAPIs(QsciLexer*)", typeof(void), typeof(QsciLexer), lexer);
		}
		public void Add(string entry) {
			interceptor.Invoke("add$", "add(const QString&)", typeof(void), typeof(string), entry);
		}
		public void Clear() {
			interceptor.Invoke("clear", "clear()", typeof(void));
		}
		public bool Load(string fname) {
			return (bool) interceptor.Invoke("load$", "load(const QString&)", typeof(bool), typeof(string), fname);
		}
		public void Remove(string entry) {
			interceptor.Invoke("remove$", "remove(const QString&)", typeof(void), typeof(string), entry);
		}
		public void Prepare() {
			interceptor.Invoke("prepare", "prepare()", typeof(void));
		}
		public void CancelPreparation() {
			interceptor.Invoke("cancelPreparation", "cancelPreparation()", typeof(void));
		}
		public string DefaultPreparedName() {
			return (string) interceptor.Invoke("defaultPreparedName", "defaultPreparedName() const", typeof(string));
		}
		public bool IsPrepared(string fname) {
			return (bool) interceptor.Invoke("isPrepared$", "isPrepared(const QString&) const", typeof(bool), typeof(string), fname);
		}
		public bool IsPrepared() {
			return (bool) interceptor.Invoke("isPrepared", "isPrepared() const", typeof(bool));
		}
		public bool LoadPrepared(string fname) {
			return (bool) interceptor.Invoke("loadPrepared$", "loadPrepared(const QString&)", typeof(bool), typeof(string), fname);
		}
		public bool LoadPrepared() {
			return (bool) interceptor.Invoke("loadPrepared", "loadPrepared()", typeof(bool));
		}
		public bool SavePrepared(string fname) {
			return (bool) interceptor.Invoke("savePrepared$", "savePrepared(const QString&) const", typeof(bool), typeof(string), fname);
		}
		public bool SavePrepared() {
			return (bool) interceptor.Invoke("savePrepared", "savePrepared() const", typeof(bool));
		}
		public void AutoCompletionList(List<string> context, List<string> wlist) {
			interceptor.Invoke("autoCompletionList??", "autoCompletionList(const QStringList&, QStringList&)", typeof(void), typeof(List<string>), context, typeof(List<string>), wlist);
		}
		public void AutoCompletionSelected(string sel) {
			interceptor.Invoke("autoCompletionSelected$", "autoCompletionSelected(const QString&)", typeof(void), typeof(string), sel);
		}
		public string CallTips(List<string> context, QsciScintilla.CallTipsStyle style, int maxnr, int commas, ref int ctshift) {
			StackItem[] stack = new StackItem[6];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(context);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(context);
#endif
			stack[2].s_int = (int) style;
			stack[3].s_int = maxnr;
			stack[4].s_int = commas;
			stack[5].s_int = ctshift;
			interceptor.Invoke("callTips?$$$$", "callTips(const QStringList&, QsciScintilla::CallTipsStyle, int, int, int&)", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
			ctshift = stack[5].s_int;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).SynchronizedFree();
#endif
			return (string) returnValue;
		}
		public string CallTipsNextPrev(int dir, ref int ctshift) {
			StackItem[] stack = new StackItem[3];
			stack[1].s_int = dir;
			stack[2].s_int = ctshift;
			interceptor.Invoke("callTipsNextPrev$$", "callTipsNextPrev(int, int&)", stack);
			ctshift = stack[2].s_int;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).SynchronizedFree();
#endif
			return (string) returnValue;
		}
		[SmokeMethod("event(QEvent*)")]
		public override bool Event(QEvent e) {
			return (bool) interceptor.Invoke("event#", "event(QEvent*)", typeof(bool), typeof(QEvent), e);
		}
		public List<string> InstalledAPIFiles() {
			return (List<string>) interceptor.Invoke("installedAPIFiles", "installedAPIFiles() const", typeof(List<string>));
		}
		~QsciAPIs() {
			interceptor.Invoke("~QsciAPIs", "~QsciAPIs()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~QsciAPIs", "~QsciAPIs()", typeof(void));
		}
		public static new string Tr(string s, string c) {
			return (string) staticInterceptor.Invoke("tr$$", "tr(const char*, const char*)", typeof(string), typeof(string), s, typeof(string), c);
		}
		public static new string Tr(string s) {
			return (string) staticInterceptor.Invoke("tr$", "tr(const char*)", typeof(string), typeof(string), s);
		}
		protected new IQsciAPIsSignals Emit {
			get { return (IQsciAPIsSignals) Q_EMIT; }
		}
	}

	public interface IQsciAPIsSignals : IQObjectSignals {
		[Q_SIGNAL("void apiPreparationCancelled()")]
		void ApiPreparationCancelled();
		[Q_SIGNAL("void apiPreparationStarted()")]
		void ApiPreparationStarted();
		[Q_SIGNAL("void apiPreparationFinished()")]
		void ApiPreparationFinished();
	}
}
