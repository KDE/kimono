//Auto-generated by kalyptus. DO NOT EDIT.
namespace Sonnet {
    using Kimono;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  Spell checker object.
    /// </remarks>        <short> class used for actuall spell checking.</short>
    [SmokeClass("Sonnet::Speller")]
    public class Speller : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected Speller(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Speller), this);
        }
        public enum Attribute {
            CheckUppercase = 0,
            SkipRunTogether = 1,
        }
        public Speller(string lang) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Speller$", "Speller(const QString&)", typeof(void), typeof(string), lang);
        }
        public Speller() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Speller", "Speller()", typeof(void));
        }
        public Speller(Sonnet.Speller speller) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Speller#", "Speller(const Sonnet::Speller&)", typeof(void), typeof(Sonnet.Speller), speller);
        }
        /// <remarks>
        ///  Returns true is the speller supports currently selected
        ///  language.
        ///          </remarks>        <short>    Returns true is the speller supports currently selected  language.</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        ///  Sets the language supported by this speller.
        ///          </remarks>        <short>    Sets the language supported by this speller.</short>
        public void SetLanguage(string lang) {
            interceptor.Invoke("setLanguage$", "setLanguage(const QString&)", typeof(void), typeof(string), lang);
        }
        /// <remarks>
        ///  Returns language supported by this speller.
        ///          </remarks>        <short>    Returns language supported by this speller.</short>
        public string Language() {
            return (string) interceptor.Invoke("language", "language() const", typeof(string));
        }
        /// <remarks>
        ///  Checks the given word.
        /// </remarks>        <return> false if the word is misspelled. true otherwise
        ///          </return>
        ///         <short>    Checks the given word.</short>
        public bool IsCorrect(string word) {
            return (bool) interceptor.Invoke("isCorrect$", "isCorrect(const QString&) const", typeof(bool), typeof(string), word);
        }
        /// <remarks>
        ///  Checks the given word.
        /// </remarks>        <return> true if the word is misspelled. false otherwise
        ///          </return>
        ///         <short>    Checks the given word.</short>
        public bool IsMisspelled(string word) {
            return (bool) interceptor.Invoke("isMisspelled$", "isMisspelled(const QString&) const", typeof(bool), typeof(string), word);
        }
        /// <remarks>
        ///  Fetches suggestions for the word.
        /// </remarks>        <return> list of all suggestions for the word
        ///          </return>
        ///         <short>    Fetches suggestions for the word.</short>
        public List<string> Suggest(string word) {
            return (List<string>) interceptor.Invoke("suggest$", "suggest(const QString&) const", typeof(List<string>), typeof(string), word);
        }
        /// <remarks>
        ///  Convience method calling isCorrect() and suggest()
        ///  if the word isn't correct.
        ///          </remarks>        <short>    Convience method calling isCorrect() and suggest()  if the word isn't correct.</short>
        public bool CheckAndSuggest(string word, List<string> suggestions) {
            return (bool) interceptor.Invoke("checkAndSuggest$?", "checkAndSuggest(const QString&, QStringList&) const", typeof(bool), typeof(string), word, typeof(List<string>), suggestions);
        }
        /// <remarks>
        ///  Stores user defined good replacement for the bad word.
        /// </remarks>        <return> true on success
        ///          </return>
        ///         <short>    Stores user defined good replacement for the bad word.</short>
        public bool StoreReplacement(string bad, string good) {
            return (bool) interceptor.Invoke("storeReplacement$$", "storeReplacement(const QString&, const QString&)", typeof(bool), typeof(string), bad, typeof(string), good);
        }
        /// <remarks>
        ///  Adds word to the list of of personal words.
        /// </remarks>        <return> true on success
        ///          </return>
        ///         <short>    Adds word to the list of of personal words.</short>
        public bool AddToPersonal(string word) {
            return (bool) interceptor.Invoke("addToPersonal$", "addToPersonal(const QString&)", typeof(bool), typeof(string), word);
        }
        /// <remarks>
        ///  Adds word to the words recognizable in the current session.
        /// </remarks>        <return> true on success
        ///          </return>
        ///         <short>    Adds word to the words recognizable in the current session.</short>
        public bool AddToSession(string word) {
            return (bool) interceptor.Invoke("addToSession$", "addToSession(const QString&)", typeof(bool), typeof(string), word);
        }
        public void Save(KConfig config) {
            interceptor.Invoke("save#", "save(KConfig*)", typeof(void), typeof(KConfig), config);
        }
        public void Restore(KConfig config) {
            interceptor.Invoke("restore#", "restore(KConfig*)", typeof(void), typeof(KConfig), config);
        }
        /// <remarks>
        ///  Returns names of all supported backends (e.g. ISpell, ASpell)
        ///          </remarks>        <short>    Returns names of all supported backends (e.</short>
        public List<string> AvailableBackends() {
            return (List<string>) interceptor.Invoke("availableBackends", "availableBackends() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Returns a list of supported languages.
        ///          </remarks>        <short>    Returns a list of supported languages.</short>
        public List<string> AvailableLanguages() {
            return (List<string>) interceptor.Invoke("availableLanguages", "availableLanguages() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Returns a localized list of names of supported languages.
        ///          </remarks>        <short>    Returns a localized list of names of supported languages.</short>
        public List<string> AvailableLanguageNames() {
            return (List<string>) interceptor.Invoke("availableLanguageNames", "availableLanguageNames() const", typeof(List<string>));
        }
        public void SetDefaultLanguage(string lang) {
            interceptor.Invoke("setDefaultLanguage$", "setDefaultLanguage(const QString&)", typeof(void), typeof(string), lang);
        }
        public string DefaultLanguage() {
            return (string) interceptor.Invoke("defaultLanguage", "defaultLanguage() const", typeof(string));
        }
        public void SetDefaultClient(string client) {
            interceptor.Invoke("setDefaultClient$", "setDefaultClient(const QString&)", typeof(void), typeof(string), client);
        }
        public string DefaultClient() {
            return (string) interceptor.Invoke("defaultClient", "defaultClient() const", typeof(string));
        }
        public void SetAttribute(Sonnet.Speller.Attribute attr, bool b) {
            interceptor.Invoke("setAttribute$$", "setAttribute(Sonnet::Speller::Attribute, bool)", typeof(void), typeof(Sonnet.Speller.Attribute), attr, typeof(bool), b);
        }
        public void SetAttribute(Sonnet.Speller.Attribute attr) {
            interceptor.Invoke("setAttribute$", "setAttribute(Sonnet::Speller::Attribute)", typeof(void), typeof(Sonnet.Speller.Attribute), attr);
        }
        public bool TestAttribute(Sonnet.Speller.Attribute attr) {
            return (bool) interceptor.Invoke("testAttribute$", "testAttribute(Sonnet::Speller::Attribute) const", typeof(bool), typeof(Sonnet.Speller.Attribute), attr);
        }
        ~Speller() {
            interceptor.Invoke("~Speller", "~Speller()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~Speller", "~Speller()", typeof(void));
        }
    }
}
