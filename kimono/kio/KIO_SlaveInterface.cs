//Auto-generated by kalyptus. DO NOT EDIT.
namespace KIO {
    using Kimono;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  There are two classes that specifies the protocol between application
    ///  ( KIO.Job) and kioslave. SlaveInterface is the class to use on the application
    ///  end, SlaveBase is the one to use on the slave end.
    ///  A call to foo() results in a call to slotFoo() on the other end.
    ///   See <see cref="ISlaveInterfaceSignals"></see> for signals emitted by SlaveInterface
    /// </remarks>        <short>    There are two classes that specifies the protocol between application  ( KIO.Job) and kioslave.</short>
    [SmokeClass("KIO::SlaveInterface")]
    public class SlaveInterface : QObject {
        protected SlaveInterface(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(SlaveInterface), this);
        }
        // KIO::SlaveInterface* SlaveInterface(KIO::SlaveInterfacePrivate& arg1,QObject* arg2); >>>> NOT CONVERTED
        // KIO::SlaveInterface* SlaveInterface(KIO::SlaveInterfacePrivate& arg1); >>>> NOT CONVERTED
        public void SetConnection(KIO.Connection connection) {
            interceptor.Invoke("setConnection#", "setConnection(KIO::Connection*)", typeof(void), typeof(KIO.Connection), connection);
        }
        public KIO.Connection Connection() {
            return (KIO.Connection) interceptor.Invoke("connection", "connection() const", typeof(KIO.Connection));
        }
        public void SendResumeAnswer(bool resume) {
            interceptor.Invoke("sendResumeAnswer$", "sendResumeAnswer(bool)", typeof(void), typeof(bool), resume);
        }
        public void SetOffset(long offset) {
            interceptor.Invoke("setOffset$", "setOffset(KIO::filesize_t)", typeof(void), typeof(long), offset);
        }
        public long Offset() {
            return (long) interceptor.Invoke("offset", "offset() const", typeof(long));
        }
        [SmokeMethod("dispatch()")]
        protected virtual bool Dispatch() {
            return (bool) interceptor.Invoke("dispatch", "dispatch()", typeof(bool));
        }
        [SmokeMethod("dispatch(int, const QByteArray&)")]
        protected virtual bool Dispatch(int _cmd, QByteArray data) {
            return (bool) interceptor.Invoke("dispatch$#", "dispatch(int, const QByteArray&)", typeof(bool), typeof(int), _cmd, typeof(QByteArray), data);
        }
        protected void MessageBox(int type, string text, string caption, string buttonYes, string buttonNo) {
            interceptor.Invoke("messageBox$$$$$", "messageBox(int, const QString&, const QString&, const QString&, const QString&)", typeof(void), typeof(int), type, typeof(string), text, typeof(string), caption, typeof(string), buttonYes, typeof(string), buttonNo);
        }
        protected void MessageBox(int type, string text, string caption, string buttonYes, string buttonNo, string dontAskAgainName) {
            interceptor.Invoke("messageBox$$$$$$", "messageBox(int, const QString&, const QString&, const QString&, const QString&, const QString&)", typeof(void), typeof(int), type, typeof(string), text, typeof(string), caption, typeof(string), buttonYes, typeof(string), buttonNo, typeof(string), dontAskAgainName);
        }
        protected void RequestNetwork(string arg1, string arg2) {
            interceptor.Invoke("requestNetwork$$", "requestNetwork(const QString&, const QString&)", typeof(void), typeof(string), arg1, typeof(string), arg2);
        }
        protected void DropNetwork(string arg1, string arg2) {
            interceptor.Invoke("dropNetwork$$", "dropNetwork(const QString&, const QString&)", typeof(void), typeof(string), arg1, typeof(string), arg2);
        }
        [Q_SLOT("void calcSpeed()")]
        protected void CalcSpeed() {
            interceptor.Invoke("calcSpeed", "calcSpeed()", typeof(void));
        }
        protected new ISlaveInterfaceSignals Emit {
            get { return (ISlaveInterfaceSignals) Q_EMIT; }
        }
    }

    public interface ISlaveInterfaceSignals : IQObjectSignals {
        [Q_SIGNAL("void data(QByteArray)")]
        void Data(QByteArray arg1);
        [Q_SIGNAL("void dataReq()")]
        void DataReq();
        [Q_SIGNAL("void error(int, QString)")]
        void Error(int arg1, string arg2);
        [Q_SIGNAL("void connected()")]
        void Connected();
        [Q_SIGNAL("void finished()")]
        void Finished();
        [Q_SIGNAL("void slaveStatus(pid_t, QByteArray, QString, bool)")]
        void SlaveStatus(int arg1, QByteArray arg2, string arg3, bool arg4);
        [Q_SIGNAL("void listEntries(KIO::UDSEntryList)")]
        void ListEntries(List<KIO.UDSEntry> arg1);
        [Q_SIGNAL("void statEntry(KIO::UDSEntry)")]
        void StatEntry(KIO.UDSEntry arg1);
        [Q_SIGNAL("void needSubUrlData()")]
        void NeedSubUrlData();
        [Q_SIGNAL("void canResume(KIO::filesize_t)")]
        void CanResume(long arg1);
        [Q_SIGNAL("void open()")]
        void Open();
        [Q_SIGNAL("void written(KIO::filesize_t)")]
        void Written(long arg1);
        [Q_SIGNAL("void metaData(KIO::MetaData)")]
        void MetaData(KIO.MetaData arg1);
        [Q_SIGNAL("void totalSize(KIO::filesize_t)")]
        void TotalSize(long arg1);
        [Q_SIGNAL("void processedSize(KIO::filesize_t)")]
        void ProcessedSize(long arg1);
        [Q_SIGNAL("void redirection(KUrl)")]
        void Redirection(KUrl arg1);
        [Q_SIGNAL("void position(KIO::filesize_t)")]
        void Position(long arg1);
        [Q_SIGNAL("void speed(unsigned)")]
        void Speed(long arg1);
        [Q_SIGNAL("void errorPage()")]
        void ErrorPage();
        [Q_SIGNAL("void mimeType(QString)")]
        void MimeType(string arg1);
        [Q_SIGNAL("void warning(QString)")]
        void Warning(string arg1);
        [Q_SIGNAL("void infoMessage(QString)")]
        void InfoMessage(string arg1);
    }
}
