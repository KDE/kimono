//Auto-generated by kalyptus. DO NOT EDIT.
namespace KIO {
    using Kimono;
    using System;
    using Qyoto;
    /// <remarks>
    ///  A simple job (one url and one command).
    ///  This is the base class for all jobs that are scheduled.
    ///  Other jobs are high-level jobs (CopyJob, DeleteJob, FileCopyJob...)
    ///  that manage subjobs but aren't scheduled directly.
    ///      </remarks>        <short>    A simple job (one url and one command).</short>
    [SmokeClass("KIO::SimpleJob")]
    public class SimpleJob : KIO.Job, IDisposable {
        protected SimpleJob(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(SimpleJob), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static SimpleJob() {
            staticInterceptor = new SmokeInvocation(typeof(SimpleJob), null);
        }
        // KIO::SimpleJob* SimpleJob(KIO::SimpleJobPrivate& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Returns the SimpleJob's URL
        /// </remarks>        <return> the url
        ///          </return>
        ///         <short>    Returns the SimpleJob's URL </short>
        public KUrl Url() {
            return (KUrl) interceptor.Invoke("url", "url() const", typeof(KUrl));
        }
        /// <remarks>
        ///  Abort job.
        ///  Suspends slave to be reused by another job for the same request.
        ///          </remarks>        <short>    Abort job.</short>
        [SmokeMethod("putOnHold()")]
        public virtual void PutOnHold() {
            interceptor.Invoke("putOnHold", "putOnHold()", typeof(void));
        }
        /// <remarks>
        ///  Called on a slave's error.
        ///  Made public for the scheduler.
        ///          </remarks>        <short>   </short>
        [Q_SLOT("void slotError(int, QString)")]
        public void SlotError(int arg1, string arg2) {
            interceptor.Invoke("slotError$$", "slotError(int, const QString&)", typeof(void), typeof(int), arg1, typeof(string), arg2);
        }
        /// <remarks>
        ///  Suspend this job
        /// </remarks>        <short>    Suspend this job </short>
        ///         <see> resume</see>
        [SmokeMethod("doSuspend()")]
        protected override bool DoSuspend() {
            return (bool) interceptor.Invoke("doSuspend", "doSuspend()", typeof(bool));
        }
        /// <remarks>
        ///  Resume this job
        /// </remarks>        <short>    Resume this job </short>
        ///         <see> suspend</see>
        [SmokeMethod("doResume()")]
        protected override bool DoResume() {
            return (bool) interceptor.Invoke("doResume", "doResume()", typeof(bool));
        }
        /// <remarks>
        ///  Abort job.
        ///  This kills all subjobs and deletes the job.
        ///          </remarks>        <short>    Abort job.</short>
        [SmokeMethod("doKill()")]
        protected override bool DoKill() {
            return (bool) interceptor.Invoke("doKill", "doKill()", typeof(bool));
        }
        protected void StoreSSLSessionFromJob(KUrl m_redirectionURL) {
            interceptor.Invoke("storeSSLSessionFromJob#", "storeSSLSessionFromJob(const KUrl&)", typeof(void), typeof(KUrl), m_redirectionURL);
        }
        /// <remarks>
        ///  Creates a new simple job. You don't need to use this constructor,
        ///  unless you create a new job that inherits from SimpleJob.
        ///          </remarks>        <short>    Creates a new simple job.</short>
        /// <remarks>
        ///  Called when the slave marks the job
        ///  as finished.
        ///          </remarks>        <short>    Called when the slave marks the job  as finished.</short>
        [Q_SLOT("void slotFinished()")]
        [SmokeMethod("slotFinished()")]
        protected virtual void SlotFinished() {
            interceptor.Invoke("slotFinished", "slotFinished()", typeof(void));
        }
        /// <remarks>
        ///  Called on a slave's warning.
        ///          </remarks>        <short>   </short>
        [Q_SLOT("void slotWarning(QString)")]
        [SmokeMethod("slotWarning(const QString&)")]
        protected virtual void SlotWarning(string arg1) {
            interceptor.Invoke("slotWarning$", "slotWarning(const QString&)", typeof(void), typeof(string), arg1);
        }
        /// <remarks>
        ///  MetaData from the slave is received.
        /// <param> name="_metaData" the meta data
        /// </param></remarks>        <short>    MetaData from the slave is received.</short>
        ///         <see> metaData</see>
        [Q_SLOT("void slotMetaData(KIO::MetaData)")]
        [SmokeMethod("slotMetaData(const KIO::MetaData&)")]
        protected virtual void SlotMetaData(KIO.MetaData _metaData) {
            interceptor.Invoke("slotMetaData#", "slotMetaData(const KIO::MetaData&)", typeof(void), typeof(KIO.MetaData), _metaData);
        }
        ~SimpleJob() {
            interceptor.Invoke("~SimpleJob", "~SimpleJob()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~SimpleJob", "~SimpleJob()", typeof(void));
        }
        /// <remarks>
        ///  Discard suspended slave.
        ///          </remarks>        <short>    Discard suspended slave.</short>
        public static void RemoveOnHold() {
            staticInterceptor.Invoke("removeOnHold", "removeOnHold()", typeof(void));
        }
        protected new ISimpleJobSignals Emit {
            get { return (ISimpleJobSignals) Q_EMIT; }
        }
    }

    public interface ISimpleJobSignals : KIO.IJobSignals {
    }
}
