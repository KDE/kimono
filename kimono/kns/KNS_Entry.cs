//Auto-generated by kalyptus. DO NOT EDIT.
namespace KNS {
    using Kimono;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  This class provides accessor methods to the data objects
    ///  as used by KNewStuff.
    ///  It should probably not be used directly by the application.
    /// </remarks>        <author> Cornelius Schumacher (schumacher@kde.org)
    ///  \par Maintainer:
    ///  Josef Spillner (spillner@kde.org)
    ///  </author>
    ///         <short> KNewStuff data entry container. </short>
    [SmokeClass("KNS::Entry")]
    public class Entry : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected Entry(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Entry), this);
        }
        /// <remarks>
        ///  Status of the entry. An entry will be downloadable from the provider's
        ///  site prior to the download. Once downloaded and installed, it will
        ///  be either installed or updateable, implying an out-of-date
        ///  installation. Finally, the entry can be deleted and hence show up as
        ///  downloadable again.
        ///  Entries not taking part in this cycle, for example those in upload,
        ///  have an invalid status.
        ///      </remarks>        <short>    Status of the entry.</short>
        public enum Status {
            Invalid = 0,
            Downloadable = 1,
            Installed = 2,
            Updateable = 3,
            Deleted = 4,
        }
        /// <remarks>
        ///  Source of the entry, A entry's data is coming from either cache, or an online provider
        ///  this helps the engine know which data to use when merging cached entries with online
        ///  entry data
        ///      </remarks>        <short>    Source of the entry, A entry's data is coming from either cache, or an online provider  this helps the engine know which data to use when merging cached entries with online  entry data      </short>
        public enum Source {
            Cache = 0,
            Online = 1,
            Registry = 2,
        }
        /// <remarks>
        ///  Constructor.
        ///      </remarks>        <short>    Constructor.</short>
        public Entry() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Entry", "Entry()", typeof(void));
        }
        public Entry(KNS.Entry other) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Entry#", "Entry(const KNS::Entry&)", typeof(void), typeof(KNS.Entry), other);
        }
        /// <remarks>
        ///  Sets the name for this data object.
        ///      </remarks>        <short>    Sets the name for this data object.</short>
        public void SetName(KNS.KTranslatable name) {
            interceptor.Invoke("setName#", "setName(const KNS::KTranslatable&)", typeof(void), typeof(KNS.KTranslatable), name);
        }
        /// <remarks>
        ///  Retrieve the name of the data object.
        /// </remarks>        <return> object name (potentially translated)
        ///      </return>
        ///         <short>    Retrieve the name of the data object.</short>
        public KNS.KTranslatable Name() {
            return (KNS.KTranslatable) interceptor.Invoke("name", "name() const", typeof(KNS.KTranslatable));
        }
        /// <remarks>
        ///  Sets the data category, e.g. 'kdesktop/wallpaper'.
        ///      </remarks>        <short>    Sets the data category, e.</short>
        public void SetCategory(string category) {
            interceptor.Invoke("setCategory$", "setCategory(const QString&)", typeof(void), typeof(string), category);
        }
        /// <remarks>
        ///  Retrieve the category of the data object.
        /// </remarks>        <return> object category
        ///      </return>
        ///         <short>    Retrieve the category of the data object.</short>
        public string Category() {
            return (string) interceptor.Invoke("category", "category() const", typeof(string));
        }
        /// <remarks>
        ///  Sets the author of the object.
        ///      </remarks>        <short>    Sets the author of the object.</short>
        public void SetAuthor(KNS.Author author) {
            interceptor.Invoke("setAuthor#", "setAuthor(const KNS::Author&)", typeof(void), typeof(KNS.Author), author);
        }
        /// <remarks>
        ///  Retrieve the author of the object.
        /// </remarks>        <return> object author
        ///      </return>
        ///         <short>    Retrieve the author of the object.</short>
        public KNS.Author Author() {
            return (KNS.Author) interceptor.Invoke("author", "author() const", typeof(KNS.Author));
        }
        /// <remarks>
        ///  Sets the license (abbreviation) applicable to the object.
        ///      </remarks>        <short>    Sets the license (abbreviation) applicable to the object.</short>
        public void SetLicense(string license) {
            interceptor.Invoke("setLicense$", "setLicense(const QString&)", typeof(void), typeof(string), license);
        }
        /// <remarks>
        ///  Retrieve the license name of the object.
        /// </remarks>        <return> object license
        ///      </return>
        ///         <short>    Retrieve the license name of the object.</short>
        public string License() {
            return (string) interceptor.Invoke("license", "license() const", typeof(string));
        }
        /// <remarks>
        ///  Sets a short description on what the object is all about.
        ///      </remarks>        <short>    Sets a short description on what the object is all about.</short>
        public void SetSummary(KNS.KTranslatable summary) {
            interceptor.Invoke("setSummary#", "setSummary(const KNS::KTranslatable&)", typeof(void), typeof(KNS.KTranslatable), summary);
        }
        /// <remarks>
        ///  Retrieve a short description about the object.
        /// </remarks>        <return> object description
        ///      </return>
        ///         <short>    Retrieve a short description about the object.</short>
        public KNS.KTranslatable Summary() {
            return (KNS.KTranslatable) interceptor.Invoke("summary", "summary() const", typeof(KNS.KTranslatable));
        }
        /// <remarks>
        ///  Sets the version number.
        ///      </remarks>        <short>    Sets the version number.</short>
        public void SetVersion(string version) {
            interceptor.Invoke("setVersion$", "setVersion(const QString&)", typeof(void), typeof(string), version);
        }
        /// <remarks>
        ///  Retrieve the version string of the object.
        /// </remarks>        <return> object version
        ///      </return>
        ///         <short>    Retrieve the version string of the object.</short>
        public string Version() {
            return (string) interceptor.Invoke("version", "version() const", typeof(string));
        }
        /// <remarks>
        ///  Sets the release number, which is increased for feature-equal objects
        ///  with the same version number, but slightly updated contents.
        ///      </remarks>        <short>    Sets the release number, which is increased for feature-equal objects  with the same version number, but slightly updated contents.</short>
        public void SetRelease(int release) {
            interceptor.Invoke("setRelease$", "setRelease(int)", typeof(void), typeof(int), release);
        }
        /// <remarks>
        ///  Retrieve the release number of the object
        /// </remarks>        <return> object release
        ///      </return>
        ///         <short>    Retrieve the release number of the object </short>
        public int Release() {
            return (int) interceptor.Invoke("release", "release() const", typeof(int));
        }
        /// <remarks>
        ///  Sets the release date.
        ///      </remarks>        <short>    Sets the release date.</short>
        public void SetReleaseDate(QDate releasedate) {
            interceptor.Invoke("setReleaseDate#", "setReleaseDate(const QDate&)", typeof(void), typeof(QDate), releasedate);
        }
        /// <remarks>
        ///  Retrieve the date of the object's publication.
        /// </remarks>        <return> object release date
        ///      </return>
        ///         <short>    Retrieve the date of the object's publication.</short>
        public QDate ReleaseDate() {
            return (QDate) interceptor.Invoke("releaseDate", "releaseDate() const", typeof(QDate));
        }
        /// <remarks>
        ///  Sets the object's file.
        ///      </remarks>        <short>    Sets the object's file.</short>
        public void SetPayload(KNS.KTranslatable url) {
            interceptor.Invoke("setPayload#", "setPayload(const KNS::KTranslatable&)", typeof(void), typeof(KNS.KTranslatable), url);
        }
        /// <remarks>
        ///  Retrieve the file name of the object.
        /// </remarks>        <return> object filename
        ///      </return>
        ///         <short>    Retrieve the file name of the object.</short>
        public KNS.KTranslatable Payload() {
            return (KNS.KTranslatable) interceptor.Invoke("payload", "payload() const", typeof(KNS.KTranslatable));
        }
        /// <remarks>
        ///  Sets the object's preview file, if available. This should be a
        ///  picture file.
        ///      </remarks>        <short>    Sets the object's preview file, if available.</short>
        public void SetPreview(KNS.KTranslatable url) {
            interceptor.Invoke("setPreview#", "setPreview(const KNS::KTranslatable&)", typeof(void), typeof(KNS.KTranslatable), url);
        }
        /// <remarks>
        ///  Retrieve the file name of an image containing a preview of the object.
        /// </remarks>        <return> object preview filename
        ///      </return>
        ///         <short>    Retrieve the file name of an image containing a preview of the object.</short>
        public KNS.KTranslatable Preview() {
            return (KNS.KTranslatable) interceptor.Invoke("preview", "preview() const", typeof(KNS.KTranslatable));
        }
        /// <remarks>
        ///  Set the files that have been installed by the install command.
        /// <param> name="files" local file names
        ///      </param></remarks>        <short>    Set the files that have been installed by the install command.</short>
        public void SetInstalledFiles(List<string> files) {
            interceptor.Invoke("setInstalledFiles?", "setInstalledFiles(const QStringList&)", typeof(void), typeof(List<string>), files);
        }
        /// <remarks>
        ///  Set the files that have been uninstalled by the uninstall command.
        /// <param> name="files" local file names
        /// </param></remarks>        <short>    Set the files that have been uninstalled by the uninstall command.</short>
        public void SetUnInstalledFiles(List<string> files) {
            interceptor.Invoke("setUnInstalledFiles?", "setUnInstalledFiles(const QStringList&)", typeof(void), typeof(List<string>), files);
        }
        /// <remarks>
        ///  Retrieve the locally installed files.
        /// </remarks>        <return> file names
        ///      </return>
        ///         <short>    Retrieve the locally installed files.</short>
        public List<string> InstalledFiles() {
            return (List<string>) interceptor.Invoke("installedFiles", "installedFiles() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Retrieve the locally uninstalled files.
        /// </remarks>        <return> file names
        /// </return>
        ///         <short>    Retrieve the locally uninstalled files.</short>
        public List<string> UninstalledFiles() {
            return (List<string>) interceptor.Invoke("uninstalledFiles", "uninstalledFiles() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Sets the rating between 0 (worst) and 100 (best).
        ///      </remarks>        <short>    Sets the rating between 0 (worst) and 100 (best).</short>
        public void SetRating(int rating) {
            interceptor.Invoke("setRating$", "setRating(int)", typeof(void), typeof(int), rating);
        }
        /// <remarks>
        ///  Retrieve the rating for the object, which has been determined by its
        ///  users and thus might change over time.
        /// </remarks>        <return> object rating
        ///      </return>
        ///         <short>    Retrieve the rating for the object, which has been determined by its  users and thus might change over time.</short>
        public int Rating() {
            return (int) interceptor.Invoke("rating", "rating() const", typeof(int));
        }
        /// <remarks>
        ///  Sets the number of downloads.
        ///      </remarks>        <short>    Sets the number of downloads.</short>
        public void SetDownloads(int downloads) {
            interceptor.Invoke("setDownloads$", "setDownloads(int)", typeof(void), typeof(int), downloads);
        }
        /// <remarks>
        ///  Retrieve the download count for the object, which has been determined
        ///  by its hosting sites and thus might change over time.
        /// </remarks>        <return> object download count
        ///      </return>
        ///         <short>    Retrieve the download count for the object, which has been determined  by its hosting sites and thus might change over time.</short>
        public int Downloads() {
            return (int) interceptor.Invoke("downloads", "downloads() const", typeof(int));
        }
        /// <remarks>
        ///  Sets the checksum of the entry. This will be a string representation
        ///  of an MD5 sum of the entry's selected payload file.
        ///  <see cref="#checksum"></see> Checksum for the entry
        ///      </remarks>        <short>    Sets the checksum of the entry.</short>
        public void SetChecksum(string checksum) {
            interceptor.Invoke("setChecksum$", "setChecksum(const QString&)", typeof(void), typeof(string), checksum);
        }
        /// <remarks>
        ///  Sets the signature of the entry. This will be a digital signature
        ///  in OpenPGP-compliant format.
        ///  <see cref="#signature"></see> Signature for the entry
        ///      </remarks>        <short>    Sets the signature of the entry.</short>
        public void SetSignature(string signature) {
            interceptor.Invoke("setSignature$", "setSignature(const QString&)", typeof(void), typeof(string), signature);
        }
        /// <remarks>
        ///  Returns the checksum for the entry.
        ///  If an empty string is returned, no checksum was assigned.
        /// </remarks>        <return> Checksum of this entry
        ///      </return>
        ///         <short>    Returns the checksum for the entry.</short>
        public string Checksum() {
            return (string) interceptor.Invoke("checksum", "checksum() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the signature for the entry.
        ///  If an empty string is returned, no signature was assigned.
        /// </remarks>        <return> Signature of this entry
        ///      </return>
        ///         <short>    Returns the signature for the entry.</short>
        public string Signature() {
            return (string) interceptor.Invoke("signature", "signature() const", typeof(string));
        }
        /// <remarks>
        ///  Sets the entry's status. If no status is set, the default will be
        ///  \ref Invalid.
        /// <param> name="status" New status of the entry
        ///      </param></remarks>        <short>    Sets the entry's status.</short>
        public void SetStatus(KNS.Entry.Status status) {
            interceptor.Invoke("setStatus$", "setStatus(KNS::Entry::Status)", typeof(void), typeof(KNS.Entry.Status), status);
        }
        /// <remarks>
        ///  Retrieves the entry's status.
        /// </remarks>        <return> Current status of the entry
        ///      </return>
        ///         <short>    Retrieves the entry's status.</short>
        public KNS.Entry.Status status() {
            return (KNS.Entry.Status) interceptor.Invoke("status", "status()", typeof(KNS.Entry.Status));
        }
        public void SetSource(KNS.Entry.Source source) {
            interceptor.Invoke("setSource$", "setSource(KNS::Entry::Source)", typeof(void), typeof(KNS.Entry.Source), source);
        }
        public KNS.Entry.Source source() {
            return (KNS.Entry.Source) interceptor.Invoke("source", "source()", typeof(KNS.Entry.Source));
        }
        public void SetIdNumber(int number) {
            interceptor.Invoke("setIdNumber$", "setIdNumber(int)", typeof(void), typeof(int), number);
        }
        public int IdNumber() {
            return (int) interceptor.Invoke("idNumber", "idNumber() const", typeof(int));
        }
        ~Entry() {
            interceptor.Invoke("~Entry", "~Entry()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~Entry", "~Entry()", typeof(void));
        }
    }
}
