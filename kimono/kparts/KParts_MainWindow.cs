//Auto-generated by kalyptus. DO NOT EDIT.
namespace KParts {
    using Kimono;
    using System;
    using Qyoto;
    /// <remarks>
    ///  A KPart-aware main window, whose user interface is described in XML.
    ///  Inherit your main window from this class
    ///  and don't forget to call setXMLFile() in the inherited constructor.
    ///  It implements all internal interfaces in the case of a
    ///  KMainWindow as host: the builder and servant interface (for menu
    ///  merging).
    ///  </remarks>        <short>    A KPart-aware main window, whose user interface is described in XML.</short>
    [SmokeClass("KParts::MainWindow")]
    public class MainWindow : KXmlGuiWindow, KParts.IPartBase, IDisposable {
        protected MainWindow(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(MainWindow), this);
        }
        // KParts::PartBase* PartBase(KParts::PartBasePrivate& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Constructor, same signature as KMainWindow.
        ///    </remarks>        <short>    Constructor, same signature as KMainWindow.</short>
        public MainWindow(QWidget parent, uint f) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("MainWindow#$", "MainWindow(QWidget*, Qt::WindowFlags)", typeof(void), typeof(QWidget), parent, typeof(uint), f);
        }
        public MainWindow(QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("MainWindow#", "MainWindow(QWidget*)", typeof(void), typeof(QWidget), parent);
        }
        public MainWindow() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("MainWindow", "MainWindow()", typeof(void));
        }
        public MainWindow(QWidget parent, string name, uint f) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("MainWindow#$$", "MainWindow(QWidget*, const char*, Qt::WindowFlags)", typeof(void), typeof(QWidget), parent, typeof(string), name, typeof(uint), f);
        }
        public MainWindow(QWidget parent, string name) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("MainWindow#$", "MainWindow(QWidget*, const char*)", typeof(void), typeof(QWidget), parent, typeof(string), name);
        }
        [Q_SLOT("void configureToolbars()")]
        [SmokeMethod("configureToolbars()")]
        public override void ConfigureToolbars() {
            interceptor.Invoke("configureToolbars", "configureToolbars()", typeof(void));
        }
        [SmokeMethod("createShellGUI(bool)")]
        protected virtual void CreateShellGUI(bool create) {
            interceptor.Invoke("createShellGUI$", "createShellGUI(bool)", typeof(void), typeof(bool), create);
        }
        [SmokeMethod("createShellGUI()")]
        protected virtual void CreateShellGUI() {
            interceptor.Invoke("createShellGUI", "createShellGUI()", typeof(void));
        }
        /// <remarks>
        ///  Create the GUI (by merging the host's and the active part's)
        ///  You _must_ call this in order to see any GUI being created.
        ///  In a main window with multiple parts being shown (e.g. as in Konqueror)
        ///  you need to connect this slot to the
        ///  KPartManager.ActivePartChanged() signal
        /// <param> name="part" The active part (set to null if no part).
        ///    </param></remarks>        <short>    Create the GUI (by merging the host's and the active part's)  You _must_ call this in order to see any GUI being created.</short>
        [Q_SLOT("void createGUI(KParts::Part*)")]
        protected void CreateGUI(KParts.Part part) {
            interceptor.Invoke("createGUI#", "createGUI(KParts::Part*)", typeof(void), typeof(KParts.Part), part);
        }
        /// <remarks>
        ///  Called when the active part wants to change the statusbar message
        ///  Reimplement if your mainwindow has a complex statusbar
        ///  (with several items)
        ///    </remarks>        <short>    Called when the active part wants to change the statusbar message  Reimplement if your mainwindow has a complex statusbar  (with several items)    </short>
        [Q_SLOT("void slotSetStatusBarText(QString)")]
        [SmokeMethod("slotSetStatusBarText(const QString&)")]
        protected virtual void SlotSetStatusBarText(string arg1) {
            interceptor.Invoke("slotSetStatusBarText$", "slotSetStatusBarText(const QString&)", typeof(void), typeof(string), arg1);
        }
        /// <remarks>
        ///  Rebuilds the GUI after KEditToolbar changed the toolbar layout.
        /// </remarks>        <short>    Rebuilds the GUI after KEditToolbar changed the toolbar layout.</short>
        ///         <see> configureToolbars</see>
        ///         <see> KDE4:</see>
        ///         <see> make</see>
        ///         <see> this</see>
        ///         <see> virtual.</see>
        ///         <see> (For</see>
        ///         <see> now</see>
        ///         <see> we</see>
        ///         <see> rely</see>
        ///         <see> on</see>
        ///         <see> the</see>
        ///         <see> fact</see>
        ///         <see> that</see>
        ///         <see> it's</see>
        ///         <see> called</see>
        ///         <see> as</see>
        ///         <see> a</see>
        ///         <see> slot</see>
        ///         <see> so</see>
        ///         <see> the</see>
        ///         <see> metaobject</see>
        ///         <see> finds</see>
        ///         <see> it</see>
        ///         <see> here).</see>
        [Q_SLOT("void saveNewToolbarConfig()")]
        [SmokeMethod("saveNewToolbarConfig()")]
        protected override void SaveNewToolbarConfig() {
            interceptor.Invoke("saveNewToolbarConfig", "saveNewToolbarConfig()", typeof(void));
        }
        ~MainWindow() {
            interceptor.Invoke("~MainWindow", "~MainWindow()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~MainWindow", "~MainWindow()", typeof(void));
        }
        /// <remarks>
        ///   Internal method. Called by KParts.Part to specify the parent object for plugin objects.
        ///    </remarks>        <short>     Internal method.</short>
        public void SetPartObject(QObject arg1) {
            interceptor.Invoke("setPartObject#", "setPartObject(QObject*)", typeof(void), typeof(QObject), arg1);
        }
        public QObject PartObject() {
            return (QObject) interceptor.Invoke("partObject", "partObject() const", typeof(QObject));
        }
        /// <remarks>
        ///  Set the componentData(KComponentData) for this part.
        ///  Call this first in the inherited class constructor,
        ///  because it loads the i18n catalogs.
        ///    </remarks>        <short>    Set the componentData(KComponentData) for this part.</short>
        [SmokeMethod("setComponentData(const KComponentData&)")]
        protected virtual void SetComponentData(KComponentData componentData) {
            interceptor.Invoke("setComponentData#", "setComponentData(const KComponentData&)", typeof(void), typeof(KComponentData), componentData);
        }
        /// <remarks>
        ///  Set the componentData(KComponentData) for this part.
        ///  Call this first in the inherited class constructor,
        ///  because it loads the i18n catalogs.
        ///  It is recommended to call setComponentData with loadPlugins set to false,
        ///  and to load plugins at the end of your part constructor (in the case of
        ///  KParts.MainWindow, plugins are automatically loaded in createGUI anyway,
        ///  so set loadPlugins to false for KParts.MainWindow as well).
        ///    </remarks>        <short>    Set the componentData(KComponentData) for this part.</short>
        [SmokeMethod("setComponentData(const KComponentData&, bool)")]
        protected virtual void SetComponentData(KComponentData componentData, bool loadPlugins) {
            interceptor.Invoke("setComponentData#$", "setComponentData(const KComponentData&, bool)", typeof(void), typeof(KComponentData), componentData, typeof(bool), loadPlugins);
        }
        /// <remarks>
        ///  Load the Plugins honoring the PluginLoadingMode.
        ///  If you call this method in an already constructed GUI (like when the user
        ///  has changed which plugins are enabled) you need to add the new plugins to
        ///  the KXMLGUIFactory:
        ///  <pre>
        ///  if( factory() )
        ///  {
        ///    QList<KParts.Plugin > plugins = KParts.Plugin.PluginObjects( this );
        ///    for(int i = 0; i != plugins.size(); ++i) {
        ///       factory().AddClient( plugins[i] );
        ///    }
        ///  }
        ///  </pre>
        ///    </remarks>        <short>    Load the Plugins honoring the PluginLoadingMode.</short>
        protected void LoadPlugins(QObject parent, IKXMLGUIClient parentGUIClient, KComponentData componentData) {
            interceptor.Invoke("loadPlugins###", "loadPlugins(QObject*, KXMLGUIClient*, const KComponentData&)", typeof(void), typeof(QObject), parent, typeof(IKXMLGUIClient), parentGUIClient, typeof(KComponentData), componentData);
        }
        /// <remarks>
        ///  Set how plugins should be loaded
        /// <param> name="loadingMode" see PluginLoadingMode
        /// </param> For a KParts.Part: call this before setComponentData.
        ///  For a KParts.MainWindow: call this before createGUI.
        ///    </remarks>        <short>    Set how plugins should be loaded </short>
        protected void SetPluginLoadingMode(KParts.PartBase.PluginLoadingMode loadingMode) {
            interceptor.Invoke("setPluginLoadingMode$", "setPluginLoadingMode(KParts::PartBase::PluginLoadingMode)", typeof(void), typeof(KParts.PartBase.PluginLoadingMode), loadingMode);
        }
        /// <remarks>
        ///  If you change the binary interface offered by your part, you can avoid crashes
        ///  from old plugins lying around by setting X-KDE-InterfaceVersion=2 in the
        ///  .desktop files of the plugins, and calling setPluginInterfaceVersion( 2 ), so that
        ///  the old plugins are not loaded. Increase both numbers every time a
        ///  binary incompatible change in the application's plugin interface is made.
        /// <param> name="version" the interface version that plugins must have in order to be loaded.
        /// </param> For a KParts.Part: call this before setComponentData.
        ///  For a KParts.MainWindow: call this before createGUI.
        ///    </remarks>        <short>    If you change the binary interface offered by your part, you can avoid crashes  from old plugins lying around by setting X-KDE-InterfaceVersion=2 in the  .</short>
        protected void SetPluginInterfaceVersion(int version) {
            interceptor.Invoke("setPluginInterfaceVersion$", "setPluginInterfaceVersion(int)", typeof(void), typeof(int), version);
        }
        protected new IMainWindowSignals Emit {
            get { return (IMainWindowSignals) Q_EMIT; }
        }
    }

    public interface IMainWindowSignals : IKXmlGuiWindowSignals {
    }
}
