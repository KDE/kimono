//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  KUniqueApplication is a KApplication which only uses a single process.  When
    ///  a KUniqueApplication is started, it attempts to contact an existing copy 
    ///  of the application.  If successful, the program asks the 
    ///  existing process to create a new instance by calling its newInstance() method
    ///  and then exits.  If there is no existing process then the program forks and
    ///  calls the newInstance() method.  When newInstance() is called, the application
    ///  will typically create a new window or activate an existing one.
    ///  Instances of KUniqueApplication can be made to behave like a normal application by passing
    ///  the StartFlag.NonUniqueInstance flag to start().
    ///  Please note that this supports only one process per KDE session. If
    ///  your application can only be opened once per user or once per host, you
    ///  need to ensure this independently of KUniqueApplication.
    ///  The .desktop file for the application should state X-DBUS-StartupType=Unique,
    ///  see ktoolinvocation.h
    ///  If your application is used to open files, it should also support the --tempfile
    ///  option (see KCmdLineArgs.AddTempFileOption()), to delete tempfiles after use.
    ///  Add X-KDE-HasTempFileOption=true to the .desktop file to indicate this.
    /// </remarks>        <author> Preston Brown <pbrown@kde.org>
    ///  </author>
    ///         <short>    KUniqueApplication is a KApplication which only uses a single process.</short>
    ///         <see> KApplication</see>
    [SmokeClass("KUniqueApplication")]
    public class KUniqueApplication : KApplication, IDisposable {
        protected KUniqueApplication(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KUniqueApplication), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KUniqueApplication() {
            staticInterceptor = new SmokeInvocation(typeof(KUniqueApplication), null);
        }
        /// <remarks> 
        ///  These flags can be used to specify how new instances of 
        ///  unique applications are created.
        ///    </remarks>        <short>     These flags can be used to specify how new instances of   unique applications are created.</short>
        public enum StartFlag {
            NonUniqueInstance = 0x1,
        }
        /// <remarks>
        ///  Constructor. Takes command line arguments from KCmdLineArgs
        /// <param> name="GUIenabled" Set to false to disable all GUI stuff. This implies
        ///  no styles either.
        /// </param><param> name="configUnique" If true, the uniqueness of the application will
        ///                  depend on the value of the "MultipleInstances"
        ///                  key in the "KDE" group of the application config file.
        ///    </param></remarks>        <short>    Constructor.</short>
        public KUniqueApplication(bool GUIenabled, bool configUnique) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KUniqueApplication$$", "KUniqueApplication(bool, bool)", typeof(void), typeof(bool), GUIenabled, typeof(bool), configUnique);
        }
        public KUniqueApplication(bool GUIenabled) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KUniqueApplication$", "KUniqueApplication(bool)", typeof(void), typeof(bool), GUIenabled);
        }
        public KUniqueApplication() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KUniqueApplication", "KUniqueApplication()", typeof(void));
        }
        /// <remarks>
        ///  Creates a new "instance" of the application.
        ///  Usually this will involve making some calls into the GUI portion of your
        ///  application asking for a new window to be created, possibly with
        ///  some data already loaded based on the arguments received.
        ///  Command line arguments have been passed to KCmdLineArgs before this
        ///  function is called and can be checked in the usual way.
        ///  The default implementation ensures the mainwindow of the already
        ///  running instance is shown and activated if necessary. If your
        ///  application has only one mainwindow, you should call this default
        ///  implementation and only add your special handling if needed.
        ///  Note that newInstance() is called also in the first started
        ///  application process.
        ///  For applications that share one process for several mainwindows,
        ///  the reimplementation could be:
        ///  <pre>
        ///     int MyApp.NewInstance()
        ///     {
        ///     KCmdLineArgs.SetCwd(QDir.CurrentPath().toUtf8());
        ///     KCmdLineArgs args = KCmdLineArgs.ParsedArgs();
        ///     static bool first = true;
        ///     if (args.Count() > 0) {
        ///         for (int i = 0; i < args.Count(); ++i) {
        ///             openWindow(args.Url(i));
        ///         }
        ///     } else if( !first || !isSessionRestored()) {
        ///         openWindow(KUrl()); // create a new window
        ///     }
        ///     first = false;
        ///     args.Clear();
        ///     return 0;
        ///     }
        ///  </pre>
        /// </remarks>        <return> An exit value. The calling process will exit with this value.
        ///    </return>
        ///         <short>    Creates a new "instance" of the application.</short>
        [SmokeMethod("newInstance()")]
        public virtual int NewInstance() {
            return (int) interceptor.Invoke("newInstance", "newInstance()", typeof(int));
        }
        /// <remarks>
        ///  Returns whether newInstance() is being called while session
        ///  restoration is in progress.
        ///    </remarks>        <short>    Returns whether newInstance() is being called while session  restoration is in progress.</short>
        public bool RestoringSession() {
            return (bool) interceptor.Invoke("restoringSession", "restoringSession()", typeof(bool));
        }
        ~KUniqueApplication() {
            interceptor.Invoke("~KUniqueApplication", "~KUniqueApplication()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KUniqueApplication", "~KUniqueApplication()", typeof(void));
        }
        /// <remarks>
        ///  Adds command line options specific for KUniqueApplication.
        ///  Should be called before calling KUniqueApplication constructor
        ///  and / or start().
        ///    </remarks>        <short>    Adds command line options specific for KUniqueApplication.</short>
        public static void AddCmdLineOptions() {
            staticInterceptor.Invoke("addCmdLineOptions", "addCmdLineOptions()", typeof(void));
        }
        /// <remarks>
        ///  Forks and registers with D-Bus.
        ///  The command line arguments are being sent via D-Bus to newInstance()
        ///  and will be received once the application enters the event loop.
        ///  Typically this is used like:
        ///  <pre>
        ///  int main(string[] args) {
        ///     KAboutData about("myappname", 0, ki18n("myAppName"), .....);
        ///     KCmdLineArgs.Init(args, &about);
        ///     KCmdLineArgs.AddCmdLineOptions( myCmdOptions );
        ///     KUniqueApplication.AddCmdLineOptions();
        ///     if (!KUniqueApplication.Start()) {
        ///        fprintf(stderr, "myAppName is already running!\n");
        ///        return 0;
        ///     }
        ///     KUniqueApplication a;
        ///     return a.exec();
        ///  }
        ///  </pre>
        ///  Note that it's not necessary to call start() explicitly. It will be
        ///  called automatically before creating KUniqueApplication if it hasn't
        ///  been called yet, without any performance impact.
        ///  Also note that you MUST call KUniqueApplication.AddCmdLineOptions(),
        ///  if you use command line options before start() is called.
        /// <param> name="flags" Optional flags which control how a new instance 
        ///  				of the application is started.
        /// </param></remarks>        <return> true if registration is successful.
        ///          false if another process was already running.
        ///    </return>
        ///         <short>    Forks and registers with D-Bus.</short>
        public static bool Start(uint flags) {
            return (bool) staticInterceptor.Invoke("start$", "start(KUniqueApplication::StartFlags)", typeof(bool), typeof(uint), flags);
        }
        public static bool Start() {
            return (bool) staticInterceptor.Invoke("start", "start()", typeof(bool));
        }
        /// <remarks>
        ///    </remarks>        <short>   </short>
        public static void SetHandleAutoStarted() {
            staticInterceptor.Invoke("setHandleAutoStarted", "setHandleAutoStarted()", typeof(void));
        }
        protected new IKUniqueApplicationSignals Emit {
            get { return (IKUniqueApplicationSignals) Q_EMIT; }
        }
    }

    public interface IKUniqueApplicationSignals : IKApplicationSignals {
    }
}
