//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  A container for a "state-aware" brush.
    ///  KStatefulBrush provides an easy and safe way to store a color for use in a
    ///  user interface. It is "safe" both in that it will make it easy to deal with
    ///  widget states in a correct manner, and that it insulates you against changes
    ///  in QPalette.ColorGroup.
    ///  Basically, a stateful brush is used to cache a particular "color" from the
    ///  KDE system palette (usually, one which does not live in QPalette) in the way
    ///  you would have used a QColor in KDE3. When you are ready to draw using the
    ///  brush, you use the current state to retrieve the appropriate brush.
    ///  Stateful brushes can also be used to apply state effects to arbitrary
    ///  brushes, for example when working with a application specific user-defined
    ///  color palette.
    ///  @note As of Qt 4.3, QPalette.ColorGroup is missing a state for disabled
    ///  widgets in an inactive window. Hopefully Trolltech will fix this bug, at
    ///  which point KColorScheme and KStatefulBrush will be updated to recognize the
    ///  new state. Using KStatefulBrush will allow your application to inherit these
    ///  changes "for free", without even recompiling.
    ///  </remarks>        <short>    A container for a "state-aware" brush.</short>
    [SmokeClass("KStatefulBrush")]
    public class KStatefulBrush : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KStatefulBrush(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KStatefulBrush), this);
        }
        /// <remarks>
        ///  Construct a "default" stateful brush. For such an instance, all
        ///  overloads of KStatefulBrush.Brush will return a default brush (i.e.
        ///  <tt>QBrush()</tt>).
        ///      </remarks>        <short>    Construct a "default" stateful brush.</short>
        public KStatefulBrush() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush", "KStatefulBrush()", typeof(void));
        }
        /// <remarks>
        ///  Construct a stateful brush from given color set and foreground role,
        ///  using the colors from the given KConfig (if null, the system colors are
        ///  used).
        ///      </remarks>        <short>    Construct a stateful brush from given color set and foreground role,  using the colors from the given KConfig (if null, the system colors are  used).</short>
        public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.ForegroundRole arg2, KSharedConfig arg3) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush$$?", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::ForegroundRole, KSharedPtr<KSharedConfig>)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.ForegroundRole), arg2, typeof(KSharedConfig), arg3);
        }
        public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.ForegroundRole arg2) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush$$", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::ForegroundRole)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.ForegroundRole), arg2);
        }
        /// <remarks>
        ///  Construct a stateful brush from given color set and background role,
        ///  using the colors from the given KConfig (if null, the system colors are
        ///  used).
        ///      </remarks>        <short>    Construct a stateful brush from given color set and background role,  using the colors from the given KConfig (if null, the system colors are  used).</short>
        public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.BackgroundRole arg2, KSharedConfig arg3) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush$$?", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::BackgroundRole, KSharedPtr<KSharedConfig>)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.BackgroundRole), arg2, typeof(KSharedConfig), arg3);
        }
        public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.BackgroundRole arg2) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush$$", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::BackgroundRole)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.BackgroundRole), arg2);
        }
        /// <remarks>
        ///  Construct a stateful brush from given color set and decoration role,
        ///  using the colors from the given KConfig (if null, the system colors are
        ///  used).
        ///      </remarks>        <short>    Construct a stateful brush from given color set and decoration role,  using the colors from the given KConfig (if null, the system colors are  used).</short>
        public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.DecorationRole arg2, KSharedConfig arg3) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush$$?", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::DecorationRole, KSharedPtr<KSharedConfig>)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.DecorationRole), arg2, typeof(KSharedConfig), arg3);
        }
        public KStatefulBrush(KColorScheme.ColorSet arg1, KColorScheme.DecorationRole arg2) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush$$", "KStatefulBrush(KColorScheme::ColorSet, KColorScheme::DecorationRole)", typeof(void), typeof(KColorScheme.ColorSet), arg1, typeof(KColorScheme.DecorationRole), arg2);
        }
        /// <remarks>
        ///  Construct a stateful background brush from a specified QBrush (or
        ///  QColor, via QBrush's implicit constructor). The various states are
        ///  determined from the base QBrush (which fills in the Active state)
        ///  according to the same rules used to build stateful color schemes from
        ///  the system color scheme. The state effects from the given KConfig are
        ///  used (if null, the system state effects are used).
        ///      </remarks>        <short>    Construct a stateful background brush from a specified QBrush (or  QColor, via QBrush's implicit constructor).</short>
        public KStatefulBrush(QBrush arg1, KSharedConfig arg2) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush#?", "KStatefulBrush(const QBrush&, KSharedPtr<KSharedConfig>)", typeof(void), typeof(QBrush), arg1, typeof(KSharedConfig), arg2);
        }
        public KStatefulBrush(QBrush arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush#", "KStatefulBrush(const QBrush&)", typeof(void), typeof(QBrush), arg1);
        }
        /// <remarks>
        ///  Construct a stateful foreground/decoration brush from a specified
        ///  QBrush (or QColor, via QBrush's implicit constructor). The various
        ///  states are determined from the base QBrush (which fills in the Active
        ///  state) according to the same rules used to build stateful color schemes
        ///  from the system color scheme. The state effects from the given KConfig
        ///  are used (if null, the system state effects are used).
        /// <param> name="background" The background brush (or color) corresponding to the
        ///  KColorScheme.NormalBackground role and QPalette.Active state for this
        ///  foreground/decoration color.
        ///      </param></remarks>        <short>    Construct a stateful foreground/decoration brush from a specified  QBrush (or QColor, via QBrush's implicit constructor).</short>
        public KStatefulBrush(QBrush arg1, QBrush background, KSharedConfig arg3) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush##?", "KStatefulBrush(const QBrush&, const QBrush&, KSharedPtr<KSharedConfig>)", typeof(void), typeof(QBrush), arg1, typeof(QBrush), background, typeof(KSharedConfig), arg3);
        }
        public KStatefulBrush(QBrush arg1, QBrush background) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush##", "KStatefulBrush(const QBrush&, const QBrush&)", typeof(void), typeof(QBrush), arg1, typeof(QBrush), background);
        }
        /// <remarks> Construct a copy of another KStatefulBrush. </remarks>        <short>   Construct a copy of another KStatefulBrush.</short>
        public KStatefulBrush(KStatefulBrush arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStatefulBrush#", "KStatefulBrush(const KStatefulBrush&)", typeof(void), typeof(KStatefulBrush), arg1);
        }
        /// <remarks>
        ///  Retrieve the brush for the specified widget state. This is used when you
        ///  know explicitly what state is wanted. Otherwise one of overloads is
        ///  often more convenient.
        ///      </remarks>        <short>    Retrieve the brush for the specified widget state.</short>
        public QBrush Brush(QPalette.ColorGroup arg1) {
            return (QBrush) interceptor.Invoke("brush$", "brush(QPalette::ColorGroup) const", typeof(QBrush), typeof(QPalette.ColorGroup), arg1);
        }
        /// <remarks>
        ///  Retrieve the brush, using a QPalette reference to determine the correct
        ///  state. Use when your painting code has easy access to the QPalette that
        ///  it is supposed to be using. The state used in this instance is the
        ///  currentColorGroup of the palette.
        ///      </remarks>        <short>    Retrieve the brush, using a QPalette reference to determine the correct  state.</short>
        public QBrush Brush(QPalette arg1) {
            return (QBrush) interceptor.Invoke("brush#", "brush(const QPalette&) const", typeof(QBrush), typeof(QPalette), arg1);
        }
        /// <remarks>
        ///  Retrieve the brush, using a QWidget pointer to determine the correct
        ///  state. Use when you have a pointer to the widget that you are painting.
        ///  The state used is the current state of the widget.
        ///  @note If you pass an invalid widget, you will get a default brush (i.e.
        ///  <tt>QBrush()</tt>).
        ///      </remarks>        <short>    Retrieve the brush, using a QWidget pointer to determine the correct  state.</short>
        public QBrush Brush(QWidget arg1) {
            return (QBrush) interceptor.Invoke("brush#", "brush(const QWidget*) const", typeof(QBrush), typeof(QWidget), arg1);
        }
        ~KStatefulBrush() {
            interceptor.Invoke("~KStatefulBrush", "~KStatefulBrush()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KStatefulBrush", "~KStatefulBrush()", typeof(void));
        }
    }
}
