//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  The base class for all jobs.
    ///  For all jobs created in an application, the code looks like
    ///  <pre>
    ///  void SomeClass.MethodWithAsynchronousJobCall()
    ///  {
    ///    KJob  job = someoperation( some parameters );
    ///    connect( job, SIGNAL("result( KJob  )"),
    ///             this, SLOT("handleResult( KJob  )") );
    ///    job.Start();
    ///  }
    ///  </pre>
    ///    (other connects, specific to the job)
    ///  And handleResult is usually at least:
    ///  <pre>
    ///  void SomeClass.HandleResult( KJob job )
    ///  {
    ///    if ( job.Error() )
    ///        doSomething();
    ///  }
    ///  </pre>
    ///  With the synchronous interface the code looks like
    ///  <pre>
    ///  void SomeClass.MethodWithSynchronousJobCall()
    ///  {
    ///    KJob job = someoperation( some parameters );
    ///    if ( !job.Exec() )
    ///    {
    ///        // An error occurred
    ///    }
    ///    else
    ///    {
    ///        // Do something
    ///    }
    ///  }
    ///  </pre>
    ///  @note: KJob and its subclasses is meant to be used 
    ///  in a fire-and-forget way. It's deleting itself when
    ///  it has finished using deleteLater() so the job
    ///  instance disappears after the next event loop run.
    ///   See <see cref="IKJobSignals"></see> for signals emitted by KJob
    /// </remarks>        <short>    The base class for all jobs.</short>
    [SmokeClass("KJob")]
    public abstract class KJob : QObject {
        protected KJob(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KJob), this);
        }
        public enum Unit {
            Bytes = 0,
            Files = 1,
            Directories = 2,
        }
        public enum Capability {
            NoCapabilities = 0x0000,
            Killable = 0x0001,
            Suspendable = 0x0002,
        }
        public enum KillVerbosity {
            Quietly = 0,
            EmitResult = 1,
        }
        public const int NoError = 0;
        public const int KilledJobError = 1;
        public const int UserDefinedError = 100;
        /// <remarks>
        ///  Attach a UI delegate to this job.
        ///  If the job had another UI delegate, it's automatically deleted. Once
        ///  attached to the job, the UI delegate will be deleted with the job.
        /// <param> name="delegate" the new UI delegate to use
        /// </param></remarks>        <short>    Attach a UI delegate to this job.</short>
        ///         <see> KJobUiDelegate</see>
        public void SetUiDelegate(KJobUiDelegate arg1) {
            interceptor.Invoke("setUiDelegate#", "setUiDelegate(KJobUiDelegate*)", typeof(void), typeof(KJobUiDelegate), arg1);
        }
        /// <remarks>
        ///  Retrieves the delegate attached to this job.
        /// </remarks>        <return> the delegate attached to this job, or 0 if there's no such delegate
        ///      </return>
        ///         <short>    Retrieves the delegate attached to this job.</short>
        public KJobUiDelegate UiDelegate() {
            return (KJobUiDelegate) interceptor.Invoke("uiDelegate", "uiDelegate() const", typeof(KJobUiDelegate));
        }
        /// <remarks>
        ///  Returns the capabilities of this job.
        /// </remarks>        <return> the capabilities that this job supports
        /// </return>
        ///         <short>    Returns the capabilities of this job.</short>
        ///         <see> setCapabilities</see>
        public uint Capabilities() {
            return (uint) interceptor.Invoke("capabilities", "capabilities() const", typeof(uint));
        }
        /// <remarks>
        ///  Returns if the job was suspended with the suspend() call.
        /// </remarks>        <return> if the job was suspended
        /// </return>
        ///         <short>    Returns if the job was suspended with the suspend() call.</short>
        ///         <see> suspend</see>
        ///         <see> resume</see>
        public bool IsSuspended() {
            return (bool) interceptor.Invoke("isSuspended", "isSuspended() const", typeof(bool));
        }
        [SmokeMethod("start()")]
        public abstract void Start();
        /// <remarks>
        ///  Executes the job synchronously.
        /// </remarks>        <return> true if the job has been executed without error, false otherwise
        ///      </return>
        ///         <short>    Executes the job synchronously.</short>
        public bool Exec() {
            return (bool) interceptor.Invoke("exec", "exec()", typeof(bool));
        }
        /// <remarks>
        ///  Returns the error code, if there has been an error.
        ///  Only call this method from the slot connected to result().
        /// </remarks>        <return> the error code for this job, 0 if no error.
        ///      </return>
        ///         <short>    Returns the error code, if there has been an error.</short>
        public int Error() {
            return (int) interceptor.Invoke("error", "error() const", typeof(int));
        }
        /// <remarks>
        ///  Returns the error text if there has been an error.
        ///  Only call if error is not 0.
        ///  This is really internal, better use errorString.
        /// </remarks>        <return> a string to help understand the error, usually the url
        ///  related to the error. Only valid if error() is not 0.
        ///      </return>
        ///         <short>    Returns the error text if there has been an error.</short>
        public string ErrorText() {
            return (string) interceptor.Invoke("errorText", "errorText() const", typeof(string));
        }
        /// <remarks>
        ///  Converts an error code and a non-i18n error message into an
        ///  error message in the current language. The low level (non-i18n)
        ///  error message (usually a url) is put into the translated error
        ///  message using %1.
        ///  Example for errid == ERR_CANNOT_OPEN_FOR_READING:
        ///  <pre>
        ///    i18n( "Could not read\n%1" , errorText() );
        ///  </pre>
        ///  Do not call it if error() is not 0.
        /// </remarks>        <return> the error message and if there is no error, a message
        ///          telling the user that the app is broken, so check with
        ///          error() whether there is an error
        ///      </return>
        ///         <short>    Converts an error code and a non-i18n error message into an  error message in the current language.</short>
        [SmokeMethod("errorString() const")]
        public virtual string ErrorString() {
            return (string) interceptor.Invoke("errorString", "errorString() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the processed amount of a given unit for this job.
        /// <param> name="unit" the unit of the requested amount
        /// </param></remarks>        <return> the processed size
        ///      </return>
        ///         <short>    Returns the processed amount of a given unit for this job.</short>
        public ulong ProcessedAmount(KJob.Unit unit) {
            return (ulong) interceptor.Invoke("processedAmount$", "processedAmount(KJob::Unit) const", typeof(ulong), typeof(KJob.Unit), unit);
        }
        /// <remarks>
        ///  Returns the total amount of a given unit for this job.
        /// <param> name="unit" the unit of the requested amount
        /// </param></remarks>        <return> the total size
        ///      </return>
        ///         <short>    Returns the total amount of a given unit for this job.</short>
        public ulong TotalAmount(KJob.Unit unit) {
            return (ulong) interceptor.Invoke("totalAmount$", "totalAmount(KJob::Unit) const", typeof(ulong), typeof(KJob.Unit), unit);
        }
        /// <remarks>
        ///  Returns the overall progress of this job.
        /// </remarks>        <return> the overall progress of this job
        ///      </return>
        ///         <short>    Returns the overall progress of this job.</short>
        public ulong Percent() {
            return (ulong) interceptor.Invoke("percent", "percent() const", typeof(ulong));
        }
        /// <remarks>
        ///  set the auto-delete property of the job. If <code>autodelete</code> is
        ///  set to false the job will not delete itself once its finished.
        ///  The default for any KJob is to automatically delete itself.
        /// <param> name="autodelete" set to false to disable automatic deletion
        ///  of the job.
        ///      </param></remarks>        <short>    set the auto-delete property of the job.</short>
        public void SetAutoDelete(bool autodelete) {
            interceptor.Invoke("setAutoDelete$", "setAutoDelete(bool)", typeof(void), typeof(bool), autodelete);
        }
        /// <remarks>
        ///  Returns whether this job automatically deletes itself once
        ///  the job is finished.
        /// </remarks>        <return> whether the job is deleted automatically after
        ///  finishing.
        ///      </return>
        ///         <short>    Returns whether this job automatically deletes itself once  the job is finished.</short>
        public bool IsAutoDelete() {
            return (bool) interceptor.Invoke("isAutoDelete", "isAutoDelete() const", typeof(bool));
        }
        /// <remarks>
        ///  Aborts this job.
        ///  This kills and deletes the job.
        /// <param> name="verbosity" if equals to EmitResult, Job will emit signal result
        ///  and ask uiserver to close the progress window.
        ///  <code>verbosity</code> is set to EmitResult for subjobs. Whether applications
        ///  should call with Quietly or EmitResult depends on whether they rely
        ///  on result being emitted or not.
        /// </param></remarks>        <return> true if the operation is supported and succeeded, false otherwise
        ///      </return>
        ///         <short>    Aborts this job.</short>
        [Q_SLOT("bool kill(KillVerbosity)")]
        public bool Kill(KJob.KillVerbosity verbosity) {
            return (bool) interceptor.Invoke("kill$", "kill(KJob::KillVerbosity)", typeof(bool), typeof(KJob.KillVerbosity), verbosity);
        }
        [Q_SLOT("bool kill()")]
        public bool Kill() {
            return (bool) interceptor.Invoke("kill", "kill()", typeof(bool));
        }
        /// <remarks>
        ///  Suspends this job.
        ///  The job should be kept in a state in which it is possible to resume it.
        /// </remarks>        <return> true if the operation is supported and succeeded, false otherwise
        ///      </return>
        ///         <short>    Suspends this job.</short>
        [Q_SLOT("bool suspend()")]
        public bool Suspend() {
            return (bool) interceptor.Invoke("suspend", "suspend()", typeof(bool));
        }
        /// <remarks>
        ///  Resumes this job.
        /// </remarks>        <return> true if the operation is supported and succeeded, false otherwise
        ///      </return>
        ///         <short>    Resumes this job.</short>
        [Q_SLOT("bool resume()")]
        public bool Resume() {
            return (bool) interceptor.Invoke("resume", "resume()", typeof(bool));
        }
        /// <remarks>
        ///  Aborts this job quietly.
        ///  This simply kills the job, no error reporting or job deletion should be involved.
        /// </remarks>        <return> true if the operation is supported and succeeded, false otherwise
        ///      </return>
        ///         <short>    Aborts this job quietly.</short>
        [SmokeMethod("doKill()")]
        protected virtual bool DoKill() {
            return (bool) interceptor.Invoke("doKill", "doKill()", typeof(bool));
        }
        /// <remarks>
        ///  Suspends this job.
        /// </remarks>        <return> true if the operation is supported and succeeded, false otherwise
        ///      </return>
        ///         <short>    Suspends this job.</short>
        [SmokeMethod("doSuspend()")]
        protected virtual bool DoSuspend() {
            return (bool) interceptor.Invoke("doSuspend", "doSuspend()", typeof(bool));
        }
        /// <remarks>
        ///  Resumes this job.
        /// </remarks>        <return> true if the operation is supported and succeeded, false otherwise
        ///      </return>
        ///         <short>    Resumes this job.</short>
        [SmokeMethod("doResume()")]
        protected virtual bool DoResume() {
            return (bool) interceptor.Invoke("doResume", "doResume()", typeof(bool));
        }
        /// <remarks>
        ///  Sets the capabilities for this job.
        /// <param> name="capabilities" are the capabilities supported by this job
        /// </param></remarks>        <short>    Sets the capabilities for this job.</short>
        ///         <see> capabilities</see>
        protected void SetCapabilities(uint capabilities) {
            interceptor.Invoke("setCapabilities$", "setCapabilities(KJob::Capabilities)", typeof(void), typeof(uint), capabilities);
        }
        /// <remarks>
        ///  Sets the error code. It should be called when an error
        ///  is encountered in the job, just before calling emitResult().
        /// <param> name="errorCode" the error code
        /// </param></remarks>        <short>    Sets the error code.</short>
        ///         <see> emitResult</see>
        protected void SetError(int errorCode) {
            interceptor.Invoke("setError$", "setError(int)", typeof(void), typeof(int), errorCode);
        }
        /// <remarks>
        ///  Sets the error text. It should be called when an error
        ///  is encountered in the job, just before calling emitResult().
        /// <param> name="errorText" the error text
        /// </param></remarks>        <short>    Sets the error text.</short>
        ///         <see> emitResult</see>
        protected void SetErrorText(string errorText) {
            interceptor.Invoke("setErrorText$", "setErrorText(const QString&)", typeof(void), typeof(string), errorText);
        }
        /// <remarks>
        ///  Sets the processed size. The processedAmount() and percent() signals
        ///  are emitted if the values changed. The percent() signal is emitted
        ///  only for the progress unit.
        /// <param> name="unit" the unit of the new processed amount
        /// </param><param> name="amount" the new processed amount
        ///      </param></remarks>        <short>    Sets the processed size.</short>
        protected void SetProcessedAmount(KJob.Unit unit, ulong amount) {
            interceptor.Invoke("setProcessedAmount$$", "setProcessedAmount(KJob::Unit, qulonglong)", typeof(void), typeof(KJob.Unit), unit, typeof(ulong), amount);
        }
        /// <remarks>
        ///  Sets the total size. The totalSize() and percent() signals
        ///  are emitted if the values changed. The percent() signal is emitted
        ///  only for the progress unit.
        /// <param> name="unit" the unit of the new total amount
        /// </param><param> name="amount" the new total amount
        ///      </param></remarks>        <short>    Sets the total size.</short>
        protected void SetTotalAmount(KJob.Unit unit, ulong amount) {
            interceptor.Invoke("setTotalAmount$$", "setTotalAmount(KJob::Unit, qulonglong)", typeof(void), typeof(KJob.Unit), unit, typeof(ulong), amount);
        }
        /// <remarks>
        ///  Sets the overall progress of the job. The percent() signal
        ///  is emitted if the value changed.
        /// <param> name="percentage" the new overall progress
        ///      </param></remarks>        <short>    Sets the overall progress of the job.</short>
        protected void SetPercent(ulong percentage) {
            interceptor.Invoke("setPercent$", "setPercent(unsigned long)", typeof(void), typeof(ulong), percentage);
        }
        /// <remarks>
        ///  Utility function to emit the result signal, and suicide this job.
        ///  It first notifies the observers to hide the progress for this job using
        ///  the finished() signal.
        ///  @note: Deletes this job using deleteLater().
        /// </remarks>        <short>    Utility function to emit the result signal, and suicide this job.</short>
        ///         <see> result</see>
        ///         <see> finished</see>
        protected void EmitResult() {
            interceptor.Invoke("emitResult", "emitResult()", typeof(void));
        }
        /// <remarks>
        ///  Utility function for inherited jobs.
        ///  Emits the percent signal if bigger than previous value,
        ///  after calculating it from the parameters.
        /// <param> name="processedAmount" the processed amount
        /// </param><param> name="totalAmount" the total amount
        /// </param></remarks>        <short>    Utility function for inherited jobs.</short>
        ///         <see> percent</see>
        protected void EmitPercent(ulong processedAmount, ulong totalAmount) {
            interceptor.Invoke("emitPercent$$", "emitPercent(qulonglong, qulonglong)", typeof(void), typeof(ulong), processedAmount, typeof(ulong), totalAmount);
        }
        /// <remarks>
        ///  Utility function for inherited jobs.
        ///  Emits the speed signal and starts the timer for removing that info
        /// <param> name="speed" the speed in bytes/s
        ///      </param></remarks>        <short>    Utility function for inherited jobs.</short>
        protected void EmitSpeed(ulong speed) {
            interceptor.Invoke("emitSpeed$", "emitSpeed(unsigned long)", typeof(void), typeof(ulong), speed);
        }
        protected new IKJobSignals Emit {
            get { return (IKJobSignals) Q_EMIT; }
        }
    }

    public interface IKJobSignals : IQObjectSignals {
        /// <remarks>
        ///  Emitted to display state information about this job.
        ///  Examples of message are "Resolving host", "Connecting to host...", etc.
        /// <param> name="job" the job that emitted this signal
        /// </param><param> name="plain" the info message
        /// </param><param> name="rich" the rich text version of the message, or string() is none is available
        ///      </param></remarks>        <short>    Emitted to display state information about this job.</short>
        [Q_SIGNAL("void infoMessage(KJob*, QString, QString)")]
        void InfoMessage(KJob job, string plain, string rich);
        /// <remarks>
        ///  Emitted to display state information about this job.
        ///  Examples of message are "Resolving host", "Connecting to host...", etc.
        /// <param> name="job" the job that emitted this signal
        /// </param><param> name="plain" the info message
        /// </param><param> name="rich" the rich text version of the message, or string() is none is available
        ///      </param></remarks>        <short>    Emitted to display state information about this job.</short>
        [Q_SIGNAL("void infoMessage(KJob*, QString)")]
        void InfoMessage(KJob job, string plain);
        /// <remarks>
        ///  Emitted to display a warning about this job.
        /// <param> name="job" the job that emitted this signal
        /// </param><param> name="plain" the warning message
        /// </param><param> name="rich" the rich text version of the message, or string() is none is available
        ///      </param></remarks>        <short>    Emitted to display a warning about this job.</short>
        [Q_SIGNAL("void warning(KJob*, QString, QString)")]
        void Warning(KJob job, string plain, string rich);
        /// <remarks>
        ///  Emitted to display a warning about this job.
        /// <param> name="job" the job that emitted this signal
        /// </param><param> name="plain" the warning message
        /// </param><param> name="rich" the rich text version of the message, or string() is none is available
        ///      </param></remarks>        <short>    Emitted to display a warning about this job.</short>
        [Q_SIGNAL("void warning(KJob*, QString)")]
        void Warning(KJob job, string plain);
    }
}
