//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class KRandomSequence krandomsequence.h <KRandomSequence>
    ///  A class to create a pseudo-random sequence
    ///  Given a seed number, this class will produce a sequence of
    ///  pseudo-random numbers.  This would typically be used in
    ///  applications like games.
    ///  In general, you should instantiate a KRandomSequence object and
    ///  pass along your seed number in the constructor.  From then on,
    ///  simply call getDouble or getLong to obtain the next
    ///  number in the sequence.
    /// </remarks>        <author> Sean Harmer <sh@astro.keele.ac.uk>
    ///  </author>
    ///         <short>    \class KRandomSequence krandomsequence.</short>
    [SmokeClass("KRandomSequence")]
    public class KRandomSequence : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KRandomSequence(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KRandomSequence), this);
        }
        /// <remarks>
        ///  Creates a pseudo-random sequence based on the seed lngSeed.
        ///  A Pseudo-random sequence is different for each seed but can be
        ///  reproduced by starting the sequence with the same seed.
        ///  If you need a single value which needs to be unpredictable,
        ///  you need to use KRandom.Random() instead.
        /// <param> name="lngSeed" Seed to initialize the sequence with.
        ///  If lngSeed is 0, the sequence is initialized with a value from
        ///  KRandom.Random().
        ///    </param></remarks>        <short>    Creates a pseudo-random sequence based on the seed lngSeed.</short>
        public KRandomSequence(long lngSeed) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KRandomSequence$", "KRandomSequence(long)", typeof(void), typeof(long), lngSeed);
        }
        public KRandomSequence() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KRandomSequence", "KRandomSequence()", typeof(void));
        }
        /// <remarks>
        ///  Copy constructor
        ///    </remarks>        <short>    Copy constructor    </short>
        public KRandomSequence(KRandomSequence a) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KRandomSequence#", "KRandomSequence(const KRandomSequence&)", typeof(void), typeof(KRandomSequence), a);
        }
        /// <remarks>
        ///  Restart the sequence based on lngSeed.
        /// <param> name="lngSeed" Seed to initialize the sequence with.
        ///  If lngSeed is 0, the sequence is initialized with a value from
        ///  KRandom.Random().
        ///    </param></remarks>        <short>    Restart the sequence based on lngSeed.</short>
        public void SetSeed(long lngSeed) {
            interceptor.Invoke("setSeed$", "setSeed(long)", typeof(void), typeof(long), lngSeed);
        }
        public void SetSeed() {
            interceptor.Invoke("setSeed", "setSeed()", typeof(void));
        }
        /// <remarks>
        ///  Get the next number from the pseudo-random sequence.
        /// </remarks>        <return> a pseudo-random double value between [0,1)
        ///    </return>
        ///         <short>    Get the next number from the pseudo-random sequence.</short>
        public double GetDouble() {
            return (double) interceptor.Invoke("getDouble", "getDouble()", typeof(double));
        }
        /// <remarks>
        ///  Get the next number from the pseudo-random sequence.
        /// </remarks>        <return> a pseudo-random integer value between [0, max)
        ///  with 0 <= max < 1.000.000
        ///    </return>
        ///         <short>    Get the next number from the pseudo-random sequence.</short>
        public ulong GetLong(ulong max) {
            return (ulong) interceptor.Invoke("getLong$", "getLong(unsigned long)", typeof(ulong), typeof(ulong), max);
        }
        /// <remarks>
        ///  Get a boolean from the pseudo-random sequence.
        /// </remarks>        <return> a boolean which is either true or false
        ///    </return>
        ///         <short>    Get a boolean from the pseudo-random sequence.</short>
        public bool GetBool() {
            return (bool) interceptor.Invoke("getBool", "getBool()", typeof(bool));
        }
        /// <remarks>
        ///  Modulate the random sequence.
        ///  If S(i) is the sequence of numbers that will follow
        ///  given the current state after calling modulate(i),
        ///  then S(i) != S(j) for i != j and
        ///       S(i) == S(j) for i == j.
        ///  This can be useful in game situation where "undo" restores
        ///  the state of the random sequence. If the game modulates the
        ///  random sequence with the move chosen by the player, the
        ///  random sequence will be identical whenever the player "redo"-s
        ///  his or hers original move, but different when the player
        ///  chooses another move.
        ///  With this scenario "undo" can no longer be used to repeat a
        ///  certain move over and over again until the computer reacts
        ///  with a favorable response or to predict the response for a
        ///  certain move based on the response to another move.
        /// <param> name="i" the sequence identified
        ///    </param></remarks>        <short>    Modulate the random sequence.</short>
        public void Modulate(int i) {
            interceptor.Invoke("modulate$", "modulate(int)", typeof(void), typeof(int), i);
        }
        ~KRandomSequence() {
            interceptor.Invoke("~KRandomSequence", "~KRandomSequence()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KRandomSequence", "~KRandomSequence()", typeof(void));
        }
    }
}
