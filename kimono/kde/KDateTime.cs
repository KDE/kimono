//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Runtime.InteropServices;
    /// <remarks>
    ///  Topics:
    ///   - <see cref="#intro"></see>
    ///   - <see cref="#manipulation"></see>
    ///   - <see cref="#compatibility"></see>
    ///  @section intro Introduction
    ///  The class KDateTime combines a date and time with support for an
    ///  associated time zone or UTC offset. When manipulating KDateTime objects,
    ///  their time zones or UTC offsets are automatically taken into account. KDateTime
    ///  can also be set to represent a date-only value with no associated time.
    ///  The class uses QDateTime internally to represent date/time values, and
    ///  therefore uses the Gregorian calendar for dates starting from 15 October 1582,
    ///  and the Julian calendar for dates up to 4 October 1582. The minimum year
    ///  number is -4712 (4713 BC), while the upper limit is more than 11,000,000. The
    ///  actual adoption of the Gregorian calendar after 1582 was slow; the last European
    ///  country to adopt it, Greece, did so only in 1923. See QDateTime Considerations
    ///  section below for further discussion of the date range limitations.
    ///  The time specification types which KDateTime supports are:
    ///  - the UTC time zone
    ///  - a local time with a specified offset from UTC
    ///  - a local time in a specified time zone
    ///  - a local time using the current system time zone (a special case of the
    ///    previous item)
    ///  - local clock time, using whatever the local system clock says on whichever
    ///    computer it happens to be on. In this case, the equivalent UTC time will
    ///    vary depending on system. As a result, calculations involving local clock
    ///    times do not necessarily produce reliable results.
    ///  These characteristics are more fully described in the description of the
    ///  SpecType enumeration. Also see
    ///  <a href="http://www.w3.org/TR/timezone/">W3C: Working with Time Zones</a>
    ///  for a good overview of the different ways of representing times.
    ///  To set the time specification, use one of the setTimeSpec() methods, to get
    ///  the time specification, call timeSpec(), isUtc(), isLocalZone(),
    ///  isOffsetFromUtc() or isClockTime(). To determine whether two KDateTime
    ///  instances have the same time specification, call timeSpec() on each and
    ///  compare the returned values using KDateTime.Spec.Operator==().
    ///  @section manipulation Date and Time Manipulation
    ///  A KDateTime object can be created by passing a date and time in its
    ///  constructor, together with a time specification.
    ///  If both the date and time are null, isNull() returns true. If the date, time
    ///  and time specification are all valid, isValid() returns true.
    ///  A KDateTime object can be converted to a different time specification by
    ///  using toUtc(), toLocalZone() or toClockTime(). It can be converted to a
    ///  specific time zone by toZone(). To return the time as an elapsed time since
    ///  1 January 1970 (as used by time(2)), use toTime_t(). The results of time
    ///  zone conversions are cached to minimize the need for recalculation. Each
    ///  KDateTime object caches its UTC equivalent and the last time zone
    ///  conversion performed.
    ///  The date and time can be set either in the constructor, or afterwards by
    ///  calling setDate(), setTime() or setDateTime(). To return the date and/or
    ///  time components of the KDateTime, use date(), time() and dateTime(). You
    ///  can determine whether the KDateTime represents a date and time, or a date
    ///  only, by isDateOnly(). You can change between a date and time or a date only
    ///  value using setDateOnly().
    ///  You can increment or decrement the date/time using addSecs(), addDays(),
    ///  addMonths() and addYears(). The interval between two date/time values can
    ///  be found using secsTo() or daysTo().
    ///  The comparison operators (operator==(), operator<(), etc.) all take the time
    ///  zone properly into account; if the two KDateTime objects have different time
    ///  zones, they are first converted to UTC before the comparison is
    ///  performed. An alternative to the comparison operators is compare() which will
    ///  in addition tell you if a KDateTime object overlaps with another when one or
    ///  both are date-only values.
    ///  KDateTime values may be converted to and from a string representation using
    ///  the toString() and fromString() methods. These handle a variety of text
    ///  formats including ISO 8601 and RFC 2822.
    ///  KDateTime uses Qt's facilities to implicitly share data. Copying instances
    ///  is very efficient, and copied instances share cached UTC and time zone
    ///  conversions even after the copy is performed. A separate copy of the data is
    ///  created whenever a non-const method is called. If you want to force the
    ///  creation of a separate copy of the data (e.g. if you want two copies to
    ///  cache different time zone conversions), call detach(). 
    ///  @section compatibility QDateTime Considerations
    ///  KDateTime's interface is designed to be as compatible as possible with that
    ///  of QDateTime, but with adjustments to cater for time zone handling. Because
    ///  QDateTime lacks methods, KDateTime is not inherited from QDateTime,
    ///  but instead is implemented using a private QDateTime object.
    ///  The date range restriction due to the use of QDateTime internally may at
    ///  first sight seem a design limitation. However, two factors should be
    ///  considered:
    ///  - there are significant problems in the representation of dates before the
    ///    Gregorian calendar was adopted. The date of adoption of the Gregorian
    ///    calendar varied from place to place, and in the Julian calendar the
    ///    date of the new year varied so that in different places the year number
    ///    could differ by one. So any date/time system which attempted to represent
    ///    dates as actually used in history would be too specialized to belong to
    ///    the core KDE libraries. Date/time systems for scientific applications can
    ///    be much simpler, but may differ from historical records.
    ///  - time zones were not invented until the middle of the 19th century. Before
    ///    that, solar time was used.
    ///  Because of these issues, together with the fact that KDateTime's aim is to
    ///  provide automatic time zone handling for date/time values, QDateTime was
    ///  chosen as the basis for KDateTime. For those who need an extended date
    ///  range, other classes exist.
    /// </remarks>        <author> David Jarvie \<djarvie@kde.org\>.
    ///  </author>
    ///         <short> A class representing a date and time with an associated time zone.</short>
    ///         <see> KTimeZone</see>
    ///         <see> KSystemTimeZones</see>
    ///         <see> QDateTime</see>
    ///         <see> QDate</see>
    ///         <see> QTime</see>
    ///         <see> <a</see>
    ///         <see> href="http://www.w3.org/TR/timezone/">W3C:</see>
    ///         <see> Working</see>
    ///         <see> with</see>
    ///         <see> Time</see>
    ///         <see> Zones</a></see>
    [SmokeClass("KDateTime")]
    public class KDateTime : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KDateTime(Type dummy) {}
        /// <remarks>
        ///  The full time specification of a KDateTime instance.
        ///  This specifies how the date/time component of the KDateTime instance
        ///  should be interpreted, i.e. which time zone (if any) the date/time is
        ///  expressed in.
        ///      </remarks>        <short>    The full time specification of a KDateTime instance.</short>
        [SmokeClass("KDateTime::Spec")]
        public class Spec : Object {
            protected SmokeInvocation interceptor = null;
            private IntPtr smokeObject;
            protected Spec(Type dummy) {}
            protected void CreateProxy() {
                interceptor = new SmokeInvocation(typeof(Spec), this);
            }
            private static SmokeInvocation staticInterceptor = null;
            static Spec() {
                staticInterceptor = new SmokeInvocation(typeof(Spec), null);
            }
            //  Spec(); >>>> NOT CONVERTED
            //  Spec(const KTimeZone& arg1); >>>> NOT CONVERTED
            //  Spec(,); >>>> NOT CONVERTED
            //  Spec(); >>>> NOT CONVERTED
            // SpecType type(); >>>> NOT CONVERTED
            // void setType(,); >>>> NOT CONVERTED
            // bool operator==(); >>>> NOT CONVERTED
            // bool equivalentTo(); >>>> NOT CONVERTED
            /// <remarks>
            ///  Constructs an invalid time specification.
            ///          </remarks>        <short>    Constructs an invalid time specification.</short>
            /// <remarks>
            ///  Constructs a time specification for a given time zone.
            ///  If <code>tz</code> is KTimeZone.Utc(), the time specification type is set to <code>UTC.</code>
            /// <param> name="tz" time zone
            ///          </param></remarks>        <short>    Constructs a time specification for a given time zone.</short>
            /// <remarks>
            ///  Constructs a time specification.
            /// <param> name="type" time specification type, which should not be <code>TimeZone</code>
            /// </param><param> name="utcOffset" number of seconds to add to UTC to get the local
            ///                   time. Ignored if <code>type</code> is not <code>OffsetFromUTC.</code>
            ///          </param></remarks>        <short>    Constructs a time specification.</short>
            /// <remarks>
            ///  Returns whether the time specification is valid.
            /// </remarks>        <return> @c true if valid, else @c false
            ///          </return>
            ///         <short>    Returns whether the time specification is valid.</short>
            public bool IsValid() {
                return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
            }
            /// <remarks>
            ///  Returns the time zone for the date/time, according to the time
            ///  specification type as follows:
            ///  - <code>TimeZone</code>  : the specified time zone is returned.
            ///  - <code>UTC</code>       : a UTC time zone is returned.
            ///  - <code>LocalZone</code> : the current local time zone is returned.
            /// </remarks>        <return> time zone as defined above, or invalid in all other cases
            /// </return>
            ///         <short>    Returns the time zone for the date/time, according to the time  specification type as follows:  - @c TimeZone  : the specified time zone is returned.</short>
            ///         <see> isUtc</see>
            ///         <see> isLocal</see>
            public KTimeZone TimeZone() {
                return (KTimeZone) interceptor.Invoke("timeZone", "timeZone() const", typeof(KTimeZone));
            }
            /// <remarks>
            ///  Returns the time specification type, i.e. whether it is
            ///  UTC, has a time zone, etc. If the type is the local time zone,
            ///  <code>TimeZone</code> is returned; use isLocalZone() to check for the
            ///  local time zone.
            /// </remarks>        <return> specification type
            /// </return>
            ///         <short>    Returns the time specification type, i.</short>
            ///         <see> isLocalZone</see>
            ///         <see> isClockTime</see>
            ///         <see> isUtc</see>
            ///         <see> timeZone</see>
            /// <remarks>
            ///  Returns whether the time specification is the current local
            ///  system time zone.
            /// </remarks>        <return> @c true if local system time zone
            /// </return>
            ///         <short>    Returns whether the time specification is the current local  system time zone.</short>
            ///         <see> isUtc</see>
            ///         <see> isOffsetFromUtc</see>
            ///         <see> timeZone</see>
            public bool IsLocalZone() {
                return (bool) interceptor.Invoke("isLocalZone", "isLocalZone() const", typeof(bool));
            }
            /// <remarks>
            ///  Returns whether the time specification is a local clock time.
            /// </remarks>        <return> @c true if local clock time
            /// </return>
            ///         <short>    Returns whether the time specification is a local clock time.</short>
            ///         <see> isUtc</see>
            ///         <see> timeZone</see>
            public bool IsClockTime() {
                return (bool) interceptor.Invoke("isClockTime", "isClockTime() const", typeof(bool));
            }
            /// <remarks>
            ///  Returns whether the time specification is a UTC time.
            ///  It is considered to be a UTC time if it is either type <code>UTC</code>,
            ///  or is type <code>OffsetFromUTC</code> with a zero UTC offset.
            /// </remarks>        <return> @c true if UTC
            /// </return>
            ///         <short>    Returns whether the time specification is a UTC time.</short>
            ///         <see> isLocal</see>
            ///         <see> isOffsetFromUtc</see>
            ///         <see> timeZone</see>
            public bool IsUtc() {
                return (bool) interceptor.Invoke("isUtc", "isUtc() const", typeof(bool));
            }
            /// <remarks>
            ///  Returns whether the time specification is a local time at a fixed
            ///  offset from UTC.
            /// </remarks>        <return> @c true if local time at fixed offset from UTC
            /// </return>
            ///         <short>    Returns whether the time specification is a local time at a fixed  offset from UTC.</short>
            ///         <see> isLocal</see>
            ///         <see> isUtc</see>
            ///         <see> utcOffset</see>
            public bool IsOffsetFromUtc() {
                return (bool) interceptor.Invoke("isOffsetFromUtc", "isOffsetFromUtc() const", typeof(bool));
            }
            /// <remarks>
            ///  Returns the UTC offset associated with the time specification. The
            ///  UTC offset is the number of seconds to add to UTC to get the local time.
            /// </remarks>        <return> UTC offset in seconds if type is @c OffsetFromUTC, else 0
            /// </return>
            ///         <short>    Returns the UTC offset associated with the time specification.</short>
            ///         <see> isOffsetFromUtc</see>
            public int UtcOffset() {
                return (int) interceptor.Invoke("utcOffset", "utcOffset() const", typeof(int));
            }
            /// <remarks>
            ///  Initialises the time specification.
            /// <param> name="type" the time specification type. Note that <code>TimeZone</code>
            ///                   is invalid here.
            /// </param><param> name="utcOffset" number of seconds to add to UTC to get the local
            ///                   time. Ignored if <code>spec</code> is not <code>OffsetFromUTC.</code>
            /// </param></remarks>        <short>    Initialises the time specification.</short>
            ///         <see> type</see>
            ///         <see> setType(const</see>
            ///         <see> KTimeZone&)</see>
            /// <remarks>
            ///  Sets the time zone for the time specification.
            ///  To set the time zone to the current local system time zone,
            ///  setType(LocalZone) may optionally be used instead.
            /// <param> name="tz" new time zone
            /// </param></remarks>        <short>    Sets the time zone for the time specification.</short>
            ///         <see> timeZone</see>
            ///         <see> setType(SpecType)</see>
            public void SetType(KTimeZone tz) {
                interceptor.Invoke("setType#", "setType(const KTimeZone&)", typeof(void), typeof(KTimeZone), tz);
            }
            /// <remarks>
            ///  Comparison operator.
            /// </remarks>        <return> @c true if the two instances are identical, @c false otherwise
            /// </return>
            ///         <short>    Comparison operator.</short>
            ///         <see> equivalentTo</see>
            /// <remarks>
            ///  Checks whether this instance is equivalent to another.
            ///  The two instances are considered to be equivalent if any of the following
            ///  conditions apply:
            ///  - both instances are type <code>ClockTime.</code>
            ///  - both instances are type <code>OffsetFromUTC</code> and their offsets from UTC are equal.
            ///  - both instances are type <code>TimeZone</code> and their time zones are equal.
            ///  - both instances are UTC. An instance is considered to be UTC if it is
            ///    either type <code>UTC</code>, or is type <code>OffsetFromUTC</code> with a zero UTC offset.
            /// </remarks>        <return> @c true if the two instances are equivalent, @c false otherwise
            /// </return>
            ///         <short>    Checks whether this instance is equivalent to another.</short>
            ///         <see> operator==</see>
            /// <remarks>
            ///  The UTC time specification.
            ///  Provided as a shorthand for KDateTime.Spec(KDateTime.UTC).
            ///          </remarks>        <short>    The UTC time specification.</short>
            public static int UTC() {
                return (int) staticInterceptor.Invoke("UTC", "UTC()", typeof(int));
            }
            /// <remarks>
            ///  The ClockTime time specification.
            ///  Provided as a shorthand for KDateTime.Spec(KDateTime.ClockTime).
            ///          </remarks>        <short>    The ClockTime time specification.</short>
            public static int ClockTime() {
                return (int) staticInterceptor.Invoke("ClockTime", "ClockTime()", typeof(int));
            }
            /// <remarks>
            ///  Returns a UTC offset time specification.
            ///  Provided as a shorthand for KDateTime.Spec(KDateTime.OffsetFromUTC, utcOffset).
            /// <param> name="utcOffset" number of seconds to add to UTC to get the local time
            /// </param></remarks>        <return> UTC offset time specification
            ///          </return>
            ///         <short>    Returns a UTC offset time specification.</short>
            public static int OffsetFromUTC(int utcOffset) {
                return (int) staticInterceptor.Invoke("OffsetFromUTC$", "OffsetFromUTC(int)", typeof(int), typeof(int), utcOffset);
            }
            /// <remarks>
            ///  Returns a local time zone time specification.
            ///  Provided as a shorthand for KDateTime.Spec(KDateTime.LocalZone).
            /// </remarks>        <return> Local zone time specification
            ///          </return>
            ///         <short>    Returns a local time zone time specification.</short>
            public static int LocalZone() {
                return (int) staticInterceptor.Invoke("LocalZone", "LocalZone()", typeof(int));
            }
        }
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KDateTime), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KDateTime() {
            staticInterceptor = new SmokeInvocation(typeof(KDateTime), null);
        }
        /// <remarks>
        ///  The time specification type of a KDateTime instance.
        ///  This specifies how the date/time component of the KDateTime instance
        ///  should be interpreted, i.e. what type of time zone (if any) the date/time
        ///  is expressed in. For the full time specification (including time zone
        ///  details), see KDateTime.Spec.
        ///      </remarks>        <short>    The time specification type of a KDateTime instance.</short>
        public enum SpecType {
            Invalid = 0,
            UTC = 1,
            OffsetFromUTC = 2,
            TimeZone = 3,
            LocalZone = 4,
            ClockTime = 5,
        }
        /// <remarks> Format for strings representing date/time values. </remarks>        <short>   Format for strings representing date/time values.</short>
        public enum TimeFormat {
            ISODate = 0,
            RFCDate = 1,
            RFCDateDay = 2,
            QtTextDate = 3,
            LocalDate = 4,
        }
        /// <remarks>
        ///  How this KDateTime compares with another.
        ///  If any date-only value is involved, comparison of KDateTime values
        ///  requires them to be considered as representing time periods. A date-only
        ///  instance represents a time period from 00:00:00 to 23:59:59.999 on a given
        ///  date, while a date/time instance can be considered to represent a time
        ///  period whose start and end times are the same. They may therefore be
        ///  earlier or later, or may overlap or be contained one within the other.
        ///  Values may be OR'ed with each other in any combination of 'consecutive'
        ///  intervals to represent different types of relationship.
        ///  In the descriptions of the values below,
        ///  - s1 = start time of this instance
        ///  - e1 = end time of this instance
        ///  - s2 = start time of other instance
        ///  - e2 = end time of other instance.
        ///      </remarks>        <short>    How this KDateTime compares with another.</short>
        public enum Comparison {
            Before = 0x01,
            AtStart = 0x02,
            Inside = 0x04,
            AtEnd = 0x08,
            After = 0x10,
            Equal = AtStart|Inside|AtEnd,
            Outside = Before|AtStart|Inside|AtEnd|After,
            StartsAt = AtStart|Inside|AtEnd|After,
            EndsAt = Before|AtStart|Inside|AtEnd,
        }
        // KDateTime* KDateTime(const QDate& arg1,const KDateTime::Spec& arg2); >>>> NOT CONVERTED
        // KDateTime* KDateTime(const QDate& arg1,const QTime& arg2,const KDateTime::Spec& arg3); >>>> NOT CONVERTED
        // KDateTime* KDateTime(const QDateTime& arg1,const KDateTime::Spec& arg2); >>>> NOT CONVERTED
        // KDateTime::Spec timeSpec(); >>>> NOT CONVERTED
        // KDateTime toTimeSpec(const KDateTime::Spec& arg1); >>>> NOT CONVERTED
        // void setTimeSpec(const KDateTime::Spec& arg1); >>>> NOT CONVERTED
        // KDateTime currentDateTime(const KDateTime::Spec& arg1); >>>> NOT CONVERTED
        // void setFromStringDefault(const KDateTime::Spec& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Constructs an invalid date/time.
        ///      </remarks>        <short>    Constructs an invalid date/time.</short>
        public KDateTime() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KDateTime", "KDateTime()", typeof(void));
        }
        /// <remarks>
        ///  Constructs a date-only value expressed in a given time specification. The
        ///  time is set to 00:00:00.
        ///  The instance is initialised according to the time specification type of
        ///  <code>spec</code> as follows:
        ///  - <code>UTC</code>           : date is stored as UTC.
        ///  - <code>OffsetFromUTC</code> : date is a local time at the specified offset
        ///                       from UTC.
        ///  - <code>TimeZone</code>      : date is a local time in the specified time zone.
        ///  - <code>LocalZone</code>     : date is a local date in the current system time
        ///                       zone.
        ///  - <code>ClockTime</code>     : time zones are ignored.
        /// <param> name="date" date in the time zone indicated by <code>spec</code>
        /// </param><param> name="spec" time specification
        ///      </param></remarks>        <short>    Constructs a date-only value expressed in a given time specification.</short>
        public KDateTime(QDate date) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KDateTime#", "KDateTime(const QDate&)", typeof(void), typeof(QDate), date);
        }
        /// <remarks>
        ///  Constructs a date/time expressed as specified by <code>spec.</code>
        ///  <code>date</code> and <code>time</code> are interpreted and stored according to the value of
        ///  <code>spec</code> as follows:
        ///  - <code>UTC</code>           : <code>date</code> and <code>time</code> are in UTC.
        ///  - <code>OffsetFromUTC</code> : date/time is a local time at the specified offset
        ///                       from UTC.
        ///  - <code>TimeZone</code>      : date/time is a local time in the specified time zone.
        ///  - <code>LocalZone</code>     : <code>date</code> and <code>time</code> are local times in the current
        ///                       system time zone.
        ///  - <code>ClockTime</code>     : time zones are ignored.
        /// <param> name="date" date in the time zone indicated by <code>spec</code>
        /// </param><param> name="time" time in the time zone indicated by <code>spec</code>
        /// </param><param> name="spec" time specification
        ///      </param></remarks>        <short>    Constructs a date/time expressed as specified by <code>spec.</code></short>
        public KDateTime(QDate date, QTime time) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KDateTime##", "KDateTime(const QDate&, const QTime&)", typeof(void), typeof(QDate), date, typeof(QTime), time);
        }
        /// <remarks>
        ///  Constructs a date/time expressed in a given time specification.
        ///  <code>dt</code> is interpreted and stored according to the time specification type
        ///  of <code>spec</code> as follows:
        ///  - <code>UTC</code>           : <code>dt</code> is stored as a UTC value. If
        ///                       <code>dt.timeSpec</code>() is <code>Qt</code>.LocalTime, <code>dt</code> is first
        ///                       converted from the current system time zone to UTC
        ///                       before storage.
        ///  - <code>OffsetFromUTC</code> : date/time is stored as a local time at the specified
        ///                       offset from UTC. If <code>dt.timeSpec</code>() is <code>Qt</code>.UTC,
        ///                       the time is adjusted by the UTC offset before
        ///                       storage. If <code>dt.timeSpec</code>() is <code>Qt</code>.LocalTime,
        ///                       it is assumed to be a local time at the specified
        ///                       offset from UTC, and is stored without adjustment.
        ///  - <code>TimeZone</code>      : if <code>dt</code> is specified as a UTC time (i.e. <code>dt.timeSpec</code>()
        ///                       is <code>Qt</code>.UTC), it is first converted to local time in
        ///                       specified time zone before being stored.
        ///  - <code>LocalZone</code>     : <code>dt</code> is stored as a local time in the current system
        ///                       time zone. If <code>dt.timeSpec</code>() is <code>Qt</code>.UTC, <code>dt</code> is
        ///                       first converted to local time before storage.
        ///  - <code>ClockTime</code>     : If <code>dt.timeSpec</code>() is <code>Qt</code>.UTC, <code>dt</code> is first
        ///                       converted to local time in the current system time zone
        ///                       before storage. After storage, the time is treated as a
        ///                       simple clock time, ignoring time zones.
        /// <param> name="dt" date and time
        /// </param><param> name="spec" time specification
        ///      </param></remarks>        <short>    Constructs a date/time expressed in a given time specification.</short>
        /// <remarks>
        ///  Constructs a date/time from a QDateTime.
        ///  The KDateTime is expressed in either UTC or the local system time zone,
        ///  according to <code>dt.timeSpec</code>().
        /// <param> name="dt" date and time
        ///      </param></remarks>        <short>    Constructs a date/time from a QDateTime.</short>
        public KDateTime(QDateTime dt) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KDateTime#", "KDateTime(const QDateTime&)", typeof(void), typeof(QDateTime), dt);
        }
        public KDateTime(KDateTime other) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KDateTime#", "KDateTime(const KDateTime&)", typeof(void), typeof(KDateTime), other);
        }
        /// <remarks>
        ///  Returns whether the date/time is null.
        /// </remarks>        <return> @c true if both date and time are null, else @c false
        /// </return>
        ///         <short>    Returns whether the date/time is null.</short>
        ///         <see> isValid</see>
        ///         <see> QDateTime.IsNull</see>
        public bool IsNull() {
            return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns whether the date/time is valid.
        /// </remarks>        <return> @c true if both date and time are valid, else @c false
        /// </return>
        ///         <short>    Returns whether the date/time is valid.</short>
        ///         <see> isNull</see>
        ///         <see> QDateTime.IsValid</see>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns whether the instance represents a date/time or a date-only value.
        /// </remarks>        <return> @c true if date-only, @c false if date and time
        ///      </return>
        ///         <short>    Returns whether the instance represents a date/time or a date-only value.</short>
        public bool IsDateOnly() {
            return (bool) interceptor.Invoke("isDateOnly", "isDateOnly() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns the date part of the date/time. The value returned should be
        ///  interpreted in terms of the instance's time zone or UTC offset.
        /// </remarks>        <return> date value
        /// </return>
        ///         <short>    Returns the date part of the date/time.</short>
        ///         <see> time</see>
        ///         <see> dateTime</see>
        public QDate Date() {
            return (QDate) interceptor.Invoke("date", "date() const", typeof(QDate));
        }
        /// <remarks>
        ///  Returns the time part of the date/time. The value returned should be
        ///  interpreted in terms of the instance's time zone or UTC offset. If
        ///  the instance is date-only, the time returned is 00:00:00.
        /// </remarks>        <return> time value
        /// </return>
        ///         <short>    Returns the time part of the date/time.</short>
        ///         <see> date</see>
        ///         <see> dateTime</see>
        ///         <see> isDateOnly</see>
        public QTime Time() {
            return (QTime) interceptor.Invoke("time", "time() const", typeof(QTime));
        }
        /// <remarks>
        ///  Returns the date/time component of the instance, ignoring the time
        ///  zone. The value returned should be interpreted in terms of the
        ///  instance's time zone or UTC offset. The returned value's <code>timeSpec</code>()
        ///  value will be <code>Qt</code>.UTC if the instance is a UTC time, else
        ///  <code>Qt</code>.LocalTime. If the instance is date-only, the time value is set to
        ///  00:00:00.
        /// </remarks>        <return> date/time
        /// </return>
        ///         <short>    Returns the date/time component of the instance, ignoring the time  zone.</short>
        ///         <see> date</see>
        ///         <see> time</see>
        public QDateTime DateTime() {
            return (QDateTime) interceptor.Invoke("dateTime", "dateTime() const", typeof(QDateTime));
        }
        /// <remarks>
        ///  Returns the time zone for the date/time. If the date/time is specified
        ///  as a UTC time, a UTC time zone is always returned.
        /// </remarks>        <return> time zone, or invalid if a local time at a fixed UTC offset or a
        ///          local clock time
        /// </return>
        ///         <short>    Returns the time zone for the date/time.</short>
        ///         <see> isUtc</see>
        ///         <see> isLocal</see>
        public KTimeZone TimeZone() {
            return (KTimeZone) interceptor.Invoke("timeZone", "timeZone() const", typeof(KTimeZone));
        }
        /// <remarks>
        ///  Returns the time specification of the date/time, i.e. whether it is
        ///  UTC, what time zone it is, etc.
        /// </remarks>        <return> time specification
        /// </return>
        ///         <short>    Returns the time specification of the date/time, i.</short>
        ///         <see> isLocalZone</see>
        ///         <see> isClockTime</see>
        ///         <see> isUtc</see>
        ///         <see> timeZone</see>
        /// <remarks>
        ///  Returns the time specification type of the date/time, i.e. whether it is
        ///  UTC, has a time zone, etc. If the type is the local time zone,
        ///  <code>TimeZone</code> is returned; use isLocalZone() to check for the local time
        ///  zone.
        /// </remarks>        <return> specification type
        /// </return>
        ///         <short>    Returns the time specification type of the date/time, i.</short>
        ///         <see> timeSpec</see>
        ///         <see> isLocalZone</see>
        ///         <see> isClockTime</see>
        ///         <see> isUtc</see>
        ///         <see> timeZone</see>
        public KDateTime.SpecType TimeType() {
            return (KDateTime.SpecType) interceptor.Invoke("timeType", "timeType() const", typeof(KDateTime.SpecType));
        }
        /// <remarks>
        ///  Returns whether the time zone for the date/time is the current local
        ///  system time zone.
        /// </remarks>        <return> @c true if local system time zone
        /// </return>
        ///         <short>    Returns whether the time zone for the date/time is the current local  system time zone.</short>
        ///         <see> isUtc</see>
        ///         <see> isOffsetFromUtc</see>
        ///         <see> timeZone</see>
        public bool IsLocalZone() {
            return (bool) interceptor.Invoke("isLocalZone", "isLocalZone() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns whether the date/time is a local clock time.
        /// </remarks>        <return> @c true if local clock time
        /// </return>
        ///         <short>    Returns whether the date/time is a local clock time.</short>
        ///         <see> isUtc</see>
        ///         <see> timeZone</see>
        public bool IsClockTime() {
            return (bool) interceptor.Invoke("isClockTime", "isClockTime() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns whether the date/time is a UTC time.
        ///  It is considered to be a UTC time if it either has a UTC time
        ///  specification (SpecType == UTC), or has a zero offset from UTC
        ///  (SpecType == OffsetFromUTC with zero UTC offset).
        /// </remarks>        <return> @c true if UTC
        /// </return>
        ///         <short>    Returns whether the date/time is a UTC time.</short>
        ///         <see> isLocal</see>
        ///         <see> isOffsetFromUtc</see>
        ///         <see> timeZone</see>
        public bool IsUtc() {
            return (bool) interceptor.Invoke("isUtc", "isUtc() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns whether the date/time is a local time at a fixed offset from
        ///  UTC.
        /// </remarks>        <return> @c true if local time at fixed offset from UTC
        /// </return>
        ///         <short>    Returns whether the date/time is a local time at a fixed offset from  UTC.</short>
        ///         <see> isLocal</see>
        ///         <see> isUtc</see>
        ///         <see> utcOffset</see>
        public bool IsOffsetFromUtc() {
            return (bool) interceptor.Invoke("isOffsetFromUtc", "isOffsetFromUtc() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns the UTC offset associated with the date/time. The UTC offset is
        ///  the number of seconds to add to UTC to get the local time.
        /// </remarks>        <return> UTC offset in seconds, or 0 if local clock time
        /// </return>
        ///         <short>    Returns the UTC offset associated with the date/time.</short>
        ///         <see> isClockTime</see>
        public int UtcOffset() {
            return (int) interceptor.Invoke("utcOffset", "utcOffset() const", typeof(int));
        }
        /// <remarks>
        ///  Returns whether the date/time is the second occurrence of this time. This
        ///  is only applicable to a date/time expressed in terms of a time zone (type
        ///  <code>TimeZone</code> or <code>LocalZone</code>), around the time of change from daylight
        ///  savings to standard time.
        ///  When a shift from daylight savings time to standard time occurs, the local
        ///  times (typically the previous hour) immediately preceding the shift occur
        ///  twice. For example, if a time shift of 1 hour happens at 03:00, the clock
        ///  jumps backwards to 02:00, so the local times between 02:00:00 and 02:59:59
        ///  occur once before the shift, and again after the shift.
        ///  For instances which are not of type <code>TimeZone</code>, or when the date/time is
        ///  not near to a time shift, <code>false</code> is returned.
        /// </remarks>        <return> @c true if the time is the second occurrence, @c false otherwise
        /// </return>
        ///         <short>    Returns whether the date/time is the second occurrence of this time.</short>
        ///         <see> setSecondOccurrence</see>
        public bool IsSecondOccurrence() {
            return (bool) interceptor.Invoke("isSecondOccurrence", "isSecondOccurrence() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns the time converted to UTC. The converted time has a UTC offset
        ///  of zero.
        ///  If the instance is a local clock time, it is first set to the local time
        ///  zone, and then converted to UTC.
        ///  If the instance is a date-only value, a date-only UTC value is returned,
        ///  with the date unchanged.
        /// </remarks>        <return> converted time
        /// </return>
        ///         <short>    Returns the time converted to UTC.</short>
        ///         <see> toOffsetFromUtc</see>
        ///         <see> toLocalZone</see>
        ///         <see> toZone</see>
        ///         <see> toTimeSpec</see>
        ///         <see> toTime_t</see>
        ///         <see> KTimeZone.Convert</see>
        public KDateTime ToUtc() {
            return (KDateTime) interceptor.Invoke("toUtc", "toUtc() const", typeof(KDateTime));
        }
        /// <remarks>
        ///  Returns the time expressed as an offset from UTC, using the UTC offset
        ///  associated with this instance's date/time. The date and time
        ///  components are unchanged. For example, 14:15 on 12 Jan 2001, US Eastern
        ///  time zone would return a KDateTime value of 14:15 on 12 Jan 2001 with a
        ///  UTC offset of -18000 seconds (i.e. -5 hours).
        ///  If the instance is a local clock time, the offset is set to that of the
        ///  local time zone.
        ///  If the instance is a date-only value, the offset is set to that at the
        ///  start of the day.
        /// </remarks>        <return> converted time
        /// </return>
        ///         <short>    Returns the time expressed as an offset from UTC, using the UTC offset  associated with this instance's date/time.</short>
        ///         <see> toUtc</see>
        ///         <see> toOffsetFromUtc(int)</see>
        ///         <see> toLocalZone</see>
        ///         <see> toZone</see>
        ///         <see> toTimeSpec</see>
        ///         <see> toTime_t</see>
        ///         <see> KTimeZone.Convert</see>
        public KDateTime ToOffsetFromUtc() {
            return (KDateTime) interceptor.Invoke("toOffsetFromUtc", "toOffsetFromUtc() const", typeof(KDateTime));
        }
        /// <remarks>
        ///  Returns the time expressed as a specified offset from UTC.
        ///  If the instance is a local clock time, it is first set to the local time
        ///  zone, and then converted to the UTC offset.
        ///  If the instance is a date-only value, a date-only clock time value is
        ///  returned, with the date unchanged.
        /// <param> name="utcOffset" number of seconds to add to UTC to get the local time.
        /// </param></remarks>        <return> converted time
        /// </return>
        ///         <short>    Returns the time expressed as a specified offset from UTC.</short>
        ///         <see> toUtc</see>
        ///         <see> toOffsetFromUtc</see>
        ///         <see> toLocalZone</see>
        ///         <see> toZone</see>
        ///         <see> toTimeSpec</see>
        ///         <see> toTime_t</see>
        ///         <see> KTimeZone.Convert</see>
        public KDateTime ToOffsetFromUtc(int utcOffset) {
            return (KDateTime) interceptor.Invoke("toOffsetFromUtc$", "toOffsetFromUtc(int) const", typeof(KDateTime), typeof(int), utcOffset);
        }
        /// <remarks>
        ///  Returns the time converted to the current local system time zone.
        ///  If the instance is a date-only value, a date-only local time zone value
        ///  is returned, with the date unchanged.
        /// </remarks>        <return> converted time
        /// </return>
        ///         <short>    Returns the time converted to the current local system time zone.</short>
        ///         <see> toUtc</see>
        ///         <see> toOffsetFromUtc</see>
        ///         <see> toZone</see>
        ///         <see> toTimeSpec</see>
        ///         <see> KTimeZone.Convert</see>
        public KDateTime ToLocalZone() {
            return (KDateTime) interceptor.Invoke("toLocalZone", "toLocalZone() const", typeof(KDateTime));
        }
        /// <remarks>
        ///  Returns the time converted to the local clock time. The time is first
        ///  converted to the local system time zone before setting its type to
        ///  ClockTime, i.e. no associated time zone.
        ///  If the instance is a date-only value, a date-only clock time value is
        ///  returned, with the date unchanged.
        /// </remarks>        <return> converted time
        /// </return>
        ///         <short>    Returns the time converted to the local clock time.</short>
        ///         <see> toLocalZone</see>
        ///         <see> toTimeSpec</see>
        public KDateTime ToClockTime() {
            return (KDateTime) interceptor.Invoke("toClockTime", "toClockTime() const", typeof(KDateTime));
        }
        /// <remarks>
        ///  Returns the time converted to a specified time zone.
        ///  If the instance is a local clock time, it is first set to the local time
        ///  zone, and then converted to <code>zone.</code>
        ///  If the instance is a date-only value, a date-only value in <code>zone</code> is
        ///  returned, with the date unchanged.
        /// <param> name="zone" time zone to convert to
        /// </param></remarks>        <return> converted time
        /// </return>
        ///         <short>    Returns the time converted to a specified time zone.</short>
        ///         <see> toUtc</see>
        ///         <see> toOffsetFromUtc</see>
        ///         <see> toLocalZone</see>
        ///         <see> toTimeSpec</see>
        ///         <see> KTimeZone.Convert</see>
        public KDateTime ToZone(KTimeZone zone) {
            return (KDateTime) interceptor.Invoke("toZone#", "toZone(const KTimeZone&) const", typeof(KDateTime), typeof(KTimeZone), zone);
        }
        /// <remarks>
        ///  Returns the time converted to a new time specification.
        ///  If the instance is a local clock time, it is first set to the local time
        ///  zone, and then converted to the <code>spec</code> time specification.
        ///  If the instance is a date-only value, a date-only value is returned,
        ///  with the date unchanged.
        /// <param> name="spec" new time specification
        /// </param></remarks>        <return> converted time
        /// </return>
        ///         <short>    Returns the time converted to a new time specification.</short>
        ///         <see> toLocalZone</see>
        ///         <see> toUtc</see>
        ///         <see> toOffsetFromUtc</see>
        ///         <see> toZone</see>
        ///         <see> KTimeZone.Convert</see>
        /// <remarks>
        ///  Returns the time converted to the time specification of another instance.
        ///  If this instance is a local clock time, it is first set to the local time
        ///  zone, and then converted to the <code>spec</code> time specification.
        ///  If this instance is a date-only value, a date-only value is returned,
        ///  with the date unchanged.
        /// <param> name="dt" instance providing the new time specification
        /// </param></remarks>        <return> converted time
        /// </return>
        ///         <short>    Returns the time converted to the time specification of another instance.</short>
        ///         <see> toLocalZone</see>
        ///         <see> toUtc</see>
        ///         <see> toOffsetFromUtc</see>
        ///         <see> toZone</see>
        ///         <see> KTimeZone.Convert</see>
        public KDateTime ToTimeSpec(KDateTime dt) {
            return (KDateTime) interceptor.Invoke("toTimeSpec#", "toTimeSpec(const KDateTime&) const", typeof(KDateTime), typeof(KDateTime), dt);
        }
        /// <remarks>
        ///  Converts the time to a UTC time, measured in seconds since 00:00:00 UTC
        ///  1st January 1970 (as returned by time(2)).
        /// </remarks>        <return> converted time, or -1 if the date is out of range
        /// </return>
        ///         <short>    Converts the time to a UTC time, measured in seconds since 00:00:00 UTC  1st January 1970 (as returned by time(2)).</short>
        ///         <see> setTime_t</see>
        public uint ToTime_t() {
            return (uint) interceptor.Invoke("toTime_t", "toTime_t() const", typeof(uint));
        }
        /// <remarks>
        ///  Sets the time to a UTC time, specified as seconds since 00:00:00 UTC
        ///  1st January 1970 (as returned by time(2)).
        /// <param> name="seconds" number of seconds since 00:00:00 UTC 1st January 1970
        /// </param></remarks>        <short>    Sets the time to a UTC time, specified as seconds since 00:00:00 UTC  1st January 1970 (as returned by time(2)).</short>
        ///         <see> toTime_t</see>
        public void SetTime_t(long seconds) {
            interceptor.Invoke("setTime_t$", "setTime_t(qint64)", typeof(void), typeof(long), seconds);
        }
        /// <remarks>
        ///  Sets the instance either to being a date and time value, or a date-only
        ///  value. If its status is changed to date-only, its time is set to
        ///  00:00:00.
        /// <param> name="dateOnly" <code>true</code> to set to date-only, <code>false</code> to set to date
        ///                  and time.
        /// </param></remarks>        <short>    Sets the instance either to being a date and time value, or a date-only  value.</short>
        ///         <see> isDateOnly</see>
        ///         <see> setTime</see>
        public void SetDateOnly(bool dateOnly) {
            interceptor.Invoke("setDateOnly$", "setDateOnly(bool)", typeof(void), typeof(bool), dateOnly);
        }
        /// <remarks>
        ///  Sets the date part of the date/time.
        /// <param> name="date" new date value
        /// </param></remarks>        <short>    Sets the date part of the date/time.</short>
        ///         <see> date</see>
        ///         <see> setTime</see>
        ///         <see> setTimeSpec</see>
        ///         <see> setTime_t</see>
        ///         <see> setDateOnly</see>
        public void SetDate(QDate date) {
            interceptor.Invoke("setDate#", "setDate(const QDate&)", typeof(void), typeof(QDate), date);
        }
        /// <remarks>
        ///  Sets the time part of the date/time. If the instance was date-only, it
        ///  is changed to being a date and time value.
        /// <param> name="time" new time value
        /// </param></remarks>        <short>    Sets the time part of the date/time.</short>
        ///         <see> time</see>
        ///         <see> setDate</see>
        ///         <see> setTimeSpec</see>
        ///         <see> setTime_t</see>
        public void SetTime(QTime time) {
            interceptor.Invoke("setTime#", "setTime(const QTime&)", typeof(void), typeof(QTime), time);
        }
        /// <remarks>
        ///  Sets the date/time part of the instance, leaving the time specification
        ///  unaffected.
        ///  If <code>dt</code> is a local time (<pre> dt.timeSpec() == Qt.LocalTime </pre>)
        ///  and the instance is UTC, <code>dt</code> is first converted from the current
        ///  system time zone to UTC before being stored.
        ///  If the instance was date-only, it is changed to being a date and time
        ///  value.
        /// <param> name="dt" date and time
        /// </param></remarks>        <short>    Sets the date/time part of the instance, leaving the time specification  unaffected.</short>
        ///         <see> dateTime</see>
        ///         <see> setDate</see>
        ///         <see> setTime</see>
        ///         <see> setTimeSpec</see>
        public void SetDateTime(QDateTime dt) {
            interceptor.Invoke("setDateTime#", "setDateTime(const QDateTime&)", typeof(void), typeof(QDateTime), dt);
        }
        /// <remarks>
        ///  Changes the time specification of the instance.
        ///  Any previous time zone is forgotten. The stored date/time component of
        ///  the instance is left unchanged (except that its UTC/local time setting
        ///  is set to correspond with <code>spec</code>). Usually this method will change the
        ///  absolute time which this instance represents.
        /// <param> name="spec" new time specification
        /// </param></remarks>        <short>    Changes the time specification of the instance.</short>
        ///         <see> timeSpec</see>
        ///         <see> timeZone</see>
        /// <remarks>
        ///  Sets whether the date/time is the second occurrence of this time. This
        ///  is only applicable to a date/time expressed in terms of a time zone (type
        ///  <code>TimeZone</code> or <code>LocalZone</code>), around the time of change from daylight
        ///  savings to standard time.
        ///  When a shift from daylight savings time to standard time occurs, the local
        ///  times (typically the previous hour) immediately preceding the shift occur
        ///  twice. For example, if a time shift of 1 hour happens at 03:00, the clock
        ///  jumps backwards to 02:00, so the local times between 02:00:00 and 02:59:59
        ///  occur once before the shift, and again after the shift.
        ///  For instances which are not of type <code>TimeZone</code>, or when the date/time is
        ///  not near to a time shift, calling this method has no effect.
        ///  Note that most other setting methods clear the second occurrence indicator,
        ///  so if you want to retain its setting, you must call setSecondOccurrence()
        ///  again after changing the instance's value.
        /// <param> name="second" <code>true</code> to set as the second occurrence, <code>false</code> to set as
        ///                the first occurrence
        /// </param></remarks>        <short>    Sets whether the date/time is the second occurrence of this time.</short>
        ///         <see> isSecondOccurrence</see>
        public void SetSecondOccurrence(bool second) {
            interceptor.Invoke("setSecondOccurrence$", "setSecondOccurrence(bool)", typeof(void), typeof(bool), second);
        }
        /// <remarks>
        ///  Returns a date/time <code>msecs</code> milliseconds later than the stored date/time.
        ///  Except when the instance is a local clock time (type <code>ClockTime</code>), the
        ///  calculation is done in UTC to ensure that the result takes proper account
        ///  of clock changes (e.g. daylight savings) in the time zone. The result is
        ///  expressed using the same time specification as the original instance.
        ///  Note that if the instance is a local clock time (type <code>ClockTime</code>), any
        ///  daylight savings changes or time zone changes during the period will
        ///  render the result inaccurate.
        ///  If the instance is date-only, <code>msecs</code> is rounded down to a whole number
        ///  of days and that value is added to the date to find the result.
        /// </remarks>        <return> resultant date/time
        /// </return>
        ///         <short>    Returns a date/time <code>msecs</code> milliseconds later than the stored date/time.</short>
        ///         <see> addSecs</see>
        ///         <see> addDays</see>
        ///         <see> addMonths</see>
        ///         <see> addYears</see>
        ///         <see> secsTo</see>
        public KDateTime AddMSecs(long msecs) {
            return (KDateTime) interceptor.Invoke("addMSecs$", "addMSecs(qint64) const", typeof(KDateTime), typeof(long), msecs);
        }
        /// <remarks>
        ///  Returns a date/time <code>secs</code> seconds later than the stored date/time.
        ///  Except when the instance is a local clock time (type <code>ClockTime</code>), the
        ///  calculation is done in UTC to ensure that the result takes proper account
        ///  of clock changes (e.g. daylight savings) in the time zone. The result is
        ///  expressed using the same time specification as the original instance.
        ///  Note that if the instance is a local clock time (type <code>ClockTime</code>), any
        ///  daylight savings changes or time zone changes during the period will
        ///  render the result inaccurate.
        ///  If the instance is date-only, <code>secs</code> is rounded down to a whole number
        ///  of days and that value is added to the date to find the result.
        /// </remarks>        <return> resultant date/time
        /// </return>
        ///         <short>    Returns a date/time <code>secs</code> seconds later than the stored date/time.</short>
        ///         <see> addMSecs</see>
        ///         <see> addDays</see>
        ///         <see> addMonths</see>
        ///         <see> addYears</see>
        ///         <see> secsTo</see>
        public KDateTime AddSecs(long secs) {
            return (KDateTime) interceptor.Invoke("addSecs$", "addSecs(qint64) const", typeof(KDateTime), typeof(long), secs);
        }
        /// <remarks>
        ///  Returns a date/time <code>days</code> days later than the stored date/time.
        ///  The result is expressed using the same time specification as the
        ///  original instance.
        ///  Note that if the instance is a local clock time (type <code>ClockTime</code>), any
        ///  daylight savings changes or time zone changes during the period may
        ///  render the result inaccurate.
        /// </remarks>        <return> resultant date/time
        /// </return>
        ///         <short>    Returns a date/time <code>days</code> days later than the stored date/time.</short>
        ///         <see> addSecs</see>
        ///         <see> addMonths</see>
        ///         <see> addYears</see>
        ///         <see> daysTo</see>
        public KDateTime AddDays(int days) {
            return (KDateTime) interceptor.Invoke("addDays$", "addDays(int) const", typeof(KDateTime), typeof(int), days);
        }
        /// <remarks>
        ///  Returns a date/time <code>months</code> months later than the stored date/time.
        ///  The result is expressed using the same time specification as the
        ///  original instance.
        ///  Note that if the instance is a local clock time (type <code>ClockTime</code>), any
        ///  daylight savings changes or time zone changes during the period may
        ///  render the result inaccurate.
        /// </remarks>        <return> resultant date/time
        /// </return>
        ///         <short>    Returns a date/time <code>months</code> months later than the stored date/time.</short>
        ///         <see> addSecs</see>
        ///         <see> addDays</see>
        ///         <see> addYears</see>
        ///         <see> daysTo</see>
        public KDateTime AddMonths(int months) {
            return (KDateTime) interceptor.Invoke("addMonths$", "addMonths(int) const", typeof(KDateTime), typeof(int), months);
        }
        /// <remarks>
        ///  Returns a date/time <code>years</code> years later than the stored date/time.
        ///  The result is expressed using the same time specification as the
        ///  original instance.
        ///  Note that if the instance is a local clock time (type <code>ClockTime</code>), any
        ///  daylight savings changes or time zone changes during the period may
        ///  render the result inaccurate.
        /// </remarks>        <return> resultant date/time
        /// </return>
        ///         <short>    Returns a date/time <code>years</code> years later than the stored date/time.</short>
        ///         <see> addSecs</see>
        ///         <see> addDays</see>
        ///         <see> addMonths</see>
        ///         <see> daysTo</see>
        public KDateTime AddYears(int years) {
            return (KDateTime) interceptor.Invoke("addYears$", "addYears(int) const", typeof(KDateTime), typeof(int), years);
        }
        /// <remarks>
        ///  Returns the number of seconds from this date/time to the <code>other</code> date/time.
        ///  Before performing the comparison, the two date/times are converted to UTC
        ///  to ensure that the result is correct if one of the two date/times has
        ///  daylight saving time (DST) and the other doesn't. The exception is when
        ///  both instances are local clock time, in which case no conversion to UTC
        ///  is done.
        ///  Note that if either instance is a local clock time (type <code>ClockTime</code>),
        ///  the result cannot be guaranteed to be accurate, since by definition they
        ///  contain no information about time zones or daylight savings changes.
        ///  If one instance is date-only and the other is date-time, the date-time
        ///  value is first converted to the same time specification as the date-only
        ///  value, and the result is the difference in days between the resultant
        ///  date and the date-only date.
        ///  If both instances are date-only, the result is the difference in days
        ///  between the two dates, ignoring time zones.
        /// <param> name="other" other date/time
        /// </param></remarks>        <return> number of seconds difference
        /// </return>
        ///         <short>    Returns the number of seconds from this date/time to the <code>other</code> date/time.</short>
        ///         <see> secsTo_long</see>
        ///         <see> addSecs</see>
        ///         <see> daysTo</see>
        public int SecsTo(KDateTime other) {
            return (int) interceptor.Invoke("secsTo#", "secsTo(const KDateTime&) const", typeof(int), typeof(KDateTime), other);
        }
        /// <remarks>
        ///  Returns the number of seconds from this date/time to the <code>other</code> date/time.
        ///  Before performing the comparison, the two date/times are converted to UTC
        ///  to ensure that the result is correct if one of the two date/times has
        ///  daylight saving time (DST) and the other doesn't. The exception is when
        ///  both instances are local clock time, in which case no conversion to UTC
        ///  is done.
        ///  Note that if either instance is a local clock time (type <code>ClockTime</code>),
        ///  the result cannot be guaranteed to be accurate, since by definition they
        ///  contain no information about time zones or daylight savings changes.
        ///  If one instance is date-only and the other is date-time, the date-time
        ///  value is first converted to the same time specification as the date-only
        ///  value, and the result is the difference in days between the resultant
        ///  date and the date-only date.
        ///  If both instances are date-only, the result is the difference in days
        ///  between the two dates, ignoring time zones.
        /// <param> name="other" other date/time
        /// </param></remarks>        <return> number of seconds difference
        /// </return>
        ///         <short>    Returns the number of seconds from this date/time to the <code>other</code> date/time.</short>
        ///         <see> secsTo</see>
        ///         <see> addSecs</see>
        ///         <see> daysTo</see>
        public long SecsTo_long(KDateTime other) {
            return (long) interceptor.Invoke("secsTo_long#", "secsTo_long(const KDateTime&) const", typeof(long), typeof(KDateTime), other);
        }
        /// <remarks>
        ///  Calculates the number of days from this date/time to the <code>other</code> date/time.
        ///  In calculating the result, <code>other</code> is first converted to this instance's
        ///  time zone. The number of days difference is then calculated ignoring
        ///  the time parts of the two date/times. For example, if this date/time
        ///  was 13:00 on 1 January 2000, and <code>other</code> was 02:00 on 2 January 2000,
        ///  the result would be 1.
        ///  Note that if either instance is a local clock time (type <code>ClockTime</code>),
        ///  the result cannot be guaranteed to be accurate, since by definition they
        ///  contain no information about time zones or daylight savings changes.
        ///  If one instance is date-only and the other is date-time, the date-time
        ///  value is first converted to the same time specification as the date-only
        ///  value, and the result is the difference in days between the resultant
        ///  date and the date-only date.
        ///  If both instances are date-only, the calculation ignores time zones.
        /// <param> name="other" other date/time
        /// </param></remarks>        <return> number of days difference
        /// </return>
        ///         <short>    Calculates the number of days from this date/time to the <code>other</code> date/time.</short>
        ///         <see> secsTo</see>
        ///         <see> addDays</see>
        public int DaysTo(KDateTime other) {
            return (int) interceptor.Invoke("daysTo#", "daysTo(const KDateTime&) const", typeof(int), typeof(KDateTime), other);
        }
        /// <remarks>
        ///  Returns the date/time as a string. The <code>format</code> parameter determines the
        ///  format of the result string. The <code>format</code> codes used for the date and time
        ///  components follow those used elsewhere in KDE, and are similar but not
        ///  identical to those used by strftime(3). Conversion specifiers are
        ///  introduced by a '%' character, and are replaced in <code>format</code> as follows:
        ///  <b></b>ate
        ///  - %y   2-digit year excluding century (00 - 99). Conversion is undefined
        ///         if year < 0.
        ///  - %Y   full year number
        ///  - %:m  month number, without leading zero (1 - 12)
        ///  - %m   month number, 2 digits (01 - 12)
        ///  - %b   abbreviated month name in current locale
        ///  - %B   full month name in current locale
        ///  - %:b  abbreviated month name in English (Jan, Feb, ...)
        ///  - %:B  full month name in English
        ///  - %e   day of the month (1 - 31)
        ///  - %d   day of the month, 2 digits (01 - 31)
        ///  - %a   abbreviated weekday name in current locale
        ///  - %A   full weekday name in current locale
        ///  - %:a  abbreviated weekday name in English (Mon, Tue, ...)
        ///  - %:A  full weekday name in English
        ///  <b></b>ime
        ///  - %H   hour in the 24 hour clock, 2 digits (00 - 23)
        ///  - %k   hour in the 24 hour clock, without leading zero (0 - 23)
        ///  - %I   hour in the 12 hour clock, 2 digits (01 - 12)
        ///  - %l   hour in the 12 hour clock, without leading zero (1 - 12)
        ///  - %M   minute, 2 digits (00 - 59)
        ///  - %S   seconds (00 - 59)
        ///  - %:S  seconds preceded with ':', but omitted if seconds value is zero
        ///  - %:s  milliseconds, 3 digits (000 - 999)
        ///  - %P   "am" or "pm" in the current locale, or if undefined there, in English
        ///  - %p   "AM" or "PM" in the current locale, or if undefined there, in English
        ///  - %:P  "am" or "pm"
        ///  - %:p  "AM" or "PM"
        ///  <b></b>ime zone
        ///  - %:u  UTC offset of the time zone in hours, e.g. -02. If the offset
        ///         is not a whole number of hours, the output is the same as for '%U'.
        ///  - %z   UTC offset of the time zone in hours and minutes, e.g. -0200.
        ///  - %:z  UTC offset of the time zone in hours and minutes, e.g. +02:00.
        ///  - %Z   time zone abbreviation, e.g. UTC, EDT, GMT. This is not guaranteed
        ///         to be unique among different time zones. If not applicable (i.e. if
        ///         the instance is type OffsetFromUTC), the UTC offset is substituted.
        ///  - %:Z  time zone name, e.g. Europe/London. This is system dependent. If
        ///         not applicable (i.e. if the instance is type OffsetFromUTC), the
        ///         UTC offset is substituted.
        ///  <b></b>ther
        ///  - %%   literal '%' character
        ///  Note that if the instance has a time specification of ClockTime, the
        ///  time zone or UTC offset in the result will be blank.
        ///  If you want to use the current locale's date format, you should call
        ///  KLocale.FormatDate() to format the date part of the KDateTime.
        /// <param> name="format" format for the string
        /// </param></remarks>        <return> formatted string
        /// </return>
        ///         <short>    Returns the date/time as a string.</short>
        ///         <see> fromString</see>
        ///         <see> KLocale.FormatDate</see>
        public string ToString(string format) {
            return (string) interceptor.Invoke("toString$", "toString(const QString&) const", typeof(string), typeof(string), format);
        }
        /// <remarks>
        ///  Returns the date/time as a string, formatted according to the <code>format</code>
        ///  parameter, with the UTC offset appended.
        ///  Note that if the instance has a time specification of ClockTime, the UTC
        ///  offset in the result will be blank, except for RFC 2822 format in which
        ///  it will be the offset for the local system time zone.
        ///  If the instance is date-only, the time will when <code>format</code> permits be
        ///  omitted from the output string. This applies to <code>format</code> = QtTextDate
        ///  or LocalDate. It also applies to <code>format</code> = ISODate when the instance
        ///  has a time specification of ClockTime. For all other cases, a time of
        ///  00:00:00 will be output.
        ///  For RFC 2822 format, set <code>format</code> to RFCDateDay to include the day
        ///  of the week, or to RFCDate to omit it.
        /// <param> name="format" format for output string
        /// </param></remarks>        <return> formatted string
        /// </return>
        ///         <short>    Returns the date/time as a string, formatted according to the <code>format</code>  parameter, with the UTC offset appended.</short>
        ///         <see> fromString</see>
        ///         <see> QDateTime.ToString</see>
        public string ToString(KDateTime.TimeFormat format) {
            return (string) interceptor.Invoke("toString$", "toString(KDateTime::TimeFormat) const", typeof(string), typeof(KDateTime.TimeFormat), format);
        }
        public new string ToString() {
            return (string) interceptor.Invoke("toString", "toString() const", typeof(string));
        }
        /// <remarks>
        ///  Checks whether the date/time returned by the last call to fromString()
        ///  was invalid because an otherwise valid date was outside the range which
        ///  can be represented by QDate. This status occurs when fromString() read
        ///  a valid string containing a year earlier than -4712 (4713 BC). On exit
        ///  from fromString(), if outOfRange() returns <code>true</code>, isValid() will
        ///  return <code>false.</code>
        /// </remarks>        <return> @c true if date was earlier than -4712, else @c false
        /// </return>
        ///         <short>    Checks whether the date/time returned by the last call to fromString()  was invalid because an otherwise valid date was outside the range which  can be represented by QDate.</short>
        ///         <see> isValid</see>
        ///         <see> fromString</see>
        public bool OutOfRange() {
            return (bool) interceptor.Invoke("outOfRange", "outOfRange() const", typeof(bool));
        }
        /// <remarks>
        ///  Compare this instance with another to determine whether they are
        ///  simultaneous, earlier or later, and in the case of date-only values,
        ///  whether they overlap (i.e. partly coincide but are not wholly
        ///  simultaneous).
        ///  The comparison takes time zones into account: if the two instances have
        ///  different time zones, they are first converted to UTC before comparing.
        ///  If both instances are date/time values, this instance is considered to
        ///  be either simultaneous, earlier or later, and does not overlap.
        ///  If one instance is date-only and the other is a date/time, this instance
        ///  is either strictly earlier, strictly later, or overlaps.
        ///  If both instance are date-only, they are considered simultaneous if both
        ///  their start of day and end of day times are simultaneous with each
        ///  other. (Both start and end of day times need to be considered in case a
        ///  daylight savings change occurs during that day.) Otherwise, this instance
        ///  can be strictly earlier, earlier but overlapping, later but overlapping,
        ///  or strictly later.
        ///  Note that if either instance is a local clock time (type <code>ClockTime</code>),
        ///  the result cannot be guaranteed to be correct, since by definition they
        ///  contain no information about time zones or daylight savings changes.
        /// </remarks>        <return> @c true if the two instances represent the same time, @c false otherwise
        /// </return>
        ///         <short>    Compare this instance with another to determine whether they are  simultaneous, earlier or later, and in the case of date-only values,  whether they overlap (i.</short>
        ///         <see> operator==</see>
        ///         <see> operator!=</see>
        ///         <see> operator<</see>
        ///         <see> operator<=</see>
        ///         <see> operator>=</see>
        ///         <see> operator></see>
        public KDateTime.Comparison Compare(KDateTime other) {
            return (KDateTime.Comparison) interceptor.Invoke("compare#", "compare(const KDateTime&) const", typeof(KDateTime.Comparison), typeof(KDateTime), other);
        }
        /// <remarks>
        ///  Check whether this date/time is simultaneous with another.
        ///  The comparison takes time zones into account: if the two instances have
        ///  different time zones, they are first converted to UTC before comparing.
        ///  Note that if either instance is a local clock time (type <code>ClockTime</code>),
        ///  the result cannot be guaranteed to be correct, since by definition they
        ///  contain no information about time zones or daylight savings changes.
        ///  If both instances are date-only, they are considered simultaneous if both
        ///  their start of day and end of day times are simultaneous with each
        ///  other. (Both start and end of day times need to be considered in case a
        ///  daylight saving change occurs during that day.)
        /// </remarks>        <return> @c true if the two instances represent the same time, @c false otherwise
        /// </return>
        ///         <short>    Check whether this date/time is simultaneous with another.</short>
        ///         <see> compare</see>
        public override bool Equals(object o) {
            if (!(o is KDateTime)) { return false; }
            return this == (KDateTime) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        /// <remarks>
        ///  Check whether this date/time is earlier than another.
        ///  The comparison takes time zones into account: if the two instances have
        ///  different time zones, they are first converted to UTC before comparing.
        ///  Note that if either instance is a local clock time (type <code>ClockTime</code>),
        ///  the result cannot be guaranteed to be correct, since by definition they
        ///  contain no information about time zones or daylight savings changes.
        ///  If one or both instances are date-only, the comparison returns true if
        ///  this date/time or day, falls wholly before the other date/time or
        ///  day. To achieve this, the time used in the comparison is the end of day
        ///  (if this instance is date-only) or the start of day (if the other
        ///  instance is date-only).
        /// </remarks>        <return> @c true if this instance represents an earlier time than <code>other</code>,
        ///          @c false otherwise
        /// </return>
        ///         <short>    Check whether this date/time is earlier than another.</short>
        ///         <see> compare</see>
        /// <remarks>
        ///  Create a separate copy of this instance's data if it is implicitly shared
        ///  with another instance.
        ///  You would normally only call this if you want different copies of the
        ///  same date/time value to cache conversions to different time zones. Because
        ///  only the last conversion to another time zone is cached, and the cached
        ///  value is implicitly shared, judicious use of detach() could improve
        ///  efficiency when handling several time zones. But take care: if used
        ///  inappropriately, it will reduce efficiency!
        ///      </remarks>        <short>    Create a separate copy of this instance's data if it is implicitly shared  with another instance.</short>
        public void Detach() {
            interceptor.Invoke("detach", "detach()", typeof(void));
        }
        ~KDateTime() {
            interceptor.Invoke("~KDateTime", "~KDateTime()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KDateTime", "~KDateTime()", typeof(void));
        }
        public static bool operator==(KDateTime lhs, KDateTime other) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KDateTime&) const", typeof(bool), typeof(KDateTime), lhs, typeof(KDateTime), other);
        }
        public static bool operator!=(KDateTime lhs, KDateTime other) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KDateTime&) const", typeof(bool), typeof(KDateTime), lhs, typeof(KDateTime), other);
        }
        public static bool operator<(KDateTime lhs, KDateTime other) {
            return (bool) staticInterceptor.Invoke("operator<#", "operator<(const KDateTime&) const", typeof(bool), typeof(KDateTime), lhs, typeof(KDateTime), other);
        }
        public static bool operator<=(KDateTime lhs, KDateTime other) {
            return (bool) staticInterceptor.Invoke("operator<=#", "operator<=(const KDateTime&) const", typeof(bool), typeof(KDateTime), lhs, typeof(KDateTime), other);
        }
        public static bool operator>(KDateTime lhs, KDateTime other) {
            return (bool) staticInterceptor.Invoke("operator>#", "operator>(const KDateTime&) const", typeof(bool), typeof(KDateTime), lhs, typeof(KDateTime), other);
        }
        public static bool operator>=(KDateTime lhs, KDateTime other) {
            return (bool) staticInterceptor.Invoke("operator>=#", "operator>=(const KDateTime&) const", typeof(bool), typeof(KDateTime), lhs, typeof(KDateTime), other);
        }
        /// <remarks>
        ///  Returns the current date and time, as reported by the system clock,
        ///  expressed in the local system time zone.
        /// </remarks>        <return> current date/time
        /// </return>
        ///         <short>    Returns the current date and time, as reported by the system clock,  expressed in the local system time zone.</short>
        ///         <see> currentUtcDateTime</see>
        ///         <see> currentDateTime</see>
        public static KDateTime CurrentLocalDateTime() {
            return (KDateTime) staticInterceptor.Invoke("currentLocalDateTime", "currentLocalDateTime()", typeof(KDateTime));
        }
        /// <remarks>
        ///  Returns the current date and time, as reported by the system clock,
        ///  expressed in UTC.
        /// </remarks>        <return> current date/time
        /// </return>
        ///         <short>    Returns the current date and time, as reported by the system clock,  expressed in UTC.</short>
        ///         <see> currentLocalDateTime</see>
        ///         <see> currentDateTime</see>
        public static KDateTime CurrentUtcDateTime() {
            return (KDateTime) staticInterceptor.Invoke("currentUtcDateTime", "currentUtcDateTime()", typeof(KDateTime));
        }
        /// <remarks>
        ///  Returns the current date and time, as reported by the system clock,
        ///  expressed in a given time specification.
        /// <param> name="spec" time specification
        /// </param></remarks>        <return> current date/time
        /// </return>
        ///         <short>    Returns the current date and time, as reported by the system clock,  expressed in a given time specification.</short>
        ///         <see> currentUtcDateTime</see>
        ///         <see> currentLocalDateTime</see>
        /// <remarks>
        ///  Returns the KDateTime represented by <code>string</code>, using the <code>format</code> given.
        ///  This method is the inverse of <see cref="#toString"></see>, except that it can
        ///  only return a time specification of UTC, OffsetFromUTC or ClockTime. An
        ///  actual named time zone cannot be returned since an offset from UTC only
        ///  partially specifies a time zone.
        ///  The time specification of the result is determined by the UTC offset
        ///  present in the string:
        ///  - if the UTC offset is zero the result is type <code>UTC.</code>
        ///  - if the UTC offset is non-zero, the result is type <code>OffsetFromUTC.</code>
        ///  - if there is no UTC offset, the result is by default type
        ///    <code>ClockTime.</code> You can use setFromStringDefault() to change this default.
        ///  If no time is found in <code>string</code>, a date-only value is returned, except
        ///  when the specified <code>format</code> does not permit the time to be omitted, in
        ///  which case an error is returned. An error is therefore returned for
        ///  ISODate when <code>string</code> includes a time zone specification, and for
        ///  RFCDate in all cases.
        ///  For RFC format strings, you should normally set <code>format</code> to
        ///  RFCDate. Only set it to RFCDateDay if you want to return an error
        ///  when the day of the week is omitted.
        ///  For <code>format</code> = ISODate or RFCDate[Day], if an invalid KDateTime is
        ///  returned, you can check why <code>format</code> was considered invalid by use of
        ///  outOfRange(). If that method returns true, it indicates that <code>format</code>
        ///  was in fact valid, but the date lies outside the range which can be
        ///  represented by QDate.
        /// <param> name="string" string to convert
        /// </param><param> name="format" format code. LocalDate cannot be used here.
        /// </param><param> name="negZero" if non-null, the value is set to true if a UTC offset of
        ///                 '-0000' is found or, for RFC 2822 format, an unrecognised
        ///                 or invalid time zone abbreviation is found, else false.
        /// </param></remarks>        <return> KDateTime value, or an invalid KDateTime if either parameter is invalid
        /// </return>
        ///         <short>    Returns the KDateTime represented by <code>string</code>, using the <code>format</code> given.</short>
        ///         <see> setFromStringDefault</see>
        ///         <see> toString</see>
        ///         <see> outOfRange</see>
        public static KDateTime FromString(string arg1, KDateTime.TimeFormat format, ref bool negZero) {
            StackItem[] stack = new StackItem[4];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(arg1);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(arg1);
#endif
            stack[2].s_int = (int) format;
            stack[3].s_bool = negZero;
            staticInterceptor.Invoke("fromString$$$", "fromString(const QString&, KDateTime::TimeFormat, bool*)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).Free();
#endif
            negZero = stack[3].s_bool;
            object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
            ((GCHandle) stack[0].s_class).Free();
#endif
            return (KDateTime) returnValue;
        }
        public static KDateTime FromString(string arg1, KDateTime.TimeFormat format) {
            return (KDateTime) staticInterceptor.Invoke("fromString$$", "fromString(const QString&, KDateTime::TimeFormat)", typeof(KDateTime), typeof(string), arg1, typeof(KDateTime.TimeFormat), format);
        }
        public static KDateTime FromString(string arg1) {
            return (KDateTime) staticInterceptor.Invoke("fromString$", "fromString(const QString&)", typeof(KDateTime), typeof(string), arg1);
        }
        /// <remarks>
        ///  Returns the KDateTime represented by <code>string</code>, using the <code>format</code>
        ///  given, optionally using a time zone collection <code>zones</code> as the source of
        ///  time zone definitions. The <code>format</code> codes are basically the same as
        ///  those for toString(), and are similar but not identical to those used by
        ///  strftime(3).
        ///  The <code>format</code> string consists of the same codes as that for
        ///  toString(). However, some codes which are distinct in toString() have
        ///  the same function as each other here.
        ///  Numeric values without a stated number of digits permit, but do not
        ///  require, leading zeroes. The maximum number of digits consumed by a
        ///  numeric code is the minimum needed to cover the possible range of the
        ///  number (e.g. for minutes, the range is 0 - 59, so the maximum number of
        ///  digits consumed is 2). All non-numeric values are case insensitive.
        ///  <b></b>ate
        ///  - %y   year excluding century (0 - 99). Years 0 - 50 return 2000 - 2050,
        ///         while years 51 - 99 return 1951 - 1999.
        ///  - %Y   full year number (4 digits with optional sign)
        ///  - %:Y  full year number (>= 4 digits with optional sign)
        ///  - %:m  month number (1 - 12)
        ///  - %m   month number, 2 digits (01 - 12)
        ///  - %b
        ///  - %B   month name in the current locale or, if no match, in English,
        ///         abbreviated or in full
        ///  - %:b
        ///  - %:B  month name in English, abbreviated or in full
        ///  - %e   day of the month (1 - 31)
        ///  - %d   day of the month, 2 digits (01 - 31)
        ///  - %a
        ///  - %A   weekday name in the current locale or, if no match, in English,
        ///         abbreviated or in full
        ///  - %:a
        ///  - %:A  weekday name in English, abbreviated or in full
        ///  <b></b>ime
        ///  - %H   hour in the 24 hour clock, 2 digits (00 - 23)
        ///  - %k   hour in the 24 hour clock (0 - 23)
        ///  - %I   hour in the 12 hour clock, 2 digits (01 - 12)
        ///  - %l   hour in the 12 hour clock (1 - 12)
        ///  - %M   minute, 2 digits (00 - 59)
        ///  - %:M  minute (0 - 59)
        ///  - %S   seconds, 2 digits (00 - 59)
        ///  - %s   seconds (0 - 59)
        ///  - %:S  optional seconds value (0 - 59) preceded with ':'. If no colon is
        ///         found in <code>string</code>, no input is consumed and the seconds value is
        ///         set to zero.
        ///  - %:s  fractional seconds value, preceded with a decimal point (either '.'
        ///         or the locale's decimal point symbol)
        ///  - %P
        ///  - %p   "am" or "pm", in the current locale or, if no match, in
        ///         English. This format is only useful when used with %I or %l.
        ///  - %:P
        ///  - %:p  "am" or "pm" in English. This format is only useful when used with
        ///         %I or %l.
        ///  <b></b>ime zone
        ///  - %:u
        ///  - %z   UTC offset of the time zone in hours and optionally minutes,
        ///         e.g. -02, -0200.
        ///  - %:z  UTC offset of the time zone in hours and minutes, colon separated,
        ///         e.g. +02:00.
        ///  - %Z   time zone abbreviation, consisting of alphanumeric characters,
        ///         e.g. UTC, EDT, GMT.
        ///  - %:Z  time zone name, e.g. Europe/London. The name may contain any
        ///         characters and is delimited by the following character in the
        ///         <code>format</code> string. It will not work if you follow %:Z with another
        ///         escape sequence (except %% or %t).
        ///  <b></b>ther
        ///  - %t   matches one or more whitespace characters
        ///  - %%   literal '%' character
        ///  Any other character must have a matching character in <code>string</code>, except
        ///  that a space will match zero or more whitespace characters in the input
        ///  string.
        ///  If any time zone information is present in the string, the function
        ///  attempts to find a matching time zone in the <code>zones</code> collection. A time
        ///  zone name (format code %:Z) will provide an unambiguous look up in
        ///  <code>zones.</code> Any other type of time zone information (an abbreviated time
        ///  zone code (%Z) or UTC offset (%z, %:z, %:u) is searched for in <code>zones</code>
        ///  and if only one time zone is found to match, the result is set to that
        ///  zone. Otherwise:
        ///  - If more than one match of a UTC offset is found, the action taken is
        ///    determined by <code>offsetIfAmbiguous</code>: if <code>offsetIfAmbiguous</code> is true,
        ///    a local time with an offset from UTC (type <code>OffsetFromUTC</code>) will be
        ///    returned; if false an invalid KDateTime is returned.
        ///  - If more than one match of a time zone abbreviation is found, the UTC
        ///    offset for each matching time zone is compared and, if the offsets are
        ///    the same, a local time with an offset from UTC (type <code>OffsetFromUTC</code>)
        ///    will be returned provided that <code>offsetIfAmbiguous</code> is true. Otherwise
        ///    an invalid KDateTime is returned.
        ///  - If a time zone abbreviation does not match any time zone in <code>zones</code>,
        ///    or the abbreviation does not apply at the parsed date/time, an
        ///    invalid KDateTime is returned.
        ///  - If a time zone name does not match any time zone in <code>zones</code>, an
        ///    invalid KDateTime is returned.
        ///  - If the time zone UTC offset does not match any time zone in <code>zones</code>,
        ///    a local time with an offset from UTC (type <code>OffsetFromUTC</code>) is
        ///    returned.
        ///  If <code>format</code> contains more than one time zone or UTC offset code, an
        ///  error is returned.
        ///  If no time zone information is present in the string, by default a local
        ///  clock time (type <code>ClockTime</code>) is returned. You can use
        ///  setFromStringDefault() to change this default.
        ///  If no time is found in <code>string</code>, a date-only value is returned.
        ///  If any inconsistencies are found, i.e. the same item of information
        ///  appears more than once but with different values, the weekday name does
        ///  not tally with the date, an invalid KDateTime is returned.
        ///  If an invalid KDateTime is returned, you can check why <code>format</code> was
        ///  considered invalid by use of outOfRange(). If that method returns true,
        ///  it indicates that <code>format</code> was in fact valid, but the date lies outside
        ///  the range which can be represented by QDate.
        /// <param> name="string" string to convert
        /// </param><param> name="format" format string
        /// </param><param> name="zones" time zone collection, or null for none
        /// </param><param> name="offsetIfAmbiguous" specifies what to do if more than one zone
        ///                           matches the UTC offset found in the
        ///                           string. Ignored if <code>zones</code> is null.
        /// </param></remarks>        <return> KDateTime value, or an invalid KDateTime if an error occurs, if
        ///          time zone information doesn't match any in <code>zones</code>, or if the
        ///          time zone information is ambiguous and <code>offsetIfAmbiguous</code> is
        ///          false
        /// </return>
        ///         <short>    Returns the KDateTime represented by <code>string</code>, using the <code>format</code>  given, optionally using a time zone collection <code>zones</code> as the source of  time zone definitions.</short>
        ///         <see> setFromStringDefault</see>
        ///         <see> toString</see>
        ///         <see> outOfRange</see>
        public static KDateTime FromString(string arg1, string format, KTimeZones zones, bool offsetIfAmbiguous) {
            return (KDateTime) staticInterceptor.Invoke("fromString$$#$", "fromString(const QString&, const QString&, const KTimeZones*, bool)", typeof(KDateTime), typeof(string), arg1, typeof(string), format, typeof(KTimeZones), zones, typeof(bool), offsetIfAmbiguous);
        }
        public static KDateTime FromString(string arg1, string format, KTimeZones zones) {
            return (KDateTime) staticInterceptor.Invoke("fromString$$#", "fromString(const QString&, const QString&, const KTimeZones*)", typeof(KDateTime), typeof(string), arg1, typeof(string), format, typeof(KTimeZones), zones);
        }
        public static KDateTime FromString(string arg1, string format) {
            return (KDateTime) staticInterceptor.Invoke("fromString$$", "fromString(const QString&, const QString&)", typeof(KDateTime), typeof(string), arg1, typeof(string), format);
        }
        /// <remarks>
        ///  Sets the default time specification for use by fromString() when no time
        ///  zone or UTC offset is found in the string being parsed, or when "-0000"
        ///  is found in an RFC 2822 string.
        ///  By default, fromString() returns a local clock time (type <code>ClockTime</code>)
        ///  when no definite zone or UTC offset is found. You can use this method
        ///  to make it return the local time zone, UTC, or whatever you wish.
        /// <param> name="spec" the new default time specification
        /// </param></remarks>        <short>    Sets the default time specification for use by fromString() when no time  zone or UTC offset is found in the string being parsed, or when "-0000"  is found in an RFC 2822 string.</short>
        ///         <see> fromString</see>
    }
}
