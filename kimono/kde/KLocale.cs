//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Collections.Generic;
    /// <remarks>
    ///  KLocale provides support for country specific stuff like
    ///  the national language.
    ///  KLocale supports translating, as well as specifying the format
    ///  for numbers, currency, time, and date.
    ///  Use KGlobal.Locale() to get pointer to the global KLocale object,
    ///  containing the applications current locale settings.
    ///  For example, to format the date May 17, 1995 in the current locale, use:
    ///  <pre>
    ///    string date = KGlobal.Locale().FormatDate(QDate(1995,5,17));
    ///  </pre>
    /// </remarks>        <author> Stephan Kulow <coolo@kde.org>, Preston Brown <pbrown@kde.org>,
    ///  Hans Petter Bieker <bieker@kde.org>, Lukas Tinkl <lukas.tinkl@suse.cz>
    /// </author>
    ///         <short> class for supporting locale settings and national language.</short>
    [SmokeClass("KLocale")]
    public class KLocale : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KLocale(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KLocale), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KLocale() {
            staticInterceptor = new SmokeInvocation(typeof(KLocale), null);
        }
        /// <remarks>
        ///  Various positions for where to place the positive or negative
        ///  sign when they are related to a monetary value.
        ///    </remarks>        <short>    Various positions for where to place the positive or negative  sign when they are related to a monetary value.</short>
        public enum SignPosition {
            ParensAround = 0,
            BeforeQuantityMoney = 1,
            AfterQuantityMoney = 2,
            BeforeMoney = 3,
            AfterMoney = 4,
        }
        /// <remarks>
        ///  Format for date string.
        ///    </remarks>        <short>    Format for date string.</short>
        public enum DateFormat {
            ShortDate = 0,
            LongDate = 1,
            FancyShortDate = 2,
            FancyLongDate = 3,
        }
        /// <remarks>
        ///  Options for formatting date-time values.
        ///    </remarks>        <short>    Options for formatting date-time values.</short>
        public enum DateTimeFormatOption {
            TimeZone = 0x01,
            Seconds = 0x02,
        }
        /// <remarks>
        ///  Flags for readDate()
        ///    </remarks>        <short>    Flags for readDate()    </short>
        public enum ReadDateFlags {
            NormalFormat = 1,
            ShortFormat = 2,
        }
        /// <remarks>
        ///  Flags for readTime()
        ///    </remarks>        <short>    Flags for readTime()    </short>
        public enum ReadTimeFlags {
            WithSeconds = 0,
            WithoutSeconds = 1,
        }
        /// <remarks>
        ///  The Metric system will give you information in mm, while the
        ///  Imperial system will give you information in inches.
        ///    </remarks>        <short>    The Metric system will give you information in mm, while the  Imperial system will give you information in inches.</short>
        public enum MeasureSystem {
            Metric = 0,
            Imperial = 1,
        }
        /// <remarks>
        ///  Constructs a KLocale with the given catalog name.
        ///  The constructor looks for an entry Locale/Language in the
        ///  configuration file.
        ///  If no config file is specified, it will also look for languages
        ///  using the environment variables (KDE_LANG, LC_MESSAGES, LC_ALL, LANG),
        ///  as well as the global configuration file. If KLocale is not able to use
        ///  any of the specified languages, the default language (en_US) will be
        ///  used.
        ///  If you specify a configuration file, it has to be valid until
        ///  the KLocale object is destroyed.
        /// <param> name="catalog" The name of the main language file
        /// </param><param> name="config" The configuration file to use.
        ///    </param></remarks>        <short>    Constructs a KLocale with the given catalog name.</short>
        public KLocale(string catalog, KSharedConfig config) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KLocale$?", "KLocale(const QString&, KSharedPtr<KSharedConfig>)", typeof(void), typeof(string), catalog, typeof(KSharedConfig), config);
        }
        public KLocale(string catalog) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KLocale$", "KLocale(const QString&)", typeof(void), typeof(string), catalog);
        }
        public KLocale(string catalog, string language, string country, KConfig config) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KLocale$$$#", "KLocale(const QString&, const QString&, const QString&, KConfig*)", typeof(void), typeof(string), catalog, typeof(string), language, typeof(string), country, typeof(KConfig), config);
        }
        public KLocale(string catalog, string language, string country) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KLocale$$$", "KLocale(const QString&, const QString&, const QString&)", typeof(void), typeof(string), catalog, typeof(string), language, typeof(string), country);
        }
        public KLocale(string catalog, string language) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KLocale$$", "KLocale(const QString&, const QString&)", typeof(void), typeof(string), catalog, typeof(string), language);
        }
        /// <remarks>
        ///  Copy constructor.
        ///    </remarks>        <short>    Copy constructor.</short>
        public KLocale(KLocale rhs) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KLocale#", "KLocale(const KLocale&)", typeof(void), typeof(KLocale), rhs);
        }
        /// <remarks>
        ///  Raw translation from message catalogs.
        ///  Never use this directly to get message translations. See i18n and ki18n
        ///  calls related to KLocalizedString.
        /// <param> name="msg" the message. Must not be null. Must be UTF-8 encoded.
        /// </param><param> name="lang" language in which the translation was found. If no translation
        ///              was found, KLocale.DefaultLanguage() is reported. If null,
        ///              the language is not reported.
        /// </param><param> name="trans" raw translation, or original if not found. If no translation
        ///               was found, original message is reported. If null, the
        ///               translation is not reported.
        /// </param></remarks>        <short>    Raw translation from message catalogs.</short>
        ///         <see> KLocalizedString</see>
        public void TranslateRaw(string msg, StringBuilder lang, StringBuilder trans) {
            interceptor.Invoke("translateRaw$$$", "translateRaw(const char*, QString*, QString*) const", typeof(void), typeof(string), msg, typeof(StringBuilder), lang, typeof(StringBuilder), trans);
        }
        /// <remarks>
        ///  Raw translation from message catalogs, with given context.
        ///  Context + message are used as the lookup key in catalogs.
        ///  Never use this directly to get message translations. See i18n and ki18n
        ///  calls related to KLocalizedString.
        /// <param> name="ctxt" the context. Must not be null. Must be UTF-8 encoded.
        /// </param><param> name="msg" the message. Must not be null. Must be UTF-8 encoded.
        /// </param><param> name="lang" language in which the translation was found. If no translation
        ///              was found, KLocale.DefaultLanguage() is reported. If null,
        ///              the language is not reported.
        /// </param><param> name="trans" raw translation, or original if not found. If no translation
        ///               was found, original message is reported. If null, the
        ///               translation is not reported.
        /// </param></remarks>        <short>    Raw translation from message catalogs, with given context.</short>
        ///         <see> KLocalizedString</see>
        public void TranslateRaw(string ctxt, string msg, StringBuilder lang, StringBuilder trans) {
            interceptor.Invoke("translateRaw$$$$", "translateRaw(const char*, const char*, QString*, QString*) const", typeof(void), typeof(string), ctxt, typeof(string), msg, typeof(StringBuilder), lang, typeof(StringBuilder), trans);
        }
        /// <remarks>
        ///  Raw translation from message catalogs, with given singular/plural form.
        ///  Singular form is used as the lookup key in catalogs.
        ///  Never use this directly to get message translations. See i18n and ki18n
        ///  calls related to KLocalizedString.
        /// <param> name="singular" the singular form. Must not be null. Must be UTF-8 encoded.
        /// </param><param> name="plural" the plural form. Must not be null. Must be UTF-8 encoded.
        /// </param><param> name="n" number on which the forms are decided.
        /// </param><param> name="lang" language in which the translation was found. If no translation
        ///              was found, KLocale.DefaultLanguage() is reported. If null,
        ///              the language is not reported.
        /// </param><param> name="trans" raw translation, or original if not found. If no translation
        ///               was found, original message is reported (either plural or
        ///               singular, as determined by <code>n</code> ). If null, the
        ///               translation is not reported.
        /// </param></remarks>        <short>    Raw translation from message catalogs, with given singular/plural form.</short>
        ///         <see> KLocalizedString</see>
        public void TranslateRaw(string singular, string plural, ulong n, StringBuilder lang, StringBuilder trans) {
            interceptor.Invoke("translateRaw$$$$$", "translateRaw(const char*, const char*, unsigned long, QString*, QString*) const", typeof(void), typeof(string), singular, typeof(string), plural, typeof(ulong), n, typeof(StringBuilder), lang, typeof(StringBuilder), trans);
        }
        /// <remarks>
        ///  Raw translation from message catalogs, with given context and
        ///  singular/plural form.
        ///  Context + singular form is used as the lookup key in catalogs.
        ///  Never use this directly to get message translations. See i18n and ki18n
        ///  calls related to KLocalizedString.
        /// <param> name="ctxt" the context. Must not be null. Must be UTF-8 encoded.
        /// </param><param> name="singular" the singular form. Must not be null. Must be UTF-8 encoded.
        /// </param><param> name="plural" the plural form. Must not be null. Must be UTF-8 encoded.
        /// </param><param> name="n" number on which the forms are decided.
        /// </param><param> name="lang" language in which the translation was found. If no translation
        ///              was found, KLocale.DefaultLanguage() is reported. If null,
        ///              the language is not reported.
        /// </param><param> name="trans" raw translation, or original if not found. If no translation
        ///               was found, original message is reported (either plural or
        ///               singular, as determined by <code>n</code> ). If null, the
        ///               translation is not reported.
        /// </param></remarks>        <short>    Raw translation from message catalogs, with given context and  singular/plural form.</short>
        ///         <see> KLocalizedString</see>
        public void TranslateRaw(string ctxt, string singular, string plural, ulong n, StringBuilder lang, StringBuilder trans) {
            interceptor.Invoke("translateRaw$$$$$$", "translateRaw(const char*, const char*, const char*, unsigned long, QString*, QString*) const", typeof(void), typeof(string), ctxt, typeof(string), singular, typeof(string), plural, typeof(ulong), n, typeof(StringBuilder), lang, typeof(StringBuilder), trans);
        }
        /// <remarks>
        ///  Changes the current encoding.
        /// <param> name="mibEnum" The mib of the preferred codec
        /// </param></remarks>        <return> True on success.
        ///    </return>
        ///         <short>    Changes the current encoding.</short>
        public bool SetEncoding(int mibEnum) {
            return (bool) interceptor.Invoke("setEncoding$", "setEncoding(int)", typeof(bool), typeof(int), mibEnum);
        }
        /// <remarks>
        ///  Returns what a decimal point should look like ("." or "," etc.)
        ///  according to the current locale or user settings.
        /// </remarks>        <return> The decimal symbol used by locale.
        ///    </return>
        ///         <short>    Returns what a decimal point should look like (".</short>
        public string DecimalSymbol() {
            return (string) interceptor.Invoke("decimalSymbol", "decimalSymbol() const", typeof(string));
        }
        /// <remarks>
        ///  Returns what the thousands separator should look
        ///  like ("," or "." etc.)
        ///  according to the current locale or user settings.
        /// </remarks>        <return> The thousands separator used by locale.
        ///    </return>
        ///         <short>    Returns what the thousands separator should look  like ("," or ".</short>
        public string ThousandsSeparator() {
            return (string) interceptor.Invoke("thousandsSeparator", "thousandsSeparator() const", typeof(string));
        }
        /// <remarks>
        ///  Returns what the symbol denoting currency in the current locale
        ///  as as defined by user settings should look like.
        /// </remarks>        <return> The default currency symbol used by locale.
        ///    </return>
        ///         <short>    Returns what the symbol denoting currency in the current locale  as as defined by user settings should look like.</short>
        public string CurrencySymbol() {
            return (string) interceptor.Invoke("currencySymbol", "currencySymbol() const", typeof(string));
        }
        /// <remarks>
        ///  Returns what a decimal point should look like ("." or "," etc.)
        ///  for monetary values, according to the current locale or user
        ///  settings.
        /// </remarks>        <return> The monetary decimal symbol used by locale.
        ///    </return>
        ///         <short>    Returns what a decimal point should look like (".</short>
        public string MonetaryDecimalSymbol() {
            return (string) interceptor.Invoke("monetaryDecimalSymbol", "monetaryDecimalSymbol() const", typeof(string));
        }
        /// <remarks>
        ///  Returns what a thousands separator for monetary values should
        ///  look like ("," or " " etc.) according to the current locale or
        ///  user settings.
        /// </remarks>        <return> The monetary thousands separator used by locale.
        ///    </return>
        ///         <short>    Returns what a thousands separator for monetary values should  look like ("," or " " etc.</short>
        public string MonetaryThousandsSeparator() {
            return (string) interceptor.Invoke("monetaryThousandsSeparator", "monetaryThousandsSeparator() const", typeof(string));
        }
        /// <remarks>
        ///  Returns what a positive sign should look like ("+", " ", etc.)
        ///  according to the current locale or user settings.
        /// </remarks>        <return> The positive sign used by locale.
        ///    </return>
        ///         <short>    Returns what a positive sign should look like ("+", " ", etc.</short>
        public string PositiveSign() {
            return (string) interceptor.Invoke("positiveSign", "positiveSign() const", typeof(string));
        }
        /// <remarks>
        ///  Returns what a negative sign should look like ("-", etc.)
        ///  according to the current locale or user settings.
        /// </remarks>        <return> The negative sign used by locale.
        ///    </return>
        ///         <short>    Returns what a negative sign should look like ("-", etc.</short>
        public string NegativeSign() {
            return (string) interceptor.Invoke("negativeSign", "negativeSign() const", typeof(string));
        }
        /// <remarks>
        ///  The number of fractional digits to include in numeric/monetary
        ///  values (usually 2).
        /// </remarks>        <return> Default number of fractional digits used by locale.
        ///    </return>
        ///         <short>    The number of fractional digits to include in numeric/monetary  values (usually 2).</short>
        public int FracDigits() {
            return (int) interceptor.Invoke("fracDigits", "fracDigits() const", typeof(int));
        }
        /// <remarks>
        ///  If and only if the currency symbol precedes a positive value,
        ///  this will be true.
        /// </remarks>        <return> Where to print the currency symbol for positive numbers.
        ///    </return>
        ///         <short>    If and only if the currency symbol precedes a positive value,  this will be true.</short>
        public bool PositivePrefixCurrencySymbol() {
            return (bool) interceptor.Invoke("positivePrefixCurrencySymbol", "positivePrefixCurrencySymbol() const", typeof(bool));
        }
        /// <remarks>
        ///  If and only if the currency symbol precedes a negative value,
        ///  this will be true.
        /// </remarks>        <return> True if the currency symbol precedes negative numbers.
        ///    </return>
        ///         <short>    If and only if the currency symbol precedes a negative value,  this will be true.</short>
        public bool NegativePrefixCurrencySymbol() {
            return (bool) interceptor.Invoke("negativePrefixCurrencySymbol", "negativePrefixCurrencySymbol() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns the position of a positive sign in relation to a
        ///  monetary value.
        /// </remarks>        <return> Where/how to print the positive sign.
        /// </return>
        ///         <short>    Returns the position of a positive sign in relation to a  monetary value.</short>
        ///         <see> SignPosition</see>
        public KLocale.SignPosition PositiveMonetarySignPosition() {
            return (KLocale.SignPosition) interceptor.Invoke("positiveMonetarySignPosition", "positiveMonetarySignPosition() const", typeof(KLocale.SignPosition));
        }
        /// <remarks>
        ///  Denotes where to place a negative sign in relation to a
        ///  monetary value.
        /// </remarks>        <return> Where/how to print the negative sign.
        /// </return>
        ///         <short>    Denotes where to place a negative sign in relation to a  monetary value.</short>
        ///         <see> SignPosition</see>
        public KLocale.SignPosition NegativeMonetarySignPosition() {
            return (KLocale.SignPosition) interceptor.Invoke("negativeMonetarySignPosition", "negativeMonetarySignPosition() const", typeof(KLocale.SignPosition));
        }
        /// <remarks>
        ///  Given a double, converts that to a numeric string containing
        ///  the localized monetary equivalent.
        ///  e.g. given 123456, return "$ 123,456.00".
        /// <param> name="num" The number we want to format
        /// </param><param> name="currency" The currency symbol you want.
        /// </param><param> name="digits" Number of fractional digits, or -1 for the default
        ///                value
        /// </param></remarks>        <return> The number of money as a localized string
        /// </return>
        ///         <short>    Given a double, converts that to a numeric string containing  the localized monetary equivalent.</short>
        ///         <see> fracDigits</see>
        public string FormatMoney(double num, string currency, int digits) {
            return (string) interceptor.Invoke("formatMoney$$$", "formatMoney(double, const QString&, int) const", typeof(string), typeof(double), num, typeof(string), currency, typeof(int), digits);
        }
        public string FormatMoney(double num, string currency) {
            return (string) interceptor.Invoke("formatMoney$$", "formatMoney(double, const QString&) const", typeof(string), typeof(double), num, typeof(string), currency);
        }
        public string FormatMoney(double num) {
            return (string) interceptor.Invoke("formatMoney$", "formatMoney(double) const", typeof(string), typeof(double), num);
        }
        /// <remarks>
        ///  Given a double, converts that to a numeric string containing
        ///  the localized numeric equivalent.
        ///  e.g. given 123456.78F, return "123,456.78" (for some European country).
        ///  If precision isn't specified, 2 is used.
        ///  This function is a wrapper that is provided for convenience.
        /// <param> name="num" The number to convert
        /// </param><param> name="precision" Number of fractional digits used.
        /// </param></remarks>        <return> The number as a localized string
        /// </return>
        ///         <short>    Given a double, converts that to a numeric string containing  the localized numeric equivalent.</short>
        ///         <see> formatNumber(const</see>
        ///         <see> bool</see>
        ///         <see> int)</see>
        public string FormatNumber(double num, int precision) {
            return (string) interceptor.Invoke("formatNumber$$", "formatNumber(double, int) const", typeof(string), typeof(double), num, typeof(int), precision);
        }
        public string FormatNumber(double num) {
            return (string) interceptor.Invoke("formatNumber$", "formatNumber(double) const", typeof(string), typeof(double), num);
        }
        /// <remarks>
        ///  Given a string representing a number, converts that to a numeric
        ///  string containing the localized numeric equivalent.
        ///  e.g. given 123456.78F, return "123,456.78" (for some European country).
        /// <param> name="numStr" The number to format, as a string.
        /// </param><param> name="round" Round fractional digits. (default true)
        /// </param><param> name="precision" Number of fractional digits used for rounding. Unused if round=false. (default 2)
        /// </param></remarks>        <return> The number as a localized string
        ///    </return>
        ///         <short>    Given a string representing a number, converts that to a numeric  string containing the localized numeric equivalent.</short>
        public string FormatNumber(string numStr, bool round, int precision) {
            return (string) interceptor.Invoke("formatNumber$$$", "formatNumber(const QString&, bool, int) const", typeof(string), typeof(string), numStr, typeof(bool), round, typeof(int), precision);
        }
        public string FormatNumber(string numStr, bool round) {
            return (string) interceptor.Invoke("formatNumber$$", "formatNumber(const QString&, bool) const", typeof(string), typeof(string), numStr, typeof(bool), round);
        }
        public string FormatNumber(string numStr) {
            return (string) interceptor.Invoke("formatNumber$", "formatNumber(const QString&) const", typeof(string), typeof(string), numStr);
        }
        /// <remarks>
        ///  Given an integer, converts that to a numeric string containing
        ///  the localized numeric equivalent.
        ///  e.g. given 123456L, return "123,456" (for some European country).
        /// <param> name="num" The number to convert
        /// </param></remarks>        <return> The number as a localized string
        ///    </return>
        ///         <short>    Given an integer, converts that to a numeric string containing  the localized numeric equivalent.</short>
        public string FormatLong(long num) {
            return (string) interceptor.Invoke("formatLong$", "formatLong(long) const", typeof(string), typeof(long), num);
        }
        /// <remarks>
        ///  Converts <code>size</code> from bytes to the string representation using the
        ///  IEC 60027-2 standard
        ///  Example:
        ///  formatByteSize(1024) returns "1.0 KiB"
        /// <param> name="size" size in bytes
        /// </param></remarks>        <return> converted size as a string - e.g. 123.4 KiB , 12.0 MiB
        ///    </return>
        ///         <short>    Converts <code>size</code> from bytes to the string representation using the  IEC 60027-2 standard </short>
        public string FormatByteSize(double size) {
            return (string) interceptor.Invoke("formatByteSize$", "formatByteSize(double) const", typeof(string), typeof(double), size);
        }
        /// <remarks>
        ///  Given a number of milliseconds, converts that to a string containing
        ///  the localized equivalent
        ///  e.g. given formatDuration(60000), returns "1.0 minutes"
        /// <param> name="mSec" Time duration in milliseconds
        /// </param></remarks>        <return> converted duration as a string - e.g. "5.5 seconds" "23.0 minutes"
        ///    </return>
        ///         <short>    Given a number of milliseconds, converts that to a string containing  the localized equivalent </short>
        public string FormatDuration(ulong mSec) {
            return (string) interceptor.Invoke("formatDuration$", "formatDuration(unsigned long) const", typeof(string), typeof(ulong), mSec);
        }
        /// <remarks>
        ///  Use this to determine whether nouns are declined in
        ///  locale's language. This property should remain
        ///  read-only (no setter function)
        /// </remarks>        <return> If nouns are declined
        ///    </return>
        ///         <short>    Use this to determine whether nouns are declined in  locale's language.</short>
        public bool NounDeclension() {
            return (bool) interceptor.Invoke("nounDeclension", "nounDeclension() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns a string formatted to the current locale's conventions
        ///  regarding dates.
        /// <param> name="date" the date to be formatted.
        /// </param><param> name="format" category of date format to use
        /// </param></remarks>        <return> The date as a string
        ///    </return>
        ///         <short>    Returns a string formatted to the current locale's conventions  regarding dates.</short>
        public string FormatDate(QDate date, KLocale.DateFormat format) {
            return (string) interceptor.Invoke("formatDate#$", "formatDate(const QDate&, KLocale::DateFormat) const", typeof(string), typeof(QDate), date, typeof(KLocale.DateFormat), format);
        }
        public string FormatDate(QDate date) {
            return (string) interceptor.Invoke("formatDate#", "formatDate(const QDate&) const", typeof(string), typeof(QDate), date);
        }
        /// <remarks>
        ///  Returns a string formatted to the current locale's conventions
        ///  regarding both date and time.
        /// <param> name="dateTime" the date and time to be formatted
        /// </param><param> name="format" category of date format to use
        /// </param><param> name="options" additional output options
        /// </param></remarks>        <return> The date and time as a string
        ///    </return>
        ///         <short>    Returns a string formatted to the current locale's conventions  regarding both date and time.</short>
        public string FormatDateTime(QDateTime dateTime, KLocale.DateFormat format, bool includeSecs) {
            return (string) interceptor.Invoke("formatDateTime#$$", "formatDateTime(const QDateTime&, KLocale::DateFormat, bool) const", typeof(string), typeof(QDateTime), dateTime, typeof(KLocale.DateFormat), format, typeof(bool), includeSecs);
        }
        public string FormatDateTime(QDateTime dateTime, KLocale.DateFormat format) {
            return (string) interceptor.Invoke("formatDateTime#$", "formatDateTime(const QDateTime&, KLocale::DateFormat) const", typeof(string), typeof(QDateTime), dateTime, typeof(KLocale.DateFormat), format);
        }
        public string FormatDateTime(QDateTime dateTime) {
            return (string) interceptor.Invoke("formatDateTime#", "formatDateTime(const QDateTime&) const", typeof(string), typeof(QDateTime), dateTime);
        }
        /// <remarks>
        ///  Returns a string formatted to the current locale's conventions
        ///  regarding both date and time.
        /// <param> name="dateTime" the date and time to be formatted
        /// </param><param> name="format" category of date format to use
        /// </param><param> name="options" additional output options
        /// </param></remarks>        <return> The date and time as a string
        ///    </return>
        ///         <short>    Returns a string formatted to the current locale's conventions  regarding both date and time.</short>
        public string FormatDateTime(KDateTime dateTime, KLocale.DateFormat format, uint options) {
            return (string) interceptor.Invoke("formatDateTime#$$", "formatDateTime(const KDateTime&, KLocale::DateFormat, KLocale::DateTimeFormatOptions) const", typeof(string), typeof(KDateTime), dateTime, typeof(KLocale.DateFormat), format, typeof(uint), options);
        }
        public string FormatDateTime(KDateTime dateTime, KLocale.DateFormat format) {
            return (string) interceptor.Invoke("formatDateTime#$", "formatDateTime(const KDateTime&, KLocale::DateFormat) const", typeof(string), typeof(KDateTime), dateTime, typeof(KLocale.DateFormat), format);
        }
        public string FormatDateTime(KDateTime dateTime) {
            return (string) interceptor.Invoke("formatDateTime#", "formatDateTime(const KDateTime&) const", typeof(string), typeof(KDateTime), dateTime);
        }
        /// <remarks>
        ///  Use this to determine whether in dates a possessive form of month
        ///  name is preferred ("of January" rather than "January")
        /// </remarks>        <return> If possessive form should be used
        ///   </return>
        ///         <short>    Use this to determine whether in dates a possessive form of month  name is preferred ("of January" rather than "January") </short>
        public bool DateMonthNamePossessive() {
            return (bool) interceptor.Invoke("dateMonthNamePossessive", "dateMonthNamePossessive() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns a string formatted to the current locale's conventions
        ///  regarding times.
        /// <param> name="pTime" The time to be formatted.
        /// </param><param> name="includeSecs" if true, seconds are included in the output,
        ///         otherwise only hours and minutes are formatted.
        /// </param><param> name="isDuration" if true, the given time is a duration, not a clock time.
        ///  This means "am/pm" shouldn't be displayed.
        /// </param></remarks>        <return> The time as a string
        ///    </return>
        ///         <short>    Returns a string formatted to the current locale's conventions  regarding times.</short>
        public string FormatTime(QTime pTime, bool includeSecs, bool isDuration) {
            return (string) interceptor.Invoke("formatTime#$$", "formatTime(const QTime&, bool, bool) const", typeof(string), typeof(QTime), pTime, typeof(bool), includeSecs, typeof(bool), isDuration);
        }
        public string FormatTime(QTime pTime, bool includeSecs) {
            return (string) interceptor.Invoke("formatTime#$", "formatTime(const QTime&, bool) const", typeof(string), typeof(QTime), pTime, typeof(bool), includeSecs);
        }
        public string FormatTime(QTime pTime) {
            return (string) interceptor.Invoke("formatTime#", "formatTime(const QTime&) const", typeof(string), typeof(QTime), pTime);
        }
        /// <remarks>
        ///  Use this to determine if the user wants a 12 hour clock.
        /// </remarks>        <return> If the user wants 12h clock
        ///    </return>
        ///         <short>    Use this to determine if the user wants a 12 hour clock.</short>
        public bool Use12Clock() {
            return (bool) interceptor.Invoke("use12Clock", "use12Clock() const", typeof(bool));
        }
        /// <remarks>
        ///  Use this to determine which day is the first day of the week.
        /// </remarks>        <return> an integer (Monday=1..Sunday=7)
        ///    </return>
        ///         <short>    Use this to determine which day is the first day of the week.</short>
        public int WeekStartDay() {
            return (int) interceptor.Invoke("weekStartDay", "weekStartDay() const", typeof(int));
        }
        /// <remarks>
        ///  Returns a pointer to the calendar system object.
        /// </remarks>        <return> the current calendar system instance
        ///    </return>
        ///         <short>    Returns a pointer to the calendar system object.</short>
        public KCalendarSystem Calendar() {
            return (KCalendarSystem) interceptor.Invoke("calendar", "calendar() const", typeof(KCalendarSystem));
        }
        /// <remarks>
        ///  Returns the name of the calendar system that is currently being
        ///  used by the system.
        /// </remarks>        <return> the name of the calendar system
        ///    </return>
        ///         <short>    Returns the name of the calendar system that is currently being  used by the system.</short>
        public string CalendarType() {
            return (string) interceptor.Invoke("calendarType", "calendarType() const", typeof(string));
        }
        /// <remarks>
        ///  Changes the current calendar system to the calendar specified.
        ///  Currently "gregorian" and "hijri" are supported. If the calendar
        ///  system specified is not found, gregorian will be used.
        /// <param> name="calendarType" the name of the calendar type
        ///    </param></remarks>        <short>    Changes the current calendar system to the calendar specified.</short>
        public void SetCalendar(string calendarType) {
            interceptor.Invoke("setCalendar$", "setCalendar(const QString&)", typeof(void), typeof(string), calendarType);
        }
        /// <remarks>
        ///  Converts a localized monetary string to a double.
        /// <param> name="numStr" the string we want to convert.
        /// </param><param> name="ok" the boolean that is set to false if it's not a number.
        ///            If <code>ok</code> is 0, it will be ignored
        /// </param></remarks>        <return> The string converted to a double
        ///    </return>
        ///         <short>    Converts a localized monetary string to a double.</short>
        public double ReadMoney(string numStr, ref bool ok) {
            StackItem[] stack = new StackItem[3];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(numStr);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(numStr);
#endif
            stack[2].s_bool = ok;
            interceptor.Invoke("readMoney$$", "readMoney(const QString&, bool*) const", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).Free();
#endif
            ok = stack[2].s_bool;
            return stack[0].s_double;
        }
        public double ReadMoney(string numStr) {
            return (double) interceptor.Invoke("readMoney$", "readMoney(const QString&) const", typeof(double), typeof(string), numStr);
        }
        /// <remarks>
        ///  Converts a localized numeric string to a double.
        /// <param> name="numStr" the string we want to convert.
        /// </param><param> name="ok" the boolean that is set to false if it's not a number.
        ///            If <code>ok</code> is 0, it will be ignored
        /// </param></remarks>        <return> The string converted to a double
        ///    </return>
        ///         <short>    Converts a localized numeric string to a double.</short>
        public double ReadNumber(string numStr, ref bool ok) {
            StackItem[] stack = new StackItem[3];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(numStr);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(numStr);
#endif
            stack[2].s_bool = ok;
            interceptor.Invoke("readNumber$$", "readNumber(const QString&, bool*) const", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).Free();
#endif
            ok = stack[2].s_bool;
            return stack[0].s_double;
        }
        public double ReadNumber(string numStr) {
            return (double) interceptor.Invoke("readNumber$", "readNumber(const QString&) const", typeof(double), typeof(string), numStr);
        }
        /// <remarks>
        ///  Converts a localized date string to a QDate.
        ///  The bool pointed by ok will be invalid if the date entered was not valid.
        /// <param> name="str" the string we want to convert.
        /// </param><param> name="ok" the boolean that is set to false if it's not a valid date.
        ///            If <code>ok</code> is 0, it will be ignored
        /// </param></remarks>        <return> The string converted to a QDate
        ///    </return>
        ///         <short>    Converts a localized date string to a QDate.</short>
        public QDate ReadDate(string str, ref bool ok) {
            StackItem[] stack = new StackItem[3];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(str);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(str);
#endif
            stack[2].s_bool = ok;
            interceptor.Invoke("readDate$$", "readDate(const QString&, bool*) const", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).Free();
#endif
            ok = stack[2].s_bool;
            object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
            ((GCHandle) stack[0].s_class).Free();
#endif
            return (QDate) returnValue;
        }
        public QDate ReadDate(string str) {
            return (QDate) interceptor.Invoke("readDate$", "readDate(const QString&) const", typeof(QDate), typeof(string), str);
        }
        /// <remarks>
        ///  Converts a localized date string to a QDate, using the specified format.
        ///  You will usually not want to use this method.
        ///    </remarks>        <short>    Converts a localized date string to a QDate, using the specified format.</short>
        public QDate ReadDate(string intstr, string fmt, ref bool ok) {
            StackItem[] stack = new StackItem[4];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(intstr);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(intstr);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(fmt);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(fmt);
#endif
            stack[3].s_bool = ok;
            interceptor.Invoke("readDate$$$", "readDate(const QString&, const QString&, bool*) const", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).Free();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).Free();
#endif
            ok = stack[3].s_bool;
            object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
            ((GCHandle) stack[0].s_class).Free();
#endif
            return (QDate) returnValue;
        }
        public QDate ReadDate(string intstr, string fmt) {
            return (QDate) interceptor.Invoke("readDate$$", "readDate(const QString&, const QString&) const", typeof(QDate), typeof(string), intstr, typeof(string), fmt);
        }
        /// <remarks>
        ///  Converts a localized date string to a QDate.
        ///  This method is stricter than readDate(str,&ok): it will either accept
        ///  a date in full format or a date in short format, depending on <code>flags.</code>
        /// <param> name="str" the string we want to convert.
        /// </param><param> name="flags" whether the date string is to be in full format or in short format.
        /// </param><param> name="ok" the boolean that is set to false if it's not a valid date.
        ///            If <code>ok</code> is 0, it will be ignored
        /// </param></remarks>        <return> The string converted to a QDate
        ///    </return>
        ///         <short>    Converts a localized date string to a QDate.</short>
        public QDate ReadDate(string str, KLocale.ReadDateFlags flags, ref bool ok) {
            StackItem[] stack = new StackItem[4];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(str);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(str);
#endif
            stack[2].s_int = (int) flags;
            stack[3].s_bool = ok;
            interceptor.Invoke("readDate$$$", "readDate(const QString&, KLocale::ReadDateFlags, bool*) const", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).Free();
#endif
            ok = stack[3].s_bool;
            object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
            ((GCHandle) stack[0].s_class).Free();
#endif
            return (QDate) returnValue;
        }
        public QDate ReadDate(string str, KLocale.ReadDateFlags flags) {
            return (QDate) interceptor.Invoke("readDate$$", "readDate(const QString&, KLocale::ReadDateFlags) const", typeof(QDate), typeof(string), str, typeof(KLocale.ReadDateFlags), flags);
        }
        /// <remarks>
        ///  Converts a localized time string to a QTime.
        ///  This method will try to parse it with seconds, then without seconds.
        ///  The bool pointed to by <code>ok</code> will be set to false if the time entered was
        ///  not valid.
        /// <param> name="str" the string we want to convert.
        /// </param><param> name="ok" the boolean that is set to false if it's not a valid time.
        ///            If <code>ok</code> is 0, it will be ignored
        /// </param></remarks>        <return> The string converted to a QTime
        ///    </return>
        ///         <short>    Converts a localized time string to a QTime.</short>
        public QTime ReadTime(string str, ref bool ok) {
            StackItem[] stack = new StackItem[3];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(str);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(str);
#endif
            stack[2].s_bool = ok;
            interceptor.Invoke("readTime$$", "readTime(const QString&, bool*) const", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).Free();
#endif
            ok = stack[2].s_bool;
            object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
            ((GCHandle) stack[0].s_class).Free();
#endif
            return (QTime) returnValue;
        }
        public QTime ReadTime(string str) {
            return (QTime) interceptor.Invoke("readTime$", "readTime(const QString&) const", typeof(QTime), typeof(string), str);
        }
        /// <remarks>
        ///  Converts a localized time string to a QTime.
        ///  This method is stricter than readTime(str,&ok): it will either accept
        ///  a time with seconds or a time without seconds.
        ///  Use this method when the format is known by the application.
        /// <param> name="str" the string we want to convert.
        /// </param><param> name="flags" whether the time string is expected to contain seconds or not.
        /// </param><param> name="ok" the boolean that is set to false if it's not a valid time.
        ///            If <code>ok</code> is 0, it will be ignored
        /// </param></remarks>        <return> The string converted to a QTime
        ///    </return>
        ///         <short>    Converts a localized time string to a QTime.</short>
        public QTime ReadTime(string str, KLocale.ReadTimeFlags flags, ref bool ok) {
            StackItem[] stack = new StackItem[4];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(str);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(str);
#endif
            stack[2].s_int = (int) flags;
            stack[3].s_bool = ok;
            interceptor.Invoke("readTime$$$", "readTime(const QString&, KLocale::ReadTimeFlags, bool*) const", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).Free();
#endif
            ok = stack[3].s_bool;
            object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
            ((GCHandle) stack[0].s_class).Free();
#endif
            return (QTime) returnValue;
        }
        public QTime ReadTime(string str, KLocale.ReadTimeFlags flags) {
            return (QTime) interceptor.Invoke("readTime$$", "readTime(const QString&, KLocale::ReadTimeFlags) const", typeof(QTime), typeof(string), str, typeof(KLocale.ReadTimeFlags), flags);
        }
        /// <remarks>
        ///  Returns the language code used by this object. The domain AND the
        ///  library translation must be available in this language.
        ///  defaultLanguage() is returned by default, if no other available.
        ///  Use languageCodeToName(language) to get human readable, localized
        ///  language name.
        /// </remarks>        <return> the currently used language code
        /// </return>
        ///         <short>    Returns the language code used by this object.</short>
        ///         <see> languageCodeToName</see>
        public string Language() {
            return (string) interceptor.Invoke("language", "language() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the country code of the country where the user lives.
        ///  defaultCountry() is returned by default, if no other available.
        ///  Use countryCodeToName(country) to get human readable, localized
        ///  country names.
        /// </remarks>        <return> the country code for the user
        /// </return>
        ///         <short>    Returns the country code of the country where the user lives.</short>
        ///         <see> countryCodeToName</see>
        public string Country() {
            return (string) interceptor.Invoke("country", "country() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the language codes selected by user, ordered by decreasing
        ///  priority.
        ///  Use languageCodeToName(language) to get human readable, localized
        ///  language name.
        /// </remarks>        <return> list of language codes
        /// </return>
        ///         <short>    Returns the language codes selected by user, ordered by decreasing  priority.</short>
        ///         <see> languageCodeToName</see>
        public List<string> LanguageList() {
            return (List<string>) interceptor.Invoke("languageList", "languageList() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Returns the user's preferred encoding.
        /// </remarks>        <return> The name of the preferred encoding
        /// </return>
        ///         <short>    Returns the user's preferred encoding.</short>
        ///         <see> codecForEncoding</see>
        ///         <see> encodingMib</see>
        public QByteArray Encoding() {
            return (QByteArray) interceptor.Invoke("encoding", "encoding() const", typeof(QByteArray));
        }
        /// <remarks>
        ///  Returns the user's preferred encoding.
        /// </remarks>        <return> The Mib of the preferred encoding
        /// </return>
        ///         <short>    Returns the user's preferred encoding.</short>
        ///         <see> encoding</see>
        ///         <see> codecForEncoding</see>
        public int EncodingMib() {
            return (int) interceptor.Invoke("encodingMib", "encodingMib() const", typeof(int));
        }
        /// <remarks>
        ///  Returns the user's preferred encoding. Should never be NULL.
        /// </remarks>        <return> The codec for the preferred encoding
        /// </return>
        ///         <short>    Returns the user's preferred encoding.</short>
        ///         <see> encoding</see>
        ///         <see> encodingMib</see>
        public QTextCodec CodecForEncoding() {
            return (QTextCodec) interceptor.Invoke("codecForEncoding", "codecForEncoding() const", typeof(QTextCodec));
        }
        /// <remarks>
        ///  Returns the file encoding.
        /// </remarks>        <return> The Mib of the file encoding
        /// </return>
        ///         <short>    Returns the file encoding.</short>
        ///         <see> QFile.EncodeName</see>
        ///         <see> QFile.DecodeName</see>
        public int FileEncodingMib() {
            return (int) interceptor.Invoke("fileEncodingMib", "fileEncodingMib() const", typeof(int));
        }
        /// <remarks>
        ///  Changes the current date format.
        ///  The format of the date is a string which contains variables that will
        ///  be replaced:
        /// 
        /// <li>
        /// %Y with the whole year (e.g. "1984" for "1984")
        /// </li>
        /// 
        /// <li>
        /// %y with the lower 2 digits of the year (e.g. "84" for "1984")
        /// </li>
        /// 
        /// <li>
        /// %n with the month (January="1", December="12")
        /// </li>
        /// 
        /// <li>
        /// %m with the month with two digits (January="01", December="12")
        /// </li>
        /// 
        /// <li>
        /// %e with the day of the month (e.g. "1" on the first of march)
        /// </li>
        /// 
        /// <li>
        /// %d with the day of the month with two digits(e.g. "01" on the first of march)
        /// </li>
        /// 
        /// <li>
        /// %b with the short form of the month (e.g. "Jan" for January)
        /// </li>
        /// 
        /// <li>
        /// %B with the long form of the month (e.g. "January")
        /// </li>
        /// 
        /// <li>
        /// %a with the short form of the weekday (e.g. "Wed" for Wednesday)
        /// </li>
        /// 
        /// <li>
        /// %A with the long form of the weekday (e.g. "Wednesday" for Wednesday)
        /// </li>
        ///  Everything else in the format string will be taken as is.
        ///  For example, March 20th 1989 with the format "%y:%m:%d" results
        ///  in "89:03:20".
        /// <param> name="format" The new date format
        ///    </param></remarks>        <short>    Changes the current date format.</short>
        public void SetDateFormat(string format) {
            interceptor.Invoke("setDateFormat$", "setDateFormat(const QString&)", typeof(void), typeof(string), format);
        }
        /// <remarks>
        ///  Changes the current short date format.
        ///  The format of the date is a string which contains variables that will
        ///  be replaced:
        /// 
        /// <li>
        /// %Y with the whole year (e.g. "1984" for "1984")
        /// </li>
        /// 
        /// <li>
        /// %y with the lower 2 digits of the year (e.g. "84" for "1984")
        /// </li>
        /// 
        /// <li>
        /// %n with the month (January="1", December="12")
        /// </li>
        /// 
        /// <li>
        /// %m with the month with two digits (January="01", December="12")
        /// </li>
        /// 
        /// <li>
        /// %e with the day of the month (e.g. "1" on the first of march)
        /// </li>
        /// 
        /// <li>
        /// %d with the day of the month with two digits(e.g. "01" on the first of march)
        /// </li>
        /// 
        /// <li>
        /// %b with the short form of the month (e.g. "Jan" for January)
        /// </li>
        /// 
        /// <li>
        /// %B with the long form of the month (e.g. "January")
        /// </li>
        /// 
        /// <li>
        /// %a with the short form of the weekday (e.g. "Wed" for Wednesday)
        /// </li>
        /// 
        /// <li>
        /// %A with the long form of the weekday (e.g. "Wednesday" for Wednesday)
        /// </li>
        ///  Everything else in the format string will be taken as is.
        ///  For example, March 20th 1989 with the format "%y:%m:%d" results
        ///  in "89:03:20".
        /// <param> name="format" The new short date format
        ///    </param></remarks>        <short>    Changes the current short date format.</short>
        public void SetDateFormatShort(string format) {
            interceptor.Invoke("setDateFormatShort$", "setDateFormatShort(const QString&)", typeof(void), typeof(string), format);
        }
        /// <remarks>
        ///  Changes the form of month name used in dates.
        /// <param> name="possessive" True if possessive forms should be used
        ///    </param></remarks>        <short>    Changes the form of month name used in dates.</short>
        public void SetDateMonthNamePossessive(bool possessive) {
            interceptor.Invoke("setDateMonthNamePossessive$", "setDateMonthNamePossessive(bool)", typeof(void), typeof(bool), possessive);
        }
        /// <remarks>
        ///  Changes the current time format.
        ///  The format of the time is string a which contains variables that will
        ///  be replaced:
        /// 
        /// <li>
        /// %H with the hour in 24h format and 2 digits (e.g. 5pm is "17", 5am is "05")
        /// </li>
        /// 
        /// <li>
        /// %k with the hour in 24h format and one digits (e.g. 5pm is "17", 5am is "5")
        /// </li>
        /// 
        /// <li>
        /// %I with the hour in 12h format and 2 digits (e.g. 5pm is "05", 5am is "05")
        /// </li>
        /// 
        /// <li>
        /// %l with the hour in 12h format and one digits (e.g. 5pm is "5", 5am is "5")
        /// </li>
        /// 
        /// <li>
        /// %M with the minute with 2 digits (e.g. the minute of 07:02:09 is "02")
        /// </li>
        /// 
        /// <li>
        /// %S with the seconds with 2 digits  (e.g. the minute of 07:02:09 is "09")
        /// </li>
        /// 
        /// <li>
        /// %p with pm or am (e.g. 17.00 is "pm", 05.00 is "am")
        /// </li>
        ///  Everything else in the format string will be taken as is.
        ///  For example, 5.23pm with the format "%H:%M" results
        ///  in "17:23".
        /// <param> name="format" The new time format
        ///    </param></remarks>        <short>    Changes the current time format.</short>
        public void SetTimeFormat(string format) {
            interceptor.Invoke("setTimeFormat$", "setTimeFormat(const QString&)", typeof(void), typeof(string), format);
        }
        /// <remarks>
        ///  Changes how KLocale defines the first day in week.
        /// <param> name="day" first day of the week (Monday=1..Sunday=7) as integer
        ///    </param></remarks>        <short>    Changes how KLocale defines the first day in week.</short>
        public void SetWeekStartDay(int day) {
            interceptor.Invoke("setWeekStartDay$", "setWeekStartDay(int)", typeof(void), typeof(int), day);
        }
        /// <remarks>
        ///  Returns the currently selected date format.
        /// </remarks>        <return> Current date format.
        /// </return>
        ///         <short>    Returns the currently selected date format.</short>
        ///         <see> setDateFormat</see>
        public string dateFormat() {
            return (string) interceptor.Invoke("dateFormat", "dateFormat() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the currently selected short date format.
        /// </remarks>        <return> Current short date format.
        /// </return>
        ///         <short>    Returns the currently selected short date format.</short>
        ///         <see> setDateFormatShort</see>
        public string DateFormatShort() {
            return (string) interceptor.Invoke("dateFormatShort", "dateFormatShort() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the currently selected time format.
        /// </remarks>        <return> Current time format.
        /// </return>
        ///         <short>    Returns the currently selected time format.</short>
        ///         <see> setTimeFormat</see>
        public string TimeFormat() {
            return (string) interceptor.Invoke("timeFormat", "timeFormat() const", typeof(string));
        }
        /// <remarks>
        ///  Changes the symbol used to identify the decimal pointer.
        /// <param> name="symbol" The new decimal symbol.
        ///    </param></remarks>        <short>    Changes the symbol used to identify the decimal pointer.</short>
        public void SetDecimalSymbol(string symbol) {
            interceptor.Invoke("setDecimalSymbol$", "setDecimalSymbol(const QString&)", typeof(void), typeof(string), symbol);
        }
        /// <remarks>
        ///  Changes the separator used to group digits when formating numbers.
        /// <param> name="separator" The new thousands separator.
        ///    </param></remarks>        <short>    Changes the separator used to group digits when formating numbers.</short>
        public void SetThousandsSeparator(string separator) {
            interceptor.Invoke("setThousandsSeparator$", "setThousandsSeparator(const QString&)", typeof(void), typeof(string), separator);
        }
        /// <remarks>
        ///  Changes the sign used to identify a positive number. Normally this is
        ///  left blank.
        /// <param> name="sign" Sign used for positive numbers.
        ///    </param></remarks>        <short>    Changes the sign used to identify a positive number.</short>
        public void SetPositiveSign(string sign) {
            interceptor.Invoke("setPositiveSign$", "setPositiveSign(const QString&)", typeof(void), typeof(string), sign);
        }
        /// <remarks>
        ///  Changes the sign used to identify a negative number.
        /// <param> name="sign" Sign used for negative numbers.
        ///    </param></remarks>        <short>    Changes the sign used to identify a negative number.</short>
        public void SetNegativeSign(string sign) {
            interceptor.Invoke("setNegativeSign$", "setNegativeSign(const QString&)", typeof(void), typeof(string), sign);
        }
        /// <remarks>
        ///  Changes the sign position used for positive monetary values.
        /// <param> name="signpos" The new sign position
        ///    </param></remarks>        <short>    Changes the sign position used for positive monetary values.</short>
        public void SetPositiveMonetarySignPosition(KLocale.SignPosition signpos) {
            interceptor.Invoke("setPositiveMonetarySignPosition$", "setPositiveMonetarySignPosition(KLocale::SignPosition)", typeof(void), typeof(KLocale.SignPosition), signpos);
        }
        /// <remarks>
        ///  Changes the sign position used for negative monetary values.
        /// <param> name="signpos" The new sign position
        ///    </param></remarks>        <short>    Changes the sign position used for negative monetary values.</short>
        public void SetNegativeMonetarySignPosition(KLocale.SignPosition signpos) {
            interceptor.Invoke("setNegativeMonetarySignPosition$", "setNegativeMonetarySignPosition(KLocale::SignPosition)", typeof(void), typeof(KLocale.SignPosition), signpos);
        }
        /// <remarks>
        ///  Changes the position where the currency symbol should be printed for
        ///  positive monetary values.
        /// <param> name="prefix" True if the currency symbol should be prefixed instead of
        ///  postfixed
        ///    </param></remarks>        <short>    Changes the position where the currency symbol should be printed for  positive monetary values.</short>
        public void SetPositivePrefixCurrencySymbol(bool prefix) {
            interceptor.Invoke("setPositivePrefixCurrencySymbol$", "setPositivePrefixCurrencySymbol(bool)", typeof(void), typeof(bool), prefix);
        }
        /// <remarks>
        ///  Changes the position where the currency symbol should be printed for
        ///  negative monetary values.
        /// <param> name="prefix" True if the currency symbol should be prefixed instead of
        ///  postfixed
        ///    </param></remarks>        <short>    Changes the position where the currency symbol should be printed for  negative monetary values.</short>
        public void SetNegativePrefixCurrencySymbol(bool prefix) {
            interceptor.Invoke("setNegativePrefixCurrencySymbol$", "setNegativePrefixCurrencySymbol(bool)", typeof(void), typeof(bool), prefix);
        }
        /// <remarks>
        ///  Changes the number of digits used when formating numbers.
        /// <param> name="digits" The default number of digits to use.
        ///    </param></remarks>        <short>    Changes the number of digits used when formating numbers.</short>
        public void SetFracDigits(int digits) {
            interceptor.Invoke("setFracDigits$", "setFracDigits(int)", typeof(void), typeof(int), digits);
        }
        /// <remarks>
        ///  Changes the separator used to group digits when formating monetary values.
        /// <param> name="separator" The new thousands separator.
        ///    </param></remarks>        <short>    Changes the separator used to group digits when formating monetary values.</short>
        public void SetMonetaryThousandsSeparator(string separator) {
            interceptor.Invoke("setMonetaryThousandsSeparator$", "setMonetaryThousandsSeparator(const QString&)", typeof(void), typeof(string), separator);
        }
        /// <remarks>
        ///  Changes the symbol used to identify the decimal pointer for monetary
        ///  values.
        /// <param> name="symbol" The new decimal symbol.
        ///    </param></remarks>        <short>    Changes the symbol used to identify the decimal pointer for monetary  values.</short>
        public void SetMonetaryDecimalSymbol(string symbol) {
            interceptor.Invoke("setMonetaryDecimalSymbol$", "setMonetaryDecimalSymbol(const QString&)", typeof(void), typeof(string), symbol);
        }
        /// <remarks>
        ///  Changes the current currency symbol.
        /// <param> name="symbol" The new currency symbol
        ///    </param></remarks>        <short>    Changes the current currency symbol.</short>
        public void SetCurrencySymbol(string symbol) {
            interceptor.Invoke("setCurrencySymbol$", "setCurrencySymbol(const QString&)", typeof(void), typeof(string), symbol);
        }
        /// <remarks>
        ///  Returns the preferred page size for printing.
        /// </remarks>        <return> The preferred page size, cast it to QPrinter.PageSize
        ///    </return>
        ///         <short>    Returns the preferred page size for printing.</short>
        public int PageSize() {
            return (int) interceptor.Invoke("pageSize", "pageSize() const", typeof(int));
        }
        /// <remarks>
        ///  Changes the preferred page size when printing.
        /// <param> name="paperFormat" the new preferred page size in the format QPrinter.PageSize
        ///    </param></remarks>        <short>    Changes the preferred page size when printing.</short>
        public void SetPageSize(int paperFormat) {
            interceptor.Invoke("setPageSize$", "setPageSize(int)", typeof(void), typeof(int), paperFormat);
        }
        /// <remarks>
        ///  Returns which measuring system we use.
        /// </remarks>        <return> The preferred measuring system
        ///    </return>
        ///         <short>    Returns which measuring system we use.</short>
        public KLocale.MeasureSystem measureSystem() {
            return (KLocale.MeasureSystem) interceptor.Invoke("measureSystem", "measureSystem() const", typeof(KLocale.MeasureSystem));
        }
        /// <remarks>
        ///  Changes the preferred measuring system.
        /// </remarks>        <return> value The preferred measuring system
        ///    </return>
        ///         <short>    Changes the preferred measuring system.</short>
        public void SetMeasureSystem(KLocale.MeasureSystem value) {
            interceptor.Invoke("setMeasureSystem$", "setMeasureSystem(KLocale::MeasureSystem)", typeof(void), typeof(KLocale.MeasureSystem), value);
        }
        /// <remarks>
        ///  Adds another catalog to search for translation lookup.
        ///  This function is useful for extern libraries and/or code,
        ///  that provide there own messages.
        ///  If the catalog does not exist for the chosen language,
        ///  it will be ignored and en_US will be used.
        /// <param> name="catalog" The catalog to add.
        ///    </param></remarks>        <short>    Adds another catalog to search for translation lookup.</short>
        public void InsertCatalog(string catalog) {
            interceptor.Invoke("insertCatalog$", "insertCatalog(const QString&)", typeof(void), typeof(string), catalog);
        }
        /// <remarks>
        ///  Removes a catalog for translation lookup.
        /// <param> name="catalog" The catalog to remove.
        /// </param></remarks>        <short>    Removes a catalog for translation lookup.</short>
        ///         <see> insertCatalog</see>
        public void RemoveCatalog(string catalog) {
            interceptor.Invoke("removeCatalog$", "removeCatalog(const QString&)", typeof(void), typeof(string), catalog);
        }
        /// <remarks>
        ///  Sets the active catalog for translation lookup.
        /// <param> name="catalog" The catalog to activate.
        ///    </param></remarks>        <short>    Sets the active catalog for translation lookup.</short>
        public void SetActiveCatalog(string catalog) {
            interceptor.Invoke("setActiveCatalog$", "setActiveCatalog(const QString&)", typeof(void), typeof(string), catalog);
        }
        /// <remarks>
        ///  Translates a message as a QTranslator is supposed to.
        ///  The parameters are similar to i18n(), but the result
        ///  value has other semantics (it can be string())
        /// </remarks>        <short>    Translates a message as a QTranslator is supposed to.</short>
        public string TranslateQt(string context, string sourceText, string comment) {
            return (string) interceptor.Invoke("translateQt$$$", "translateQt(const char*, const char*, const char*) const", typeof(string), typeof(string), context, typeof(string), sourceText, typeof(string), comment);
        }
        /// <remarks>
        ///  Provides list of all known language codes.
        ///  Use languageCodeToName(language) to get human readable, localized
        ///  language names.
        /// </remarks>        <return> list of all language codes
        /// </return>
        ///         <short>    Provides list of all known language codes.</short>
        ///         <see> languageCodeToName</see>
        public List<string> AllLanguagesList() {
            return (List<string>) interceptor.Invoke("allLanguagesList", "allLanguagesList() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Convert a known language code to a human readable, localized form.
        ///  If an unknown language code is supplied, empty string is returned;
        ///  this will never happen if the code has been obtained by one of the
        ///  KLocale methods.
        /// <param> name="language" the language code
        /// </param></remarks>        <return> the human readable and localized form if the code is known,
        ///          empty otherwise
        /// </return>
        ///         <short>    Convert a known language code to a human readable, localized form.</short>
        ///         <see> language</see>
        ///         <see> languageList</see>
        ///         <see> allLanguagesList</see>
        public string LanguageCodeToName(string language) {
            return (string) interceptor.Invoke("languageCodeToName$", "languageCodeToName(const QString&) const", typeof(string), typeof(string), language);
        }
        /// <remarks>
        ///  Provides list of all known country codes.
        ///  Use countryCodeToName(country) to get human readable, localized
        ///  country names.
        /// </remarks>        <return> a list of all country codes
        /// </return>
        ///         <short>    Provides list of all known country codes.</short>
        ///         <see> countryCodeToName</see>
        public List<string> AllCountriesList() {
            return (List<string>) interceptor.Invoke("allCountriesList", "allCountriesList() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Convert a known country code to a human readable, localized form.
        ///  If an unknown country code is supplied, empty string is returned;
        ///  this will never happen if the code has been obtained by one of the
        ///  KLocale methods.
        /// <param> name="code" the country code
        /// </param></remarks>        <return> the human readable and localized form of the country name
        /// </return>
        ///         <short>    Convert a known country code to a human readable, localized form.</short>
        ///         <see> country</see>
        ///         <see> allCountriesList</see>
        public string CountryCodeToName(string country) {
            return (string) interceptor.Invoke("countryCodeToName$", "countryCodeToName(const QString&) const", typeof(string), typeof(string), country);
        }
        /// <remarks>
        ///  Reports whether evaluation of translation scripts is enabled.
        /// </remarks>        <return> true if script evaluation is enabled, false otherwise.
        ///    </return>
        ///         <short>    Reports whether evaluation of translation scripts is enabled.</short>
        public bool UseTranscript() {
            return (bool) interceptor.Invoke("useTranscript", "useTranscript() const", typeof(bool));
        }
        /// <remarks>
        ///  Checks whether or not the active catalog is found for the given language.
        /// <param> name="language" language to check
        ///    </param></remarks>        <short>    Checks whether or not the active catalog is found for the given language.</short>
        public bool IsApplicationTranslatedInto(string language) {
            return (bool) interceptor.Invoke("isApplicationTranslatedInto$", "isApplicationTranslatedInto(const QString&)", typeof(bool), typeof(string), language);
        }
        /// <remarks>
        ///  Copies the catalogs of this objct to an other KLocale object.
        ///    </remarks>        <short>    Copies the catalogs of this objct to an other KLocale object.</short>
        public void CopyCatalogsTo(KLocale locale) {
            interceptor.Invoke("copyCatalogsTo#", "copyCatalogsTo(KLocale*)", typeof(void), typeof(KLocale), locale);
        }
        /// <remarks>
        ///  Changes the current country. The current country will be left
        ///  unchanged if failed. It will force a reload of the country specific
        ///  configuration.
        /// <param> name="country" The ISO 3166 country code.
        /// </param></remarks>        <return> True on success.
        ///    </return>
        ///         <short>    Changes the current country.</short>
        public bool SetCountry(string country, KConfig config) {
            return (bool) interceptor.Invoke("setCountry$#", "setCountry(const QString&, KConfig*)", typeof(bool), typeof(string), country, typeof(KConfig), config);
        }
        /// <remarks>
        ///  Changes the current language. The current language will be left
        ///  unchanged if failed. It will force a reload of the country specific
        ///  configuration as well.
        /// <param> name="language" the language code
        /// </param></remarks>        <return> true on success
        ///    </return>
        ///         <short>    Changes the current language.</short>
        public bool SetLanguage(string language, KConfig config) {
            return (bool) interceptor.Invoke("setLanguage$#", "setLanguage(const QString&, KConfig*)", typeof(bool), typeof(string), language, typeof(KConfig), config);
        }
        /// <remarks>
        ///  Changes the list of preferred languages for the locale. The first valid
        ///  language in the list will be used, or the default language (en_US)
        ///  if none of the specified languages were available.
        /// <param> name="languages" the list of language codes
        /// </param></remarks>        <return> true if one of the specified languages were used
        ///    </return>
        ///         <short>    Changes the list of preferred languages for the locale.</short>
        public bool SetLanguage(List<string> languages) {
            return (bool) interceptor.Invoke("setLanguage?", "setLanguage(const QStringList&)", typeof(bool), typeof(List<string>), languages);
        }
        /// <remarks>
        ///  Tries to find a path to the localized file for the given original path.
        ///  This is intended mainly for non-text resources (images, sounds, etc.),
        ///  whereas text resources should be handled in more specific ways.
        ///  The possible localized paths are checked in turn by priority of set
        ///  languages, in form of dirname/l10n/ll/basename, where dirname and
        ///  basename are those of the original path, and ll is the language code.
        ///  KDE core classes which resolve paths internally (e.g. KStandardDirs)
        ///  will usually perform this lookup behind the scene.
        ///  In general, you should pipe resource paths through this method only
        ///  on explicit translators' request, or when a resource is an obvious
        ///  candidate for localization (e.g. a splash screen or a custom icon
        ///  with some text drawn on it).
        /// <param> name="filePath" path to the original file
        /// </param></remarks>        <return> path to the localized file if found, original path otherwise
        ///    </return>
        ///         <short>   </short>
        public string LocalizedFilePath(string filePath) {
            return (string) interceptor.Invoke("localizedFilePath$", "localizedFilePath(const QString&) const", typeof(string), typeof(string), filePath);
        }
        ~KLocale() {
            interceptor.Invoke("~KLocale", "~KLocale()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KLocale", "~KLocale()", typeof(void));
        }
        /// <remarks>
        ///  Parses locale string into distinct parts.
        ///  The format of locale is language_COUNTRY@modifier.CHARSET
        /// <param> name="locale" the locale string to split
        /// </param><param> name="language" set to the language part of the locale
        /// </param><param> name="country" set to the country part of the locale
        /// </param><param> name="modifier" set to the modifer part of the locale
        /// </param><param> name="charset" set to the charset part of the locale
        ///    </param></remarks>        <short>    Parses locale string into distinct parts.</short>
        public static void SplitLocale(string locale, StringBuilder language, StringBuilder country, StringBuilder modifier, StringBuilder charset) {
            staticInterceptor.Invoke("splitLocale$$$$$", "splitLocale(const QString&, QString&, QString&, QString&, QString&)", typeof(void), typeof(string), locale, typeof(StringBuilder), language, typeof(StringBuilder), country, typeof(StringBuilder), modifier, typeof(StringBuilder), charset);
        }
        /// <remarks>
        ///  Use this as main catalog for all KLocales, if not the appname
        ///  will be used. This function is best to be the very first instruction
        ///  in your program's main function as it only has an effect before the
        ///  first KLocale object is created.
        /// <param> name="catalog" Catalog to override all other main Catalogs.
        ///    </param></remarks>        <short>    Use this as main catalog for  all  KLocales, if not the appname  will be used.</short>
        public static void SetMainCatalog(string catalog) {
            staticInterceptor.Invoke("setMainCatalog$", "setMainCatalog(const char*)", typeof(void), typeof(string), catalog);
        }
        /// <remarks>
        ///  Returns the name of the internal language.
        /// </remarks>        <return> Name of the default language
        ///    </return>
        ///         <short>    Returns the name of the internal language.</short>
        public static string DefaultLanguage() {
            return (string) staticInterceptor.Invoke("defaultLanguage", "defaultLanguage()", typeof(string));
        }
        /// <remarks>
        ///  Returns the name of the default country.
        /// </remarks>        <return> Name of the default country
        ///    </return>
        ///         <short>    Returns the name of the default country.</short>
        public static string DefaultCountry() {
            return (string) staticInterceptor.Invoke("defaultCountry", "defaultCountry()", typeof(string));
        }
    }
}
