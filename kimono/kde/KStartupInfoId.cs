//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  Class representing an identification of application startup notification.
    ///  Every existing notification about a starting application has its own unique
    ///  identification, that's used to identify and manipulate the notification.
    /// </remarks>        <author> Lubos Lunak <l.lunak@kde.org>
    ///  </author>
    ///         <short>    Class representing an identification of application startup notification.</short>
    ///         <see> KStartupInfo</see>
    ///         <see> KStartupInfoData</see>
    [SmokeClass("KStartupInfoId")]
    public class KStartupInfoId : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KStartupInfoId(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KStartupInfoId), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KStartupInfoId() {
            staticInterceptor = new SmokeInvocation(typeof(KStartupInfoId), null);
        }
        /// <remarks>
        ///  Overloaded operator.
        /// </remarks>        <return> true if the notification identifications are the same
        /// 	 </return>
        ///         <short>    Overloaded operator.</short>
        public override bool Equals(object o) {
            if (!(o is KStartupInfoId)) { return false; }
            return this == (KStartupInfoId) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        /// <remarks>
        ///  Checks whether the identifier is valid.
        /// </remarks>        <return> true if this object doesn't represent a valid notification identification
        /// 	 </return>
        ///         <short>    Checks whether the identifier is valid.</short>
        public bool None() {
            return (bool) interceptor.Invoke("none", "none() const", typeof(bool));
        }
        /// <remarks>
        ///  Initializes this object with the given identification ( which may be also "0"
        ///  for no notification ), or if "" is given, tries to read it from the startup
        ///  notification environment variable, and if it's not set, creates a new one.
        /// <param> name="id" the new identification, "0" for no notification or "" to read
        ///            the environment variable
        /// 	 </param></remarks>        <short>    Initializes this object with the given identification ( which may be also "0"  for no notification ), or if "" is given, tries to read it from the startup  notification environment variable, and if it's not set, creates a new one.</short>
        public void InitId(QByteArray id) {
            interceptor.Invoke("initId#", "initId(const QByteArray&)", typeof(void), typeof(QByteArray), id);
        }
        public void InitId() {
            interceptor.Invoke("initId", "initId()", typeof(void));
        }
        /// <remarks>
        ///  Returns the notification identifier as string.
        /// </remarks>        <return> the identification string for the notification
        /// 	 </return>
        ///         <short>    Returns the notification identifier as string.</short>
        public QByteArray Id() {
            return (QByteArray) interceptor.Invoke("id", "id() const", typeof(QByteArray));
        }
        /// <remarks>
        ///  Return the user timestamp for the startup notification, or 0 if no timestamp
        ///  is set.
        ///          </remarks>        <short>    Return the user timestamp for the startup notification, or 0 if no timestamp  is set.</short>
        public ulong Timestamp() {
            return (ulong) interceptor.Invoke("timestamp", "timestamp() const", typeof(ulong));
        }
        /// <remarks>
        ///  Sets the startup notification environment variable to this identification.
        /// </remarks>        <return> true if successful, false otherwise
        /// 	 </return>
        ///         <short>    Sets the startup notification environment variable to this identification.</short>
        public bool SetupStartupEnv() {
            return (bool) interceptor.Invoke("setupStartupEnv", "setupStartupEnv() const", typeof(bool));
        }
        /// <remarks>
        ///  Creates an empty identification
        /// 	 </remarks>        <short>    Creates an empty identification 	 </short>
        public KStartupInfoId() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStartupInfoId", "KStartupInfoId()", typeof(void));
        }
        /// <remarks>
        ///  Copy constructor.
        /// 	 </remarks>        <short>    Copy constructor.</short>
        public KStartupInfoId(KStartupInfoId data) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KStartupInfoId#", "KStartupInfoId(const KStartupInfoId&)", typeof(void), typeof(KStartupInfoId), data);
        }
        ~KStartupInfoId() {
            interceptor.Invoke("~KStartupInfoId", "~KStartupInfoId()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KStartupInfoId", "~KStartupInfoId()", typeof(void));
        }
        public static bool operator==(KStartupInfoId lhs, KStartupInfoId id) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KStartupInfoId&) const", typeof(bool), typeof(KStartupInfoId), lhs, typeof(KStartupInfoId), id);
        }
        public static bool operator!=(KStartupInfoId lhs, KStartupInfoId id) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KStartupInfoId&) const", typeof(bool), typeof(KStartupInfoId), lhs, typeof(KStartupInfoId), id);
        }
        public static bool operator<(KStartupInfoId lhs, KStartupInfoId id) {
            return (bool) staticInterceptor.Invoke("operator<#", "operator<(const KStartupInfoId&) const", typeof(bool), typeof(KStartupInfoId), lhs, typeof(KStartupInfoId), id);
        }
        public static bool operator>(KStartupInfoId lhs, KStartupInfoId id) {
            return !(bool) staticInterceptor.Invoke("operator<#", "operator<(const KStartupInfoId&) const", typeof(bool), typeof(KStartupInfoId), lhs, typeof(KStartupInfoId), id)
                        && !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KStartupInfoId&) const", typeof(bool), typeof(KStartupInfoId), lhs, typeof(KStartupInfoId), id);
        }
    }
}
