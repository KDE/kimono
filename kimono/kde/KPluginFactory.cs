//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  \class KPluginFactory kpluginfactory.h <KPluginFactory>
    ///  If you develop a library that is to be loaded dynamically at runtime, then
    ///  you should return a pointer to a KPluginFactory.
    ///  For most cases it is enough to use the K_PLUGIN_FACTORY macro to create the factory.
    ///  Example:
    ///  <pre>
    ///  #include <KPluginFactory>
    ///  #include <KPluginLoader>
    ///  #include <plugininterface.h>
    ///  class MyPlugin;
    ///  K_PLUGIN_FACTORY(MyPluginFactory,
    ///                   registerPlugin<MyPlugin>();
    ///                  )
    ///  K_EXPORT_PLUGIN(MyPluginFactory("componentName"))
    ///  class MyPlugin : public PluginInterface
    ///  {
    ///      ...
    ///      KComponentData kcd = MyPluginFactory.ComponentData();
    ///      ...
    ///  }
    ///  </pre>
    ///  K_PLUGIN_FACTORY is a convenient macro that expands to a class derived from KPluginFactory
    ///  providing two constructors and a static componentData() function. The second argument to
    ///  K_PLUGIN_FACTORY is code that is called from the constructors. There you can use registerPlugin
    ///  to register as many plugins for the factory as you want to.
    ///  If you want to write a custom KPluginFactory not using the standard macro(s) you can reimplement
    ///  the create(string iface, QWidget parentWidget, QObject parent, QVariantListargs, stringkeyword)
    ///  function.
    ///  Example:
    ///  <pre>
    ///  class SomeScriptLanguageFactory : public KPluginFactory
    ///  {
    ///       public      SomeScriptLanguageFactory()
    ///      {}
    ///  protected:
    ///      QObject create(string iface, QWidget parentWidget, QObject parent, QVariantListargs, stringkeyword)
    ///      {
    ///          string identifier = QLatin1String(iface) + QLatin1Char('_') + keyword;
    ///          // load scripting language module from the information in identifier
    ///          // and return it:
    ///          return object;
    ///      }
    ///  }
    ///  </pre>
    ///  If you want to load a library use KPluginLoader.
    ///  The application that wants to instantiate plugin classes can do the following:
    ///  <pre>
    ///  KPluginFactory factory = KPluginLoader("libraryname").factory();
    ///  if (factory) {
    ///      PluginInterface p1 = factory.Create<PluginInterface>(parent);
    ///      OtherInterface p2  = factory.Create<OtherInterface>(parent);
    ///      NextInterface p3   = factory.Create<NextInterface>("keyword1", parent);
    ///      NextInterface p3   = factory.Create<NextInterface>("keyword2", parent);
    ///  }
    ///  </pre>
    ///  \author Matthias Kretz <kretz@kde.org>
    ///  \author Bernhard Loos <nhuh.put@web.de>
    ///   See <see cref="IKPluginFactorySignals"></see> for signals emitted by KPluginFactory
    /// </remarks>        <short>    \class KPluginFactory kpluginfactory.</short>
    [SmokeClass("KPluginFactory")]
    public class KPluginFactory : QObject, IDisposable {
        protected KPluginFactory(Type dummy) : base((Type) null) {}
        /// <remarks>
        ///  This is used to detect the arguments need for the constructor of plugin classes.
        ///  You can inherit it, if you want to add new classes and still keep support for the old ones.
        ///      </remarks>        <short>    This is used to detect the arguments need for the constructor of plugin classes.</short>
        [SmokeClass("KPluginFactory::InheritanceChecker")]
        public class InheritanceChecker : Object {
            protected SmokeInvocation interceptor = null;
            private IntPtr smokeObject;
            protected InheritanceChecker(Type dummy) {}
            // CreateInstanceFunction createInstanceFunction(KParts::Part* arg1); >>>> NOT CONVERTED
            // CreateInstanceFunction createInstanceFunction(QWidget* arg1); >>>> NOT CONVERTED
            // CreateInstanceFunction createInstanceFunction(); >>>> NOT CONVERTED
        }
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KPluginFactory), this);
        }
        // KPluginFactory* KPluginFactory(const char* arg1,const char* arg2,QObject* arg3); >>>> NOT CONVERTED
        // KPluginFactory* KPluginFactory(const char* arg1,const char* arg2); >>>> NOT CONVERTED
        // KPluginFactory* KPluginFactory(const char* arg1); >>>> NOT CONVERTED
        // KPluginFactory* KPluginFactory(); >>>> NOT CONVERTED
        // KPluginFactory* KPluginFactory(const KAboutData& arg1,QObject* arg2); >>>> NOT CONVERTED
        // KPluginFactory* KPluginFactory(const KAboutData& arg1); >>>> NOT CONVERTED
        // KPluginFactory* KPluginFactory(KPluginFactoryPrivate& arg1,QObject* arg2); >>>> NOT CONVERTED
        // KPluginFactory* KPluginFactory(KPluginFactoryPrivate& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  This constructor creates a factory for a plugin with the given <pre>componentName</pre> and
        ///  <pre>catalogName</pre>. Those values are used to initialize a KComponentData object for the plugin.
        ///  You can later access it with componentData(). If <pre>componentName</pre> is 0, an invalid KComponentData
        ///  object will be created.
        ///  \param componentName the component name of the plugin
        ///  \param catalogName the translation catalog to use
        ///  \param parent a parent object
        ///      </remarks>        <short>    This constructor creates a factory for a plugin with the given \p componentName and  \p catalogName.</short>
        /// <remarks>
        ///  This constructor creates a factory for a plugin with the given KAboutData object. This object is
        ///  used to initialize a KComponentData object for the plugin. You can later access it with
        ///  componentData().
        ///  KPluginFactory takes ownership of the <pre>aboutData</pre> object, so don't delete it yourself!
        ///  \param aboutData the KAboutData for the plugin
        ///  \param parent a parent object
        ///      </remarks>        <short>    This constructor creates a factory for a plugin with the given KAboutData object.</short>
        /// <remarks>
        ///  You can use this method to get the component data of the plugin. It is filled with the
        ///  information given to the constructor of KPluginFactory.
        ///  The K_PLUGIN_FACTORY macros provide a static version of this method, this can be used from
        ///  any place within the plugin.
        ///  \returns The KComponentData for the plugin
        ///      </remarks>        <short>    You can use this method to get the component data of the plugin.</short>
        public KComponentData ComponentData() {
            return (KComponentData) interceptor.Invoke("componentData", "componentData() const", typeof(KComponentData));
        }
        /// <remarks>
        ///  Function pointer type to a function that instantiates a plugin.
        ///      </remarks>        <short>    Function pointer type to a function that instantiates a plugin.</short>
        /// <remarks>
        ///  \internal
        ///  Converts a List<string> to a QVariantList
        ///      </remarks>        <short>    \internal  Converts a List<string> to a QVariantList      </short>
        protected List<QVariant> StringListToVariantList(List<string> list) {
            return (List<QVariant>) interceptor.Invoke("stringListToVariantList?", "stringListToVariantList(const QStringList&)", typeof(List<QVariant>), typeof(List<string>), list);
        }
        /// <remarks>
        ///  \internal
        ///  Converts a QVariantList of strings to a List<string>
        ///      </remarks>        <short>    \internal  Converts a QVariantList of strings to a List<string>      </short>
        protected List<string> VariantListToStringList(List<QVariant> list) {
            return (List<string>) interceptor.Invoke("variantListToStringList?", "variantListToStringList(const QList<QVariant>&)", typeof(List<string>), typeof(List<QVariant>), list);
        }
        [SmokeMethod("setupTranslations()")]
        protected virtual void SetupTranslations() {
            interceptor.Invoke("setupTranslations", "setupTranslations()", typeof(void));
        }
        /// <remarks>
        ///  This method sets the component data of the plugin. You can access the component data object
        ///  later with componentData().
        ///  Normally you don't have to call this, because the factory constructs a component data object
        ///  from the information given to the constructor.
        ///  The object is destroyed, when the module containing the plugin is unloaded. Normally this happens
        ///  only on application shutdown.
        ///  \param componentData the new KComponentData object
        ///      </remarks>        <short>    This method sets the component data of the plugin.</short>
        protected void SetComponentData(KComponentData componentData) {
            interceptor.Invoke("setComponentData#", "setComponentData(const KComponentData&)", typeof(void), typeof(KComponentData), componentData);
        }
        /// <remarks>
        ///  This function is called when the factory asked to create an Object.
        ///  You may reimplement it to provide a very flexible factory. This is especially useful to
        ///  provide generic factories for plugins implemeted using a scripting language.
        ///  \param iface The staticMetaObject.ClassName() string identifying the plugin interface that
        ///  was requested. E.g. for KCModule plugins this string will be "KCModule".
        ///  \param parentWidget Only used if the requested plugin is a KPart.
        ///  \param parent The parent object for the plugin object.
        ///  \param args A plugin specific list of arbitrary arguments.
        ///  \param keyword A string that uniquely identifies the plugin. If a KService is used this
        ///  keyword is read from the X-KDE-PluginKeyword entry in the .desktop file.
        ///      </remarks>        <short>    This function is called when the factory asked to create an Object.</short>
        [SmokeMethod("create(const char*, QWidget*, QObject*, const QList<QVariant>&, const QString&)")]
        protected virtual QObject Create(string iface, QWidget parentWidget, QObject parent, List<QVariant> args, string keyword) {
            return (QObject) interceptor.Invoke("create$##?$", "create(const char*, QWidget*, QObject*, const QList<QVariant>&, const QString&)", typeof(QObject), typeof(string), iface, typeof(QWidget), parentWidget, typeof(QObject), parent, typeof(List<QVariant>), args, typeof(string), keyword);
        }
        ~KPluginFactory() {
            interceptor.Invoke("~KPluginFactory", "~KPluginFactory()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KPluginFactory", "~KPluginFactory()", typeof(void));
        }
        protected new IKPluginFactorySignals Emit {
            get { return (IKPluginFactorySignals) Q_EMIT; }
        }
    }

    public interface IKPluginFactorySignals : IQObjectSignals {
        [Q_SIGNAL("void objectCreated(QObject*)")]
        void ObjectCreated(QObject arg1);
    }
}
