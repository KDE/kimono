//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Text;
    using System.Collections.Generic;
    /// <remarks>
    ///  This class does shell-like completion of file names.
    ///  A string passed to makeCompletion() will be interpreted as a shell 
    ///  command line. Completion will be done on the last argument on the line. 
    ///  Returned matches consist of the first arguments (uncompleted) plus the 
    ///  completed last argument.
    /// </remarks>        <author> David Smith <dsmith@algonet.se>
    ///  </author>
    ///         <short> Shell-like completion of file names.</short>
    [SmokeClass("KShellCompletion")]
    public class KShellCompletion : KUrlCompletion, IDisposable {
        protected KShellCompletion(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KShellCompletion), this);
        }
        /// <remarks>
        ///  Constructs a KShellCompletion object.
        ///      </remarks>        <short>    Constructs a KShellCompletion object.</short>
        public KShellCompletion() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KShellCompletion", "KShellCompletion()", typeof(void));
        }
        /// <remarks>
        ///  Finds completions to the given text.
        ///  The first match is returned and emitted in the signal match().
        /// <param> name="text" the text to complete
        /// </param></remarks>        <return> the first match, or string() if not found
        ///      </return>
        ///         <short>    Finds completions to the given text.</short>
        [SmokeMethod("makeCompletion(const QString&)")]
        public override string MakeCompletion(string text) {
            return (string) interceptor.Invoke("makeCompletion$", "makeCompletion(const QString&)", typeof(string), typeof(string), text);
        }
        [SmokeMethod("postProcessMatch(QString*) const")]
        protected override void PostProcessMatch(StringBuilder match) {
            interceptor.Invoke("postProcessMatch$", "postProcessMatch(QString*) const", typeof(void), typeof(StringBuilder), match);
        }
        [SmokeMethod("postProcessMatches(QStringList*) const")]
        protected override void PostProcessMatches(List<string> matches) {
            interceptor.Invoke("postProcessMatches?", "postProcessMatches(QStringList*) const", typeof(void), typeof(List<string>), matches);
        }
        ~KShellCompletion() {
            interceptor.Invoke("~KShellCompletion", "~KShellCompletion()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KShellCompletion", "~KShellCompletion()", typeof(void));
        }
        protected new IKShellCompletionSignals Emit {
            get { return (IKShellCompletionSignals) Q_EMIT; }
        }
    }

    public interface IKShellCompletionSignals : IKUrlCompletionSignals {
    }
}
