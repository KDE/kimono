//Auto-generated by kalyptus. DO NOT EDIT.
namespace KKeyServer {
    using Kimono;
    using System;
    using Qyoto;
    /// <remarks>
    ///  A collection of functions for the conversion of key presses and
    ///  their modifiers from the window system specific format
    ///  to the generic format and vice-versa.
    ///  </remarks>        <short>    A collection of functions for the conversion of key presses and  their modifiers from the window system specific format  to the generic format and vice-versa.</short>
    [SmokeClass("KKeyServer")]
    public class Global {
        private static SmokeInvocation staticInterceptor = null;
        static Global() {
            staticInterceptor = new SmokeInvocation(typeof(Global), null);
        }
        public static int MODE_SWITCH() {
            return (int) staticInterceptor.Invoke("MODE_SWITCH", "MODE_SWITCH()", typeof(int));
        }
        // bool xEventToQt(XEvent* arg1,int* arg2); >>>> NOT CONVERTED
        /// <remarks>
        ///  Initialises the values to return for the mod() functions below.
        ///  Called automatically by those functions if not already initialized.
        /// 	 </remarks>        <short>    Initialises the values to return for the mod () functions below.</short>
        public static bool InitializeMods() {
            return (bool) staticInterceptor.Invoke("initializeMods", "initializeMods()", typeof(bool));
        }
        /// <remarks>
        ///  Returns true if the current keyboard layout supports the Meta key.
        ///  Specifically, whether the Super or Meta keys are assigned to an X modifier.
        /// </remarks>        <return> true if the keyboard has a Meta key
        /// </return>
        ///         <short>    Returns true if the current keyboard layout supports the Meta key.</short>
        ///         <see> modXMeta</see>
        public static bool KeyboardHasMetaKey() {
            return (bool) staticInterceptor.Invoke("keyboardHasMetaKey", "keyboardHasMetaKey()", typeof(bool));
        }
        /// <remarks>
        ///  Returns the X11 Shift modifier mask/flag.
        /// </remarks>        <return> the X11 Shift modifier mask/flag.
        /// </return>
        ///         <short>    Returns the X11 Shift modifier mask/flag.</short>
        ///         <see> accelModMaskX</see>
        public static uint ModXShift() {
            return (uint) staticInterceptor.Invoke("modXShift", "modXShift()", typeof(uint));
        }
        /// <remarks>
        ///  Returns the X11 Lock modifier mask/flag.
        /// </remarks>        <return> the X11 Lock modifier mask/flag.
        /// </return>
        ///         <short>    Returns the X11 Lock modifier mask/flag.</short>
        ///         <see> accelModMaskX</see>
        public static uint ModXLock() {
            return (uint) staticInterceptor.Invoke("modXLock", "modXLock()", typeof(uint));
        }
        /// <remarks>
        ///  Returns the X11 Ctrl modifier mask/flag.
        /// </remarks>        <return> the X11 Ctrl modifier mask/flag.
        /// </return>
        ///         <short>    Returns the X11 Ctrl modifier mask/flag.</short>
        ///         <see> accelModMaskX</see>
        public static uint ModXCtrl() {
            return (uint) staticInterceptor.Invoke("modXCtrl", "modXCtrl()", typeof(uint));
        }
        /// <remarks>
        ///  Returns the X11 Alt (Mod1) modifier mask/flag.
        /// </remarks>        <return> the X11 Alt (Mod1) modifier mask/flag.
        /// </return>
        ///         <short>    Returns the X11 Alt (Mod1) modifier mask/flag.</short>
        ///         <see> accelModMaskX</see>
        public static uint ModXAlt() {
            return (uint) staticInterceptor.Invoke("modXAlt", "modXAlt()", typeof(uint));
        }
        /// <remarks>
        ///  Returns the X11 Win (Mod3) modifier mask/flag.
        /// </remarks>        <return> the X11 Win (Mod3) modifier mask/flag.
        /// </return>
        ///         <short>    Returns the X11 Win (Mod3) modifier mask/flag.</short>
        ///         <see> keyboardHasWinKey</see>
        ///         <see> accelModMaskX</see>
        public static uint ModXMeta() {
            return (uint) staticInterceptor.Invoke("modXMeta", "modXMeta()", typeof(uint));
        }
        /// <remarks>
        ///  Returns the X11 NumLock modifier mask/flag.
        /// </remarks>        <return> the X11 NumLock modifier mask/flag.
        /// </return>
        ///         <short>    Returns the X11 NumLock modifier mask/flag.</short>
        ///         <see> accelModMaskX</see>
        public static uint ModXNumLock() {
            return (uint) staticInterceptor.Invoke("modXNumLock", "modXNumLock()", typeof(uint));
        }
        /// <remarks>
        ///  Returns the X11 ScrollLock modifier mask/flag.
        /// </remarks>        <return> the X11 ScrollLock modifier mask/flag.
        /// </return>
        ///         <short>    Returns the X11 ScrollLock modifier mask/flag.</short>
        ///         <see> accelModMaskX</see>
        public static uint ModXScrollLock() {
            return (uint) staticInterceptor.Invoke("modXScrollLock", "modXScrollLock()", typeof(uint));
        }
        /// <remarks>
        ///  Returns the X11 Mode_switch modifier mask/flag.
        /// </remarks>        <return> the X11 Mode_switch modifier mask/flag.
        /// </return>
        ///         <short>    Returns the X11 Mode_switch modifier mask/flag.</short>
        ///         <see> accelModMaskX</see>
        public static uint ModXModeSwitch() {
            return (uint) staticInterceptor.Invoke("modXModeSwitch", "modXModeSwitch()", typeof(uint));
        }
        /// <remarks>
        ///  Returns bitwise OR'ed mask containing Shift, Ctrl, Alt, and
        ///  Win (if available).
        /// </remarks>        <short>    Returns bitwise OR'ed mask containing Shift, Ctrl, Alt, and  Win (if available).</short>
        ///         <see> modXShift</see>
        ///         <see> modXLock</see>
        ///         <see> modXCtrl</see>
        ///         <see> modXAlt</see>
        ///         <see> modXNumLock</see>
        ///         <see> modXWin</see>
        ///         <see> modXScrollLock</see>
        public static uint AccelModMaskX() {
            return (uint) staticInterceptor.Invoke("accelModMaskX", "accelModMaskX()", typeof(uint));
        }
        /// <remarks>
        ///  Extracts the symbol from the given Qt key and
        ///  converts it to an X11 symbol + modifiers.
        /// <param> name="keyQt" the qt key code
        /// </param><param> name="sym" if successful, the symbol will be written here
        /// </param></remarks>        <return> true if successful, false otherwise
        /// 	 </return>
        ///         <short>    Extracts the symbol from the given Qt key and  converts it to an X11 symbol + modifiers.</short>
        public static bool KeyQtToSymX(int keyQt, ref int sym) {
            StackItem[] stack = new StackItem[3];
            stack[1].s_int = keyQt;
            stack[2].s_int = sym;
            staticInterceptor.Invoke("keyQtToSymX$$", "keyQtToSymX(int, int*)", stack);
            sym = stack[2].s_int;
            return stack[0].s_bool;
        }
        /// <remarks>
        ///  Extracts the code from the given Qt key.
        /// <param> name="keyQt" the qt key code
        /// </param><param> name="keyCode" if successful, the symbol will be written here
        /// </param></remarks>        <return> true if successful, false otherwise
        /// 	 </return>
        ///         <short>    Extracts the code from the given Qt key.</short>
        public static bool KeyQtToCodeX(int keyQt, ref int keyCode) {
            StackItem[] stack = new StackItem[3];
            stack[1].s_int = keyQt;
            stack[2].s_int = keyCode;
            staticInterceptor.Invoke("keyQtToCodeX$$", "keyQtToCodeX(int, int*)", stack);
            keyCode = stack[2].s_int;
            return stack[0].s_bool;
        }
        /// <remarks>
        ///  Extracts the modifiers from the given Qt key and
        ///  converts them in a mask of X11 modifiers.
        /// <param> name="keyQt" the qt key code
        /// </param><param> name="mod" if successful, the modifiers will be written here
        /// </param></remarks>        <return> true if successful, false otherwise
        /// 	 </return>
        ///         <short>    Extracts the modifiers from the given Qt key and  converts them in a mask of X11 modifiers.</short>
        public static bool KeyQtToModX(int keyQt, ref int mod) {
            StackItem[] stack = new StackItem[3];
            stack[1].s_int = keyQt;
            stack[2].s_int = mod;
            staticInterceptor.Invoke("keyQtToModX$$", "keyQtToModX(int, uint*)", stack);
            mod = stack[2].s_int;
            return stack[0].s_bool;
        }
        /// <remarks>
        ///  Converts the given symbol to a Qt key code.
        /// <param> name="sym" the symbol
        /// </param><param> name="keyQt" if successful, the qt key code will be written here
        /// </param></remarks>        <return> true if successful, false otherwise
        /// 	 </return>
        ///         <short>    Converts the given symbol to a Qt key code.</short>
        public static bool SymXToKeyQt(uint sym, ref int keyQt) {
            StackItem[] stack = new StackItem[3];
            stack[1].s_uint = sym;
            stack[2].s_int = keyQt;
            staticInterceptor.Invoke("symXToKeyQt$$", "symXToKeyQt(uint, int*)", stack);
            keyQt = stack[2].s_int;
            return stack[0].s_bool;
        }
        /// <remarks>
        ///  Converts the mask of ORed X11 modifiers to
        ///  a mask of ORed Qt key code modifiers.
        /// <param> name="modX" the mask of X11 modifiers
        /// </param><param> name="modQt" the mask of Qt key code modifiers will be written here
        ///         if successful
        /// </param></remarks>        <return> true if successful, false otherwise
        /// 	 </return>
        ///         <short>    Converts the mask of ORed X11 modifiers to  a mask of ORed Qt key code modifiers.</short>
        public static bool ModXToQt(uint modX, ref int modQt) {
            StackItem[] stack = new StackItem[3];
            stack[1].s_uint = modX;
            stack[2].s_int = modQt;
            staticInterceptor.Invoke("modXToQt$$", "modXToQt(uint, int*)", stack);
            modQt = stack[2].s_int;
            return stack[0].s_bool;
        }
        /// <remarks>
        ///  Converts an X keypress event into a Qt key + modifier code
        /// <param> name="e" the X11 keypress event
        /// </param><param> name="keyModQt" the Qt keycode and mask of Qt key code modifiers will be written here
        ///         if successful
        /// </param></remarks>        <return> true if successful, false otherwise
        /// 	 </return>
        ///         <short>    Converts an X keypress event into a Qt key + modifier code </short>
        /// <remarks>
        ///  Converts the mask of ORed KKey.ModFlag modifiers to a
        ///  user-readable string.
        /// <param> name="mod" the mask of ORed KKey.ModFlag modifiers
        /// </param></remarks>        <return> the user-readable string
        /// 	 </return>
        ///         <short>    Converts the mask of ORed KKey.ModFlag modifiers to a  user-readable string.</short>
        public static string ModToStringUser(uint mod) {
            return (string) staticInterceptor.Invoke("modToStringUser$", "modToStringUser(uint)", typeof(string), typeof(uint), mod);
        }
        /// <remarks>
        ///  Converts the modifier given as user-readable string
        ///  to KKey.ModFlag modifier, or 0.
        /// 	 </remarks>        <short>    Converts the modifier given as user-readable string  to KKey.ModFlag modifier, or 0.</short>
        public static uint StringUserToMod(string mod) {
            return (uint) staticInterceptor.Invoke("stringUserToMod$", "stringUserToMod(const QString&)", typeof(uint), typeof(string), mod);
        }
    }
}
