//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  The KACL class encapsulates a POSIX Access Control List. It follows the 
    ///  little standard that couldn't, 1003.1e/1003.2c, which died in draft status.
    /// </remarks>        <author> Till Adam <adam@kde.org>
    ///  </author>
    ///         <short> a POSIX ACL encapsulation.</short>
    [SmokeClass("KACL")]
    public class KACL : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KACL(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KACL), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KACL() {
            staticInterceptor = new SmokeInvocation(typeof(KACL), null);
        }
        /// <remarks>
        ///  Creates a new KACL from <code>aclString.</code> If the string is a valid acl
        ///  string, isValid() will afterwards return true.
        ///    </remarks>        <short>    Creates a new KACL from <code>aclString.</code></short>
        public KACL(string aclString) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KACL$", "KACL(const QString&)", typeof(void), typeof(string), aclString);
        }
        /// <remarks> Copy ctor </remarks>        <short>   Copy ctor </short>
        public KACL(KACL rhs) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KACL#", "KACL(const KACL&)", typeof(void), typeof(KACL), rhs);
        }
        /// <remarks> 
        ///  Creates a new KACL from the basic permissions passed in <code>basicPermissions.</code>
        ///  isValid() will return true, afterwards.
        ///    </remarks>        <short>     Creates a new KACL from the basic permissions passed in <code>basicPermissions.</code></short>
        public KACL(long basicPermissions) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KACL$", "KACL(mode_t)", typeof(void), typeof(long), basicPermissions);
        }
        /// <remarks>
        ///  Creates an empty KACL. Until a valid acl string is set via setACL,
        ///  isValid() will return false.
        ///    </remarks>        <short>    Creates an empty KACL.</short>
        public KACL() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KACL", "KACL()", typeof(void));
        }
        public override bool Equals(object o) {
            if (!(o is KACL)) { return false; }
            return this == (KACL) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        /// <remarks>
        ///  Returns whether the KACL object represents a valid acl.
        /// </remarks>        <return> whether the KACL object represents a valid acl.
        ///    </return>
        ///         <short>    Returns whether the KACL object represents a valid acl.</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks> @return the owner's premissions entry </remarks>        <short>   @return the owner's premissions entry </short>
        public ushort OwnerPermissions() {
            return (ushort) interceptor.Invoke("ownerPermissions", "ownerPermissions() const", typeof(ushort));
        }
        /// <remarks> Set the owner's permissions entry.
        ///   /* @return the owning group's premissions entry </remarks>        <return> success or failure */
        ///   bool setOwnerPermissions( unsigned short );
        /// </return>
        ///         <short>   Set the owner's permissions entry.</short>
        public ushort OwningGroupPermissions() {
            return (ushort) interceptor.Invoke("owningGroupPermissions", "owningGroupPermissions() const", typeof(ushort));
        }
        /// <remarks> Set the owning group's permissions entry.
        ///   /* @return the premissions entry for others </remarks>        <return> success or failure */
        ///   bool setOwningGroupPermissions( unsigned short );
        /// </return>
        ///         <short>   Set the owning group's permissions entry.</short>
        public ushort OthersPermissions() {
            return (ushort) interceptor.Invoke("othersPermissions", "othersPermissions() const", typeof(ushort));
        }
        /// <remarks> Set the permissions entry for others.
        ///   /* @return the basic (owner/group/others) part of the ACL as a mode_t </remarks>        <return> success or failure */
        ///   bool setOthersPermissions( unsigned short );
        /// </return>
        ///         <short>   Set the permissions entry for others.</short>
        public long BasePermissions() {
            return (long) interceptor.Invoke("basePermissions", "basePermissions() const", typeof(long));
        }
        /// <remarks>
        ///  Return whether the ACL contains extended entries or can be expressed
        ///  using only basic file permissions.
        ///   /*
        ///  Return the entry for the permissions mask if there is one and sets
        ///  <code>exists</code> to true. If there is no such entry, <code>exists</code> is set to false.
        ///   /* Set the permissions mask for the ACL. Permissions set for individual 
        ///  entries will be masked with this, such that their effective permissions
        ///  are the result of the logical and of their entry and the mask. 
        ///   /* 
        ///  Access to the permissions entry for a named user, if such an entry 
        ///  exists. If <code>exists</code> is non-null, the boolean variable it points to
        ///  is set to true if a matching entry exists and to false otherwise.
        ///   /* Set the permissions for a user with the name <code>name.</code> Will fail
        ///  if the user doesn't exist, in which case the ACL will be unchanged.
        ///   /* Returns the list of all group permission entries. Each entry consists
        ///  of a name/permissions pair. This is a QPair, therefore access is provided 
        ///  via the .first and .next members.
        ///   /* Replace the list of all user permissions with <code>list.</code> If one
        ///  of the entries in the list does not exists, or setting of the ACL
        ///  entry fails for any reason, the ACL will be left unchanged.
        ///   /*
        ///  Access to the permissions entry for a named group, if such an entry 
        ///  exists. If <code>exists</code> is non-null, the boolean variable it points to is
        ///  set to true if a matching entry exists and to false otherwise.
        ///   /* Set the permissions for a group with the name <code>name.</code> Will fail
        ///  if the group doesn't exist, in which case the ACL be unchanged.
        ///   /* Returns the list of all group permission entries. Each entry consists
        ///  of a name/permissions pair. This is a QPair, therefor access is provided 
        ///  via the .first and .next members.
        ///   ACLGroupPermissionsList allGroupPermissions() const;
        ///   /* Replace the list of all user permissions with <code>list.</code> If one
        ///  of the entries in the list does not exists, or setting of the ACL
        ///  entry fails for any reason, the ACL will be left unchanged.
        ///   /* Sets the whole list from a string. If the string in <code>aclStr</code> represents 
        ///  a valid ACL, it will be set, otherwise the ACL remains unchanged.
        ///   /* Return a string representation of the ACL.
        /// </remarks>        <return> a string version of the ACL in the format compatible with libacl and
        ///  POSIX 1003.1e. Implementations conforming to that standard should be able
        ///  to take such strings as input. </return>
        ///         <short>    Return whether the ACL contains extended entries or can be expressed  using only basic file permissions.</short>
        public string AsString() {
            return (string) interceptor.Invoke("asString", "asString() const", typeof(string));
        }
        ~KACL() {
            interceptor.Invoke("~KACL", "~KACL()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KACL", "~KACL()", typeof(void));
        }
        public static bool operator==(KACL lhs, KACL rhs) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KACL&) const", typeof(bool), typeof(KACL), lhs, typeof(KACL), rhs);
        }
        public static bool operator!=(KACL lhs, KACL rhs) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KACL&) const", typeof(bool), typeof(KACL), lhs, typeof(KACL), rhs);
        }
    }
}
