//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Runtime.InteropServices;
    /// <remarks>
    ///   This action shows up a submenu with a list of the available codecs on the system.
    ///   See <see cref="IKCodecActionSignals"></see> for signals emitted by KCodecAction
    /// </remarks>        <short> Action for selecting one of several QTextCodec. </short>
    [SmokeClass("KCodecAction")]
    public class KCodecAction : KSelectAction, IDisposable {
        protected KCodecAction(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KCodecAction), this);
        }
        [Q_PROPERTY("QString", "codecName")]
        public string CodecName {
            get { return (string) interceptor.Invoke("currentCodecName", "currentCodecName()", typeof(string)); }
            set { interceptor.Invoke("setCurrentCodec$", "setCurrentCodec(QString)", typeof(void), typeof(string), value); }
        }
        [Q_PROPERTY("int", "codecMib")]
        public int CodecMib {
            get { return (int) interceptor.Invoke("currentCodecMib", "currentCodecMib()", typeof(int)); }
        }
        public KCodecAction(QObject parent, bool showAutoOptions) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCodecAction#$", "KCodecAction(QObject*, bool)", typeof(void), typeof(QObject), parent, typeof(bool), showAutoOptions);
        }
        public KCodecAction(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCodecAction#", "KCodecAction(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public KCodecAction(string text, QObject parent, bool showAutoOptions) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCodecAction$#$", "KCodecAction(const QString&, QObject*, bool)", typeof(void), typeof(string), text, typeof(QObject), parent, typeof(bool), showAutoOptions);
        }
        public KCodecAction(string text, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCodecAction$#", "KCodecAction(const QString&, QObject*)", typeof(void), typeof(string), text, typeof(QObject), parent);
        }
        public KCodecAction(KIcon icon, string text, QObject parent, bool showAutoOptions) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCodecAction#$#$", "KCodecAction(const KIcon&, const QString&, QObject*, bool)", typeof(void), typeof(KIcon), icon, typeof(string), text, typeof(QObject), parent, typeof(bool), showAutoOptions);
        }
        public KCodecAction(KIcon icon, string text, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCodecAction#$#", "KCodecAction(const KIcon&, const QString&, QObject*)", typeof(void), typeof(KIcon), icon, typeof(string), text, typeof(QObject), parent);
        }
        public int MibForName(string codecName, ref bool ok) {
            StackItem[] stack = new StackItem[3];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(codecName);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(codecName);
#endif
            stack[2].s_bool = ok;
            interceptor.Invoke("mibForName$$", "mibForName(const QString&, bool*) const", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
            ok = stack[2].s_bool;
            return stack[0].s_int;
        }
        public int MibForName(string codecName) {
            return (int) interceptor.Invoke("mibForName$", "mibForName(const QString&) const", typeof(int), typeof(string), codecName);
        }
        public QTextCodec CodecForMib(int mib) {
            return (QTextCodec) interceptor.Invoke("codecForMib$", "codecForMib(int) const", typeof(QTextCodec), typeof(int), mib);
        }
        public QTextCodec CurrentCodec() {
            return (QTextCodec) interceptor.Invoke("currentCodec", "currentCodec() const", typeof(QTextCodec));
        }
        public bool SetCurrentCodec(QTextCodec codec) {
            return (bool) interceptor.Invoke("setCurrentCodec#", "setCurrentCodec(QTextCodec*)", typeof(bool), typeof(QTextCodec), codec);
        }
        public bool SetCurrentCodec(string codecName) {
            return (bool) interceptor.Invoke("setCurrentCodec$", "setCurrentCodec(const QString&)", typeof(bool), typeof(string), codecName);
        }
        /// <remarks>
        ///  Applicable only if showAutoOptions in c'tor was true
        /// </remarks>        <return> KEncodingDetector.None if specific encoding is selected, not autodetection, otherwise... you know it!
        ///          </return>
        ///         <short>    Applicable only if showAutoOptions in c'tor was true </short>
        public KEncodingDetector.AutoDetectScript CurrentAutoDetectScript() {
            return (KEncodingDetector.AutoDetectScript) interceptor.Invoke("currentAutoDetectScript", "currentAutoDetectScript() const", typeof(KEncodingDetector.AutoDetectScript));
        }
        /// <remarks>
        ///  Applicable only if showAutoOptions in c'tor was true
        ///  KEncodingDetector.SemiautomaticDetection means 'Default' item
        ///          </remarks>        <short>    Applicable only if showAutoOptions in c'tor was true </short>
        public bool SetCurrentAutoDetectScript(KEncodingDetector.AutoDetectScript arg1) {
            return (bool) interceptor.Invoke("setCurrentAutoDetectScript$", "setCurrentAutoDetectScript(KEncodingDetector::AutoDetectScript)", typeof(bool), typeof(KEncodingDetector.AutoDetectScript), arg1);
        }
        [Q_SLOT("void actionTriggered(QAction*)")]
        [SmokeMethod("actionTriggered(QAction*)")]
        protected override void ActionTriggered(QAction arg1) {
            interceptor.Invoke("actionTriggered#", "actionTriggered(QAction*)", typeof(void), typeof(QAction), arg1);
        }
        ~KCodecAction() {
            interceptor.Invoke("~KCodecAction", "~KCodecAction()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KCodecAction", "~KCodecAction()", typeof(void));
        }
        protected new IKCodecActionSignals Emit {
            get { return (IKCodecActionSignals) Q_EMIT; }
        }
    }

    public interface IKCodecActionSignals : IKSelectActionSignals {
        /// <remarks>
        ///  Specific (proper) codec was selected
        ///          </remarks>        <short>    Specific (proper) codec was selected          </short>
        [Q_SIGNAL("void triggered(QTextCodec*)")]
        void Triggered(QTextCodec codec);
        /// <remarks>
        ///  Specific (proper) codec was selected
        /// </remarks>        <return> codec name
        ///          </return>
        ///         <short>    Specific (proper) codec was selected </short>
        [Q_SIGNAL("void triggered(QString)")]
        void Triggered(string arg1);
        /// <remarks>
        ///  Autodetection has been selected.
        ///  emits KEncodingDetector.SemiautomaticDetection if Default was selected.
        ///  Applicable only if showAutoOptions in c'tor was true
        ///          </remarks>        <short>    Autodetection has been selected.</short>
        [Q_SIGNAL("void triggered(KEncodingDetector::AutoDetectScript)")]
        void Triggered(KEncodingDetector.AutoDetectScript arg1);
        /// <remarks>
        ///  If showAutoOptions==true, then better handle triggered(KEncodingDetector.AutoDetectScript) signal
        ///          </remarks>        <short>    If showAutoOptions==true, then better handle triggered(KEncodingDetector.AutoDetectScript) signal          </short>
        [Q_SIGNAL("void defaultItemTriggered()")]
        void DefaultItemTriggered();
    }
}
