//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///     This widget allows the user to select from a set of objects and arrange
    ///     the order of the selected ones using two list boxes labeled "Available"
    ///     and "Used" with horizontal arrows in between to move selected objects between
    ///     the two, and vertical arrows on the right to arrange the order of the selected
    ///     objects.
    ///     The widget moves objects to the other listbox when doubleclicked if
    ///     the property moveOnDoubleClick is set to true (default). See moveOnDoubleClick()
    ///     and setMoveOnDoubleClick().
    ///     The user control the widget using the keyboard if enabled (default),
    ///     see keyboardEnabled.
    ///     Note that this may conflist with keyboard selection in the selected list box,
    ///     if you set that to anything else than QListWidget.Single (which is the default).
    ///     To use it, simply construct an instance and then add items to the two listboxes,
    ///     available through lbAvailable() and lbSelected(). Whenever you want, you can retrieve
    ///     the selected options using QListWidget methods on lbSelected().
    ///     This way, you can use your own QListWidgetItem class, allowing you to easily
    ///     store object data in those.
    ///     When an item is moved to a listbox, it is placed below the current item
    ///     of that listbox.
    ///     Standard arrow icons are used, but you can use icons of your own choice if desired,
    ///     see setButtonIcon(). It is also possible to set tooltips and whatsthis help
    ///     for the buttons. See setButtonTooltip() and setButtonWhatsThis().
    ///     To set whatsthis or tooltips for the listboxes, access them through
    ///     availableListWidget() and selectedListWidget().
    ///     All the moving buttons are automatically set enabled as expected.
    ///     Signals are sent each time an item is moved, allowing you to follow the
    ///     users actions if you need to. See addedToSelection(), removedFromSelection(),
    ///     movedUp() and movedDown()
    ///  See <see cref="IKActionSelectorSignals"></see> for signals emitted by KActionSelector
    /// </remarks>        <author> Anders Lund <anders@alweb.dk>
    /// </author>
    ///         <short> A widget for selecting and arranging actions/objects.</short>
    [SmokeClass("KActionSelector")]
    public class KActionSelector : QWidget, IDisposable {
        protected KActionSelector(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KActionSelector), this);
        }
        /// <remarks>
        ///     This enum indentifies the moving buttons
        ///   </remarks>        <short>       This enum indentifies the moving buttons   </short>
        public enum MoveButton {
            ButtonAdd = 0,
            ButtonRemove = 1,
            ButtonUp = 2,
            ButtonDown = 3,
        }
        /// <remarks>
        ///     This enum defines policies for where to insert moved items in a listbox.
        ///     The following policies are currently defined:
        /// 
        /// <li>
        /// BelowCurrent - The item is inserted below the listbox'
        ///         currentItem() or at the end if there is no curent item.
        /// </li>
        /// 
        /// <li>
        /// Sorted - The listbox is sort()ed after one or more items are inserted.
        /// </li>
        /// 
        /// <li>
        /// AtTop - The item is inserted at index 0 in the listbox.
        /// </li>
        /// 
        /// <li>
        /// AtBottom - The item is inserted at the end of the listbox.
        /// </li>
        ///     @sa availableInsertionPolicy(), setAvailableInsertionPolicy(),
        ///     selectedInsertionPolicy(), setSelectedInsertionPolicy().
        ///   </remarks>        <short>       This enum defines policies for where to insert moved items in a listbox.</short>
        public enum InsertionPolicy {
            BelowCurrent = 0,
            Sorted = 1,
            AtTop = 2,
            AtBottom = 3,
        }
        [Q_PROPERTY("bool", "moveOnDoubleClick")]
        public bool MoveOnDoubleClick {
            get { return (bool) interceptor.Invoke("moveOnDoubleClick", "moveOnDoubleClick()", typeof(bool)); }
            set { interceptor.Invoke("setMoveOnDoubleClick$", "setMoveOnDoubleClick(bool)", typeof(void), typeof(bool), value); }
        }
        [Q_PROPERTY("bool", "keyboardEnabled")]
        public bool KeyboardEnabled {
            get { return (bool) interceptor.Invoke("keyboardEnabled", "keyboardEnabled()", typeof(bool)); }
            set { interceptor.Invoke("setKeyboardEnabled$", "setKeyboardEnabled(bool)", typeof(void), typeof(bool), value); }
        }
        [Q_PROPERTY("QString", "availableLabel")]
        public string AvailableLabel {
            get { return (string) interceptor.Invoke("availableLabel", "availableLabel()", typeof(string)); }
            set { interceptor.Invoke("setAvailableLabel$", "setAvailableLabel(QString)", typeof(void), typeof(string), value); }
        }
        [Q_PROPERTY("QString", "selectedLabel")]
        public string SelectedLabel {
            get { return (string) interceptor.Invoke("selectedLabel", "selectedLabel()", typeof(string)); }
            set { interceptor.Invoke("setSelectedLabel$", "setSelectedLabel(QString)", typeof(void), typeof(string), value); }
        }
        [Q_PROPERTY("KActionSelector::InsertionPolicy", "availableInsertionPolicy")]
        public KActionSelector.InsertionPolicy AvailableInsertionPolicy {
            get { return (KActionSelector.InsertionPolicy) interceptor.Invoke("availableInsertionPolicy", "availableInsertionPolicy()", typeof(KActionSelector.InsertionPolicy)); }
            set { interceptor.Invoke("setAvailableInsertionPolicy$", "setAvailableInsertionPolicy(KActionSelector::InsertionPolicy)", typeof(void), typeof(KActionSelector.InsertionPolicy), value); }
        }
        [Q_PROPERTY("KActionSelector::InsertionPolicy", "selectedInsertionPolicy")]
        public KActionSelector.InsertionPolicy SelectedInsertionPolicy {
            get { return (KActionSelector.InsertionPolicy) interceptor.Invoke("selectedInsertionPolicy", "selectedInsertionPolicy()", typeof(KActionSelector.InsertionPolicy)); }
            set { interceptor.Invoke("setSelectedInsertionPolicy$", "setSelectedInsertionPolicy(KActionSelector::InsertionPolicy)", typeof(void), typeof(KActionSelector.InsertionPolicy), value); }
        }
        [Q_PROPERTY("bool", "showUpDownButtons")]
        public bool ShowUpDownButtons {
            get { return (bool) interceptor.Invoke("showUpDownButtons", "showUpDownButtons()", typeof(bool)); }
            set { interceptor.Invoke("setShowUpDownButtons$", "setShowUpDownButtons(bool)", typeof(void), typeof(bool), value); }
        }
        public KActionSelector(QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KActionSelector#", "KActionSelector(QWidget*)", typeof(void), typeof(QWidget), parent);
        }
        public KActionSelector() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KActionSelector", "KActionSelector()", typeof(void));
        }
        /// <remarks>
        /// </remarks>        <return> The QListWidget holding the available actions
        ///   </return>
        ///         <short>   </short>
        public QListWidget AvailableListWidget() {
            return (QListWidget) interceptor.Invoke("availableListWidget", "availableListWidget() const", typeof(QListWidget));
        }
        /// <remarks>
        /// </remarks>        <return> The QListWidget holding the selected actions
        ///   </return>
        ///         <short>   </short>
        public QListWidget SelectedListWidget() {
            return (QListWidget) interceptor.Invoke("selectedListWidget", "selectedListWidget() const", typeof(QListWidget));
        }
        /// <remarks>
        ///     Sets the pixmap of the button <code>button</code> to <code>icon.</code>
        ///     It calls SmallIconSet(pm) to generate the icon set.
        ///   </remarks>        <short>       Sets the pixmap of the button <code>button</code> to <code>icon.</code></short>
        public void SetButtonIcon(string icon, KActionSelector.MoveButton button) {
            interceptor.Invoke("setButtonIcon$$", "setButtonIcon(const QString&, KActionSelector::MoveButton)", typeof(void), typeof(string), icon, typeof(KActionSelector.MoveButton), button);
        }
        /// <remarks>
        ///     Sets the iconset for button <code>button</code> to <code>iconset.</code>
        ///     You can use this method to et a costum icon set. Either
        ///     created by QIconSet, or use the application instance of
        ///     KIconLoader (recommended).
        ///   </remarks>        <short>       Sets the iconset for button <code>button</code> to <code>iconset.</code></short>
        public void SetButtonIconSet(QIcon iconset, KActionSelector.MoveButton button) {
            interceptor.Invoke("setButtonIconSet#$", "setButtonIconSet(const QIcon&, KActionSelector::MoveButton)", typeof(void), typeof(QIcon), iconset, typeof(KActionSelector.MoveButton), button);
        }
        /// <remarks>
        ///     Sets the tooltip for the button <code>button</code> to <code>tip.</code>
        ///   </remarks>        <short>       Sets the tooltip for the button <code>button</code> to <code>tip.</code></short>
        public void SetButtonTooltip(string tip, KActionSelector.MoveButton button) {
            interceptor.Invoke("setButtonTooltip$$", "setButtonTooltip(const QString&, KActionSelector::MoveButton)", typeof(void), typeof(string), tip, typeof(KActionSelector.MoveButton), button);
        }
        /// <remarks>
        ///     Sets the whatsthis help for button <code>button</code> to <code>text.</code>
        ///   </remarks>        <short>       Sets the whatsthis help for button <code>button</code> to <code>text.</code></short>
        public void SetButtonWhatsThis(string text, KActionSelector.MoveButton button) {
            interceptor.Invoke("setButtonWhatsThis$$", "setButtonWhatsThis(const QString&, KActionSelector::MoveButton)", typeof(void), typeof(string), text, typeof(KActionSelector.MoveButton), button);
        }
        /// <remarks>
        ///      Sets the enabled state of all moving buttons to reflect the current
        ///      options.
        ///      Be sure to call this if you add or removes items to either listbox after the
        ///      widget is show()n
        ///   </remarks>        <short>        Sets the enabled state of all moving buttons to reflect the current      options.</short>
        public void SetButtonsEnabled() {
            interceptor.Invoke("setButtonsEnabled", "setButtonsEnabled()", typeof(void));
        }
        /// <remarks>
        ///     Reimplemented for internal reasons.
        ///     (calls setButtonsEnabled())
        ///   </remarks>        <short>       Reimplemented for internal reasons.</short>
        [Q_SLOT("void polish()")]
        public void Polish() {
            interceptor.Invoke("polish", "polish()", typeof(void));
        }
        /// <remarks>
        ///     Reimplamented for internal reasons.
        ///   </remarks>        <short>       Reimplamented for internal reasons.</short>
        [SmokeMethod("keyPressEvent(QKeyEvent*)")]
        protected override void KeyPressEvent(QKeyEvent arg1) {
            interceptor.Invoke("keyPressEvent#", "keyPressEvent(QKeyEvent*)", typeof(void), typeof(QKeyEvent), arg1);
        }
        /// <remarks>
        ///     Reimplemented for internal reasons.
        ///   </remarks>        <short>       Reimplemented for internal reasons.</short>
        [SmokeMethod("eventFilter(QObject*, QEvent*)")]
        protected new virtual bool EventFilter(QObject arg1, QEvent arg2) {
            return (bool) interceptor.Invoke("eventFilter##", "eventFilter(QObject*, QEvent*)", typeof(bool), typeof(QObject), arg1, typeof(QEvent), arg2);
        }
        ~KActionSelector() {
            interceptor.Invoke("~KActionSelector", "~KActionSelector()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KActionSelector", "~KActionSelector()", typeof(void));
        }
        protected new IKActionSelectorSignals Emit {
            get { return (IKActionSelectorSignals) Q_EMIT; }
        }
    }

    public interface IKActionSelectorSignals : IQWidgetSignals {
        /// <remarks>
        ///     Emitted when an item is moved to the "selected" listbox.
        ///   </remarks>        <short>       Emitted when an item is moved to the "selected" listbox.</short>
        [Q_SIGNAL("void added(QListWidgetItem*)")]
        void Added(QListWidgetItem item);
        /// <remarks>
        ///     Emitted when an item is moved out of the "selected" listbox.
        ///   </remarks>        <short>       Emitted when an item is moved out of the "selected" listbox.</short>
        [Q_SIGNAL("void removed(QListWidgetItem*)")]
        void Removed(QListWidgetItem item);
        /// <remarks>
        ///     Emitted when an item is moved upwards in the "selected" listbox.
        ///   </remarks>        <short>       Emitted when an item is moved upwards in the "selected" listbox.</short>
        [Q_SIGNAL("void movedUp(QListWidgetItem*)")]
        void MovedUp(QListWidgetItem item);
        /// <remarks>
        ///     Emitted when an item is moved downwards in the "selected" listbox.
        ///   </remarks>        <short>       Emitted when an item is moved downwards in the "selected" listbox.</short>
        [Q_SIGNAL("void movedDown(QListWidgetItem*)")]
        void MovedDown(QListWidgetItem item);
    }
}
