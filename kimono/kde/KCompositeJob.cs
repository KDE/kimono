//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  The base class for all jobs able to be composed of one
    ///  or more subjobs.
    ///  </remarks>        <short>    The base class for all jobs able to be composed of one  or more subjobs.</short>
    [SmokeClass("KCompositeJob")]
    public class KCompositeJob : KJob, IDisposable {
        protected KCompositeJob(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KCompositeJob), this);
        }
        // KCompositeJob* KCompositeJob(KCompositeJobPrivate& arg1,QObject* arg2); >>>> NOT CONVERTED
        /// <remarks>
        ///  Creates a new KCompositeJob object.
        /// <param> name="parent" the parent QObject
        ///      </param></remarks>        <short>    Creates a new KCompositeJob object.</short>
        public KCompositeJob(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCompositeJob#", "KCompositeJob(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public KCompositeJob() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCompositeJob", "KCompositeJob()", typeof(void));
        }
        /// <remarks>
        ///  Add a job that has to be finished before a result
        ///  is emitted. This has obviously to be called before
        ///  the the result has been emitted by the job.
        /// <param> name="job" the subjob to add
        /// </param></remarks>        <return> true if the job has been added correctly, false otherwise
        ///      </return>
        ///         <short>    Add a job that has to be finished before a result  is emitted.</short>
        [SmokeMethod("addSubjob(KJob*)")]
        protected virtual bool AddSubjob(KJob job) {
            return (bool) interceptor.Invoke("addSubjob#", "addSubjob(KJob*)", typeof(bool), typeof(KJob), job);
        }
        /// <remarks>
        ///  Mark a sub job as being done.
        /// <param> name="job" the subjob to remove
        /// </param></remarks>        <return> true if the job has been removed correctly, false otherwise
        ///      </return>
        ///         <short>    Mark a sub job as being done.</short>
        [SmokeMethod("removeSubjob(KJob*)")]
        protected virtual bool RemoveSubjob(KJob job) {
            return (bool) interceptor.Invoke("removeSubjob#", "removeSubjob(KJob*)", typeof(bool), typeof(KJob), job);
        }
        /// <remarks>
        ///  Checks if this job has subjobs running.
        /// </remarks>        <return> true if we still have subjobs running, false otherwise
        ///      </return>
        ///         <short>    Checks if this job has subjobs running.</short>
        protected bool HasSubjobs() {
            return (bool) interceptor.Invoke("hasSubjobs", "hasSubjobs()", typeof(bool));
        }
        /// <remarks>
        ///  Retrieves the list of the subjobs.
        /// </remarks>        <return> the full list of sub jobs
        ///      </return>
        ///         <short>    Retrieves the list of the subjobs.</short>
        protected List<KJob> Subjobs() {
            return (List<KJob>) interceptor.Invoke("subjobs", "subjobs() const", typeof(List<KJob>));
        }
        /// <remarks>
        ///  Clears the list of subjobs.
        ///      </remarks>        <short>    Clears the list of subjobs.</short>
        protected void ClearSubjobs() {
            interceptor.Invoke("clearSubjobs", "clearSubjobs()", typeof(void));
        }
        /// <remarks>
        ///  Called whenever a subjob finishes.
        ///  Default implementation checks for errors and propagates
        ///  to parent job, and in all cases it calls removeSubjob.
        /// <param> name="job" the subjob
        ///      </param></remarks>        <short>    Called whenever a subjob finishes.</short>
        [Q_SLOT("void slotResult(KJob*)")]
        [SmokeMethod("slotResult(KJob*)")]
        protected virtual void SlotResult(KJob job) {
            interceptor.Invoke("slotResult#", "slotResult(KJob*)", typeof(void), typeof(KJob), job);
        }
        /// <remarks>
        ///  Forward signal from subjob.
        /// <param> name="job" the subjob
        /// </param><param> name="plain" the info message in plain text version
        /// </param><param> name="rich" the info message in rich text version
        /// </param></remarks>        <short>    Forward signal from subjob.</short>
        ///         <see> infoMessage</see>
        [Q_SLOT("void slotInfoMessage(KJob*, QString, QString)")]
        [SmokeMethod("slotInfoMessage(KJob*, const QString&, const QString&)")]
        protected virtual void SlotInfoMessage(KJob job, string plain, string rich) {
            interceptor.Invoke("slotInfoMessage#$$", "slotInfoMessage(KJob*, const QString&, const QString&)", typeof(void), typeof(KJob), job, typeof(string), plain, typeof(string), rich);
        }
        // WARNING: Unimplemented C++ pure virtual - DO NOT CALL
        [SmokeMethod("start()")]
        public override void Start() {
            interceptor.Invoke("start", "start()", typeof(void));
        }
        ~KCompositeJob() {
            interceptor.Invoke("~KCompositeJob", "~KCompositeJob()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KCompositeJob", "~KCompositeJob()", typeof(void));
        }
        protected new IKCompositeJobSignals Emit {
            get { return (IKCompositeJobSignals) Q_EMIT; }
        }
    }

    public interface IKCompositeJobSignals : IKJobSignals {
    }
}
