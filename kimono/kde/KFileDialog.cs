//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Text;
    using System.Collections.Generic;
    /// <remarks>
    ///  Provides a user (and developer) friendly way to
    ///  select files and directories.
    ///  The widget can be used as a drop in replacement for the
    ///  QFileDialog widget, but has greater functionality and a nicer GUI.
    ///  You will usually want to use one of the static methods
    ///  getOpenFileName(), getSaveFileName(), getOpenUrl()
    ///  or for multiple files getOpenFileNames() or getOpenUrls().
    ///  The dialog has been designed to allow applications to customize it
    ///  by subclassing. It uses geometry management to ensure that subclasses
    ///  can easily add children that will be incorporated into the layout.
    ///  \image html kfiledialog.png "KDE File Dialog"
    ///  See <see cref="IKFileDialogSignals"></see> for signals emitted by KFileDialog
    /// </remarks>        <author> Richard J. Moore <rich@kde.org>, Carsten Pfeiffer <pfeiffer@kde.org>
    ///  </author>
    ///         <short> A file selection dialog. </short>
    [SmokeClass("KFileDialog")]
    public class KFileDialog : KDialog, IDisposable {
        protected KFileDialog(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KFileDialog), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KFileDialog() {
            staticInterceptor = new SmokeInvocation(typeof(KFileDialog), null);
        }
        /// <remarks>
        ///  Defines some default behavior of the filedialog.
        ///  E.g. in mode <code>Opening</code> and <code>Saving</code>, the selected files/urls will
        ///  be added to the "recent documents" list. The Saving mode also implies
        ///  setKeepLocation() being set.
        ///  <code>Other</code> means that no default actions are performed.
        /// </remarks>        <short>    Defines some default behavior of the filedialog.</short>
        ///         <see> setOperationMode</see>
        ///         <see> operationMode</see>
        public enum OperationMode {
            Other = 0,
            Opening = 1,
            Saving = 2,
        }
        // KAbstractFileWidget* fileWidget(); >>>> NOT CONVERTED
        // KFileFilterCombo* filterWidget(); >>>> NOT CONVERTED
        /// <remarks>
        ///  Constructs a file dialog.
        /// <param> name="startDir" This can either be
        /// </param>
        /// <li>
        /// The URL of the directory to start in.
        /// </li>
        /// 
        /// <li>
        /// A KUrl() to start in the current working
        ///              directory, or the last directory where a file has been
        ///              selected.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;' to start in the
        ///              directory last used by a filedialog in the same application that specified
        ///              the same keyword.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;?global' to start
        ///              in the directory last used by a filedialog in any application that specified the
        ///              same keyword.
        /// </li>
        /// <param> name="filter" A shell glob or a mime-type-filter that specifies
        ///                which files to display.
        ///  See setFilter() and setMimeFilter() for details on how to use this argument.
        /// </param><param> name="parent" The parent widget of this dialog
        /// </param><param> name="widget" A widget, or a widget of widgets, for displaying custom
        ///                data in the dialog. This can be used, for example, to
        ///                display a check box with the caption "Open as read-only".
        ///                When creating this widget, you don't need to specify a parent,
        ///                since the widget's parent will be set automatically by KFileDialog.
        ///       </param></remarks>        <short>    Constructs a file dialog.</short>
        public KFileDialog(KUrl startDir, string filter, QWidget parent, QWidget widget) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KFileDialog#$##", "KFileDialog(const KUrl&, const QString&, QWidget*, QWidget*)", typeof(void), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent, typeof(QWidget), widget);
        }
        public KFileDialog(KUrl startDir, string filter, QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KFileDialog#$#", "KFileDialog(const KUrl&, const QString&, QWidget*)", typeof(void), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent);
        }
        /// <remarks>
        /// </remarks>        <return> The selected fully qualified filename.
        ///      </return>
        ///         <short>   </short>
        public KUrl SelectedUrl() {
            return (KUrl) interceptor.Invoke("selectedUrl", "selectedUrl() const", typeof(KUrl));
        }
        /// <remarks>
        /// </remarks>        <return> The list of selected URLs.
        ///      </return>
        ///         <short>   </short>
        public List<KUrl> SelectedUrls() {
            return (List<KUrl>) interceptor.Invoke("selectedUrls", "selectedUrls() const", typeof(List<KUrl>));
        }
        /// <remarks>
        /// </remarks>        <return> the currently shown directory.
        ///      </return>
        ///         <short>   </short>
        public KUrl BaseUrl() {
            return (KUrl) interceptor.Invoke("baseUrl", "baseUrl() const", typeof(KUrl));
        }
        /// <remarks>
        ///  Returns the full path of the selected file in the local filesystem.
        ///  (Local files only)
        ///      </remarks>        <short>    Returns the full path of the selected file in the local filesystem.</short>
        public string SelectedFile() {
            return (string) interceptor.Invoke("selectedFile", "selectedFile() const", typeof(string));
        }
        /// <remarks>
        ///  Returns a list of all selected local files.
        ///      </remarks>        <short>    Returns a list of all selected local files.</short>
        public List<string> SelectedFiles() {
            return (List<string>) interceptor.Invoke("selectedFiles", "selectedFiles() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Sets the directory to view.
        /// <param> name="url" URL to show.
        /// </param><param> name="clearforward" Indicates whether the forward queue
        ///  should be cleared.
        ///      </param></remarks>        <short>    Sets the directory to view.</short>
        public void SetUrl(KUrl url, bool clearforward) {
            interceptor.Invoke("setUrl#$", "setUrl(const KUrl&, bool)", typeof(void), typeof(KUrl), url, typeof(bool), clearforward);
        }
        public void SetUrl(KUrl url) {
            interceptor.Invoke("setUrl#", "setUrl(const KUrl&)", typeof(void), typeof(KUrl), url);
        }
        /// <remarks>
        ///  Sets the file name to preselect to <code>name</code>
        ///  This takes absolute URLs and relative file names.
        ///      </remarks>        <short>    Sets the file name to preselect to <code>name</code> </short>
        public void SetSelection(string name) {
            interceptor.Invoke("setSelection$", "setSelection(const QString&)", typeof(void), typeof(string), name);
        }
        /// <remarks>
        ///  Sets the operational mode of the filedialog to <code>Saving</code>, <code>Opening</code>
        ///  or <code>Other.</code> This will set some flags that are specific to loading
        ///  or saving files. E.g. setKeepLocation() makes mostly sense for
        ///  a save-as dialog. So setOperationMode( KFileDialog.Saving ); sets
        ///  setKeepLocation for example.
        ///  The mode <code>Saving</code>, together with a default filter set via
        ///  setMimeFilter() will make the filter combobox read-only.
        ///  The default mode is <code>Opening.</code>
        ///  Call this method right after instantiating KFileDialog.
        /// </remarks>        <short>    Sets the operational mode of the filedialog to <code>Saving</code>, <code>Opening</code>  or <code>Other.</code></short>
        ///         <see> operationMode</see>
        ///         <see> KFileDialog.OperationMode</see>
        public void SetOperationMode(KFileDialog.OperationMode arg1) {
            interceptor.Invoke("setOperationMode$", "setOperationMode(KFileDialog::OperationMode)", typeof(void), typeof(KFileDialog.OperationMode), arg1);
        }
        /// <remarks>
        /// </remarks>        <return> the current operation mode, Opening, Saving or Other. Default
        ///  is Other.
        /// </return>
        ///         <short>   </short>
        ///         <see> operationMode</see>
        ///         <see> KFileDialog.OperationMode</see>
        public KFileDialog.OperationMode operationMode() {
            return (KFileDialog.OperationMode) interceptor.Invoke("operationMode", "operationMode() const", typeof(KFileDialog.OperationMode));
        }
        /// <remarks>
        ///  Sets whether the filename/url should be kept when changing directories.
        ///  This is for example useful when having a predefined filename where
        ///  the full path for that file is searched.
        ///  This is implicitly set when operationMode() is KFileDialog.Saving
        ///  getSaveFileName() and getSaveUrl() set this to true by default, so that
        ///  you can type in the filename and change the directory without having
        ///  to type the name again.
        ///      </remarks>        <short>    Sets whether the filename/url should be kept when changing directories.</short>
        public void SetKeepLocation(bool keep) {
            interceptor.Invoke("setKeepLocation$", "setKeepLocation(bool)", typeof(void), typeof(bool), keep);
        }
        /// <remarks>
        /// </remarks>        <return> whether the contents of the location edit are kept when
        ///  changing directories.
        ///      </return>
        ///         <short>   </short>
        public bool KeepsLocation() {
            return (bool) interceptor.Invoke("keepsLocation", "keepsLocation() const", typeof(bool));
        }
        /// <remarks>
        ///  Sets the filter to be used to <code>filter.</code>
        ///  You can set more
        ///  filters for the user to select separated by @c '\\n'. Every
        ///  filter entry is defined through <code>namefilter</code>|text to display.
        ///  If no @c '|' is found in the expression, just the namefilter is
        ///  shown. Examples:
        ///  <pre>
        ///  kfile.SetFilter("*.cpp|C++ Source Files\n.h|Header files");
        ///  kfile.SetFilter("*.cpp");
        ///  kfile.SetFilter("*.cpp|Sources (.cpp)");
        ///  kfile.SetFilter("*.cpp|" + i18n("Sources (.cpp)"));
        ///  kfile.SetFilter("*.cpp .cc .C|C++ Source Files\n.h .H|Header files");
        ///  </pre>
        ///  Note: The text to display is not parsed in any way. So, if you
        ///  want to show the suffix to select by a specific filter, you must
        ///  repeat it.
        ///  If the filter contains an unescaped @c '/', a mimetype-filter is assumed.
        ///  If you would like a '/' visible in your filter it can be escaped with
        ///  a @c '\'. You can specify multiple mimetypes like this (separated with
        ///  space):
        ///  <pre>
        ///  kfile.SetFilter( "image/png text/html text/plain" );
        ///  kfile.SetFilter( "*.cue|CUE\\/BIN Files (.cue)" );
        ///  </pre>
        /// </remarks>        <short>    Sets the filter to be used to <code>filter.</code></short>
        ///         <see> filterChanged</see>
        ///         <see> setMimeFilter</see>
        public void SetFilter(string filter) {
            interceptor.Invoke("setFilter$", "setFilter(const QString&)", typeof(void), typeof(string), filter);
        }
        /// <remarks>
        ///  Returns the current filter as entered by the user or one of the
        ///  predefined set via setFilter().
        /// </remarks>        <short>    Returns the current filter as entered by the user or one of the  predefined set via setFilter().</short>
        ///         <see> setFilter</see>
        ///         <see> filterChanged</see>
        public string CurrentFilter() {
            return (string) interceptor.Invoke("currentFilter", "currentFilter() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the mimetype for the desired output format.
        ///  This is only valid if setMimeFilter() has been called
        ///  previously.
        /// </remarks>        <short>    Returns the mimetype for the desired output format.</short>
        ///         <see> setFilterMimeType</see>
        public KMimeType CurrentFilterMimeType() {
            return (KMimeType) interceptor.Invoke("currentFilterMimeType", "currentFilterMimeType()", typeof(KMimeType));
        }
        /// <remarks>
        ///  Sets the filter up to specify the output type.
        /// <param> name="types" a list of mimetypes that can be used as output format
        /// </param><param> name="defaultType" the default mimetype to use as output format, if any.
        ///  If <code>defaultType</code> is set, it will be set as the current item.
        ///  Otherwise, a first item showing all the mimetypes will be created.
        ///  Typically, <code>defaultType</code> should be empty for loading and set for saving.
        /// </param> Do not use in conjunction with setFilter()
        ///      </remarks>        <short>    Sets the filter up to specify the output type.</short>
        public void SetMimeFilter(List<string> types, string defaultType) {
            interceptor.Invoke("setMimeFilter?$", "setMimeFilter(const QStringList&, const QString&)", typeof(void), typeof(List<string>), types, typeof(string), defaultType);
        }
        public void SetMimeFilter(List<string> types) {
            interceptor.Invoke("setMimeFilter?", "setMimeFilter(const QStringList&)", typeof(void), typeof(List<string>), types);
        }
        /// <remarks>
        ///  The mimetype for the desired output format.
        ///  This is only valid if setMimeFilter() has been called
        ///  previously.
        /// </remarks>        <short>    The mimetype for the desired output format.</short>
        ///         <see> setMimeFilter</see>
        public string CurrentMimeFilter() {
            return (string) interceptor.Invoke("currentMimeFilter", "currentMimeFilter() const", typeof(string));
        }
        /// <remarks>
        ///   Clears any mime- or namefilter. Does not reload the directory.
        ///      </remarks>        <short>     Clears any mime- or namefilter.</short>
        public void ClearFilter() {
            interceptor.Invoke("clearFilter", "clearFilter()", typeof(void));
        }
        /// <remarks>
        ///  Adds a preview widget and enters the preview mode.
        ///  In this mode the dialog is split and the right part contains your
        ///  preview widget.
        ///  Ownership is transferred to KFileDialog. You need to create the
        ///  preview-widget with "new", i.e. on the heap.
        /// <param> name="w" The widget to be used for the preview.
        ///      </param></remarks>        <short>    Adds a preview widget and enters the preview mode.</short>
        public void SetPreviewWidget(KPreviewWidgetBase w) {
            interceptor.Invoke("setPreviewWidget#", "setPreviewWidget(KPreviewWidgetBase*)", typeof(void), typeof(KPreviewWidgetBase), w);
        }
        /// <remarks> @see QWidget.SizeHint() </remarks>        <short>   @see QWidget.SizeHint() </short>
        [SmokeMethod("sizeHint() const")]
        public override QSize SizeHint() {
            return (QSize) interceptor.Invoke("sizeHint", "sizeHint() const", typeof(QSize));
        }
        /// <remarks>
        ///  Sets the mode of the dialog.
        ///  The mode is defined as (in kfile.h):
        ///  <pre>
        ///     enum Mode {
        ///          File         = 1,
        ///          Directory    = 2,
        ///          Files        = 4,
        ///          ExistingOnly = 8,
        ///          LocalOnly    = 16
        ///     }
        ///  </pre>
        ///  You can OR the values, e.g.
        ///  <pre>
        ///  KFile.Modes mode = KFile.Files |
        ///                      KFile.ExistingOnly |
        ///                      KFile.LocalOnly );
        ///  setMode( mode );
        ///  </pre>
        ///      </remarks>        <short>    Sets the mode of the dialog.</short>
        public void SetMode(uint m) {
            interceptor.Invoke("setMode$", "setMode(KFile::Modes)", typeof(void), typeof(uint), m);
        }
        /// <remarks>
        ///  Returns the mode of the filedialog.
        /// </remarks>        <short>    Returns the mode of the filedialog.</short>
        ///         <see> setMode</see>
        public uint Mode() {
            return (uint) interceptor.Invoke("mode", "mode() const", typeof(uint));
        }
        /// <remarks>
        ///  Sets the text to be displayed in front of the selection.
        ///  The default is "Location".
        ///  Most useful if you want to make clear what
        ///  the location is used for.
        ///      </remarks>        <short>    Sets the text to be displayed in front of the selection.</short>
        public void SetLocationLabel(string text) {
            interceptor.Invoke("setLocationLabel$", "setLocationLabel(const QString&)", typeof(void), typeof(string), text);
        }
        /// <remarks>
        ///  Returns the KFileWidget that implements most of this file dialog.
        ///  If you link to libkfile you can cast this to a KFileWidget.
        ///      </remarks>        <short>    Returns the KFileWidget that implements most of this file dialog.</short>
        /// <remarks>
        ///  Returns a pointer to the toolbar.
        ///  You can use this to insert custom
        ///  items into it, e.g.:
        ///  <pre>
        ///       yourAction = new KAction( i18n("Your Action"), 0,
        ///                                 this, SLOT("yourSlot()"),
        ///                                 this, "action name" );
        ///       yourAction.Plug( kfileDialog.ToolBar() );
        ///  </pre>
        ///      </remarks>        <short>    Returns a pointer to the toolbar.</short>
        public KToolBar ToolBar() {
            return (KToolBar) interceptor.Invoke("toolBar", "toolBar() const", typeof(KToolBar));
        }
        /// <remarks>
        /// </remarks>        <return> a pointer to the OK-Button in the filedialog. You may use it
        ///  e.g. to set a custom text to it.
        ///      </return>
        ///         <short>   </short>
        public KPushButton OkButton() {
            return (KPushButton) interceptor.Invoke("okButton", "okButton() const", typeof(KPushButton));
        }
        /// <remarks>
        /// </remarks>        <return> a pointer to the Cancel-Button in the filedialog. You may use
        ///  it e.g. to set a custom text to it.
        ///      </return>
        ///         <short>   </short>
        public KPushButton CancelButton() {
            return (KPushButton) interceptor.Invoke("cancelButton", "cancelButton() const", typeof(KPushButton));
        }
        /// <remarks>
        /// </remarks>        <return> the combobox used to type the filename or full location of the file.
        ///  You need to link to libkfile to use this widget.
        ///      </return>
        ///         <short>   </short>
        public KUrlComboBox LocationEdit() {
            return (KUrlComboBox) interceptor.Invoke("locationEdit", "locationEdit() const", typeof(KUrlComboBox));
        }
        /// <remarks>
        /// </remarks>        <return> the combobox that contains the filters
        ///  You need to link to libkfile to use this widget.
        ///      </return>
        ///         <short>   </short>
        /// <remarks>
        /// </remarks>        <return> a pointer to the action collection, holding all the used KActions.
        ///      </return>
        ///         <short>   </short>
        public KActionCollection ActionCollection() {
            return (KActionCollection) interceptor.Invoke("actionCollection", "actionCollection() const", typeof(KActionCollection));
        }
        /// <remarks>
        ///  Reimplemented to animate the cancel button.
        ///      </remarks>        <short>    Reimplemented to animate the cancel button.</short>
        [SmokeMethod("keyPressEvent(QKeyEvent*)")]
        protected override void KeyPressEvent(QKeyEvent e) {
            interceptor.Invoke("keyPressEvent#", "keyPressEvent(QKeyEvent*)", typeof(void), typeof(QKeyEvent), e);
        }
        /// <remarks>
        ///  Reimplemented for saving the dialog geometry.
        ///      </remarks>        <short>    Reimplemented for saving the dialog geometry.</short>
        [SmokeMethod("hideEvent(QHideEvent*)")]
        protected override void HideEvent(QHideEvent arg1) {
            interceptor.Invoke("hideEvent#", "hideEvent(QHideEvent*)", typeof(void), typeof(QHideEvent), arg1);
        }
        [Q_SLOT("void slotOk()")]
        [SmokeMethod("slotOk()")]
        protected virtual void SlotOk() {
            interceptor.Invoke("slotOk", "slotOk()", typeof(void));
        }
        [Q_SLOT("void accept()")]
        [SmokeMethod("accept()")]
        protected new virtual void Accept() {
            interceptor.Invoke("accept", "accept()", typeof(void));
        }
        [Q_SLOT("void slotCancel()")]
        [SmokeMethod("slotCancel()")]
        protected virtual void SlotCancel() {
            interceptor.Invoke("slotCancel", "slotCancel()", typeof(void));
        }
        ~KFileDialog() {
            interceptor.Invoke("~KFileDialog", "~KFileDialog()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KFileDialog", "~KFileDialog()", typeof(void));
        }
        /// <remarks>
        ///  Creates a modal file dialog and return the selected
        ///  filename or an empty string if none was chosen.
        ///  Note that with
        ///  this method the user must select an existing filename.
        /// <param> name="startDir" This can either be
        /// </param>
        /// <li>
        /// The URL of the directory to start in.
        /// </li>
        /// 
        /// <li>
        /// A KUrl() to start in the current working
        ///              directory, or the last directory where a file has been
        ///              selected.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;' to start in the
        ///              directory last used by a filedialog in the same application that specified
        ///              the same keyword.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;?global' to start
        ///              in the directory last used by a filedialog in any application that specified the
        ///              same keyword.
        /// </li>
        /// <param> name="filter" A shell glob or a mime-type-filter that specifies which files to display.
        ///     The preferred option is to set a list of mimetype names, see setMimeFilter() for details.
        ///     Otherwise you can set the text to be displayed for the each glob, and
        ///     provide multiple globs, see setFilter() for details.
        /// </param><param> name="parent" The widget the dialog will be centered on initially.
        /// </param><param> name="caption" The name of the dialog widget.
        ///      </param></remarks>        <short>    Creates a modal file dialog and return the selected  filename or an empty string if none was chosen.</short>
        public static string GetOpenFileName(KUrl startDir, string filter, QWidget parent, string caption) {
            return (string) staticInterceptor.Invoke("getOpenFileName#$#$", "getOpenFileName(const KUrl&, const QString&, QWidget*, const QString&)", typeof(string), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent, typeof(string), caption);
        }
        public static string GetOpenFileName(KUrl startDir, string filter, QWidget parent) {
            return (string) staticInterceptor.Invoke("getOpenFileName#$#", "getOpenFileName(const KUrl&, const QString&, QWidget*)", typeof(string), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent);
        }
        public static string GetOpenFileName(KUrl startDir, string filter) {
            return (string) staticInterceptor.Invoke("getOpenFileName#$", "getOpenFileName(const KUrl&, const QString&)", typeof(string), typeof(KUrl), startDir, typeof(string), filter);
        }
        public static string GetOpenFileName(KUrl startDir) {
            return (string) staticInterceptor.Invoke("getOpenFileName#", "getOpenFileName(const KUrl&)", typeof(string), typeof(KUrl), startDir);
        }
        public static string GetOpenFileName() {
            return (string) staticInterceptor.Invoke("getOpenFileName", "getOpenFileName()", typeof(string));
        }
        /// <remarks>
        ///  Use this version only if you have no QWidget available as
        ///  parent widget. This can be the case if the parent widget is
        ///  a widget in another process or if the parent widget is a
        ///  non-Qt widget. For example, in a GTK program.
        ///     </remarks>        <short>    Use this version only if you have no QWidget available as  parent widget.</short>
        public static string GetOpenFileNameWId(KUrl startDir, string filter, uint parent_id, string caption) {
            return (string) staticInterceptor.Invoke("getOpenFileNameWId#$$$", "getOpenFileNameWId(const KUrl&, const QString&, WId, const QString&)", typeof(string), typeof(KUrl), startDir, typeof(string), filter, typeof(uint), parent_id, typeof(string), caption);
        }
        /// <remarks>
        ///  Creates a modal file dialog and returns the selected
        ///  filenames or an empty list if none was chosen.
        ///  Note that with
        ///  this method the user must select an existing filename.
        /// <param> name="startDir" This can either be
        /// </param>
        /// <li>
        /// The URL of the directory to start in.
        /// </li>
        /// 
        /// <li>
        /// A KUrl() to start in the current working
        ///              directory, or the last directory where a file has been
        ///              selected.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;' to start in the
        ///              directory last used by a filedialog in the same application that specified
        ///              the same keyword.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;?global' to start
        ///              in the directory last used by a filedialog in any application that specified the
        ///              same keyword.
        /// </li>
        /// <param> name="filter" A shell glob or a mime-type-filter that specifies which files to display.
        ///     The preferred option is to set a list of mimetype names, see setMimeFilter() for details.
        ///     Otherwise you can set the text to be displayed for the each glob, and
        ///     provide multiple globs, see setFilter() for details.
        /// </param><param> name="parent" The widget the dialog will be centered on initially.
        /// </param><param> name="caption" The name of the dialog widget.
        ///      </param></remarks>        <short>    Creates a modal file dialog and returns the selected  filenames or an empty list if none was chosen.</short>
        public static List<string> GetOpenFileNames(KUrl startDir, string filter, QWidget parent, string caption) {
            return (List<string>) staticInterceptor.Invoke("getOpenFileNames#$#$", "getOpenFileNames(const KUrl&, const QString&, QWidget*, const QString&)", typeof(List<string>), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent, typeof(string), caption);
        }
        public static List<string> GetOpenFileNames(KUrl startDir, string filter, QWidget parent) {
            return (List<string>) staticInterceptor.Invoke("getOpenFileNames#$#", "getOpenFileNames(const KUrl&, const QString&, QWidget*)", typeof(List<string>), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent);
        }
        public static List<string> GetOpenFileNames(KUrl startDir, string filter) {
            return (List<string>) staticInterceptor.Invoke("getOpenFileNames#$", "getOpenFileNames(const KUrl&, const QString&)", typeof(List<string>), typeof(KUrl), startDir, typeof(string), filter);
        }
        public static List<string> GetOpenFileNames(KUrl startDir) {
            return (List<string>) staticInterceptor.Invoke("getOpenFileNames#", "getOpenFileNames(const KUrl&)", typeof(List<string>), typeof(KUrl), startDir);
        }
        public static List<string> GetOpenFileNames() {
            return (List<string>) staticInterceptor.Invoke("getOpenFileNames", "getOpenFileNames()", typeof(List<string>));
        }
        /// <remarks>
        ///  Creates a modal file dialog and returns the selected
        ///  URL or an empty string if none was chosen.
        ///  Note that with
        ///  this method the user must select an existing URL.
        /// <param> name="startDir" This can either be
        /// </param>
        /// <li>
        /// The URL of the directory to start in.
        /// </li>
        /// 
        /// <li>
        /// A KUrl() to start in the current working
        ///              directory, or the last directory where a file has been
        ///              selected.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;' to start in the
        ///              directory last used by a filedialog in the same application that specified
        ///              the same keyword.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;?global' to start
        ///              in the directory last used by a filedialog in any application that specified the
        ///              same keyword.
        /// </li>
        /// <param> name="filter" A shell glob or a mime-type-filter that specifies which files to display.
        ///     The preferred option is to set a list of mimetype names, see setMimeFilter() for details.
        ///     Otherwise you can set the text to be displayed for the each glob, and
        ///     provide multiple globs, see setFilter() for details.
        /// </param><param> name="parent" The widget the dialog will be centered on initially.
        /// </param><param> name="caption" The name of the dialog widget.
        ///      </param></remarks>        <short>    Creates a modal file dialog and returns the selected  URL or an empty string if none was chosen.</short>
        public static KUrl GetOpenUrl(KUrl startDir, string filter, QWidget parent, string caption) {
            return (KUrl) staticInterceptor.Invoke("getOpenUrl#$#$", "getOpenUrl(const KUrl&, const QString&, QWidget*, const QString&)", typeof(KUrl), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent, typeof(string), caption);
        }
        public static KUrl GetOpenUrl(KUrl startDir, string filter, QWidget parent) {
            return (KUrl) staticInterceptor.Invoke("getOpenUrl#$#", "getOpenUrl(const KUrl&, const QString&, QWidget*)", typeof(KUrl), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent);
        }
        public static KUrl GetOpenUrl(KUrl startDir, string filter) {
            return (KUrl) staticInterceptor.Invoke("getOpenUrl#$", "getOpenUrl(const KUrl&, const QString&)", typeof(KUrl), typeof(KUrl), startDir, typeof(string), filter);
        }
        public static KUrl GetOpenUrl(KUrl startDir) {
            return (KUrl) staticInterceptor.Invoke("getOpenUrl#", "getOpenUrl(const KUrl&)", typeof(KUrl), typeof(KUrl), startDir);
        }
        public static KUrl GetOpenUrl() {
            return (KUrl) staticInterceptor.Invoke("getOpenUrl", "getOpenUrl()", typeof(KUrl));
        }
        /// <remarks>
        ///  Creates a modal file dialog and returns the selected
        ///  URLs or an empty list if none was chosen.
        ///  Note that with
        ///  this method the user must select an existing filename.
        /// <param> name="startDir" This can either be
        /// </param>
        /// <li>
        /// The URL of the directory to start in.
        /// </li>
        /// 
        /// <li>
        /// A KUrl() to start in the current working
        ///              directory, or the last directory where a file has been
        ///              selected.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;' to start in the
        ///              directory last used by a filedialog in the same application that specified
        ///              the same keyword.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;?global' to start
        ///              in the directory last used by a filedialog in any application that specified the
        ///              same keyword.
        /// </li>
        /// <param> name="filter" A shell glob or a mime-type-filter that specifies which files to display.
        ///     The preferred option is to set a list of mimetype names, see setMimeFilter() for details.
        ///     Otherwise you can set the text to be displayed for the each glob, and
        ///     provide multiple globs, see setFilter() for details.
        /// </param><param> name="parent" The widget the dialog will be centered on initially.
        /// </param><param> name="caption" The name of the dialog widget.
        ///      </param></remarks>        <short>    Creates a modal file dialog and returns the selected  URLs or an empty list if none was chosen.</short>
        public static List<KUrl> GetOpenUrls(KUrl startDir, string filter, QWidget parent, string caption) {
            return (List<KUrl>) staticInterceptor.Invoke("getOpenUrls#$#$", "getOpenUrls(const KUrl&, const QString&, QWidget*, const QString&)", typeof(List<KUrl>), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent, typeof(string), caption);
        }
        public static List<KUrl> GetOpenUrls(KUrl startDir, string filter, QWidget parent) {
            return (List<KUrl>) staticInterceptor.Invoke("getOpenUrls#$#", "getOpenUrls(const KUrl&, const QString&, QWidget*)", typeof(List<KUrl>), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent);
        }
        public static List<KUrl> GetOpenUrls(KUrl startDir, string filter) {
            return (List<KUrl>) staticInterceptor.Invoke("getOpenUrls#$", "getOpenUrls(const KUrl&, const QString&)", typeof(List<KUrl>), typeof(KUrl), startDir, typeof(string), filter);
        }
        public static List<KUrl> GetOpenUrls(KUrl startDir) {
            return (List<KUrl>) staticInterceptor.Invoke("getOpenUrls#", "getOpenUrls(const KUrl&)", typeof(List<KUrl>), typeof(KUrl), startDir);
        }
        public static List<KUrl> GetOpenUrls() {
            return (List<KUrl>) staticInterceptor.Invoke("getOpenUrls", "getOpenUrls()", typeof(List<KUrl>));
        }
        /// <remarks>
        ///  Creates a modal file dialog and returns the selected
        ///  filename or an empty string if none was chosen.
        ///  Note that with this
        ///  method the user need not select an existing filename.
        /// <param> name="startDir" This can either be
        /// </param>
        /// <li>
        /// The URL of the directory to start in.
        /// </li>
        /// 
        /// <li>
        /// A KUrl() to start in the current working
        ///              directory, or the last directory where a file has been
        ///              selected.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;' to start in the
        ///              directory last used by a filedialog in the same application that specified
        ///              the same keyword.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;?global' to start
        ///              in the directory last used by a filedialog in any application that specified the
        ///              same keyword.
        /// </li>
        /// <param> name="filter" A shell glob or a mime-type-filter that specifies which files to display.
        ///     The preferred option is to set a list of mimetype names, see setMimeFilter() for details.
        ///     Otherwise you can set the text to be displayed for the each glob, and
        ///     provide multiple globs, see setFilter() for details.
        /// </param><param> name="parent" The widget the dialog will be centered on initially.
        /// </param><param> name="caption" The name of the dialog widget.
        ///      </param></remarks>        <short>    Creates a modal file dialog and returns the selected  filename or an empty string if none was chosen.</short>
        public static string GetSaveFileName(KUrl startDir, string filter, QWidget parent, string caption) {
            return (string) staticInterceptor.Invoke("getSaveFileName#$#$", "getSaveFileName(const KUrl&, const QString&, QWidget*, const QString&)", typeof(string), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent, typeof(string), caption);
        }
        public static string GetSaveFileName(KUrl startDir, string filter, QWidget parent) {
            return (string) staticInterceptor.Invoke("getSaveFileName#$#", "getSaveFileName(const KUrl&, const QString&, QWidget*)", typeof(string), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent);
        }
        public static string GetSaveFileName(KUrl startDir, string filter) {
            return (string) staticInterceptor.Invoke("getSaveFileName#$", "getSaveFileName(const KUrl&, const QString&)", typeof(string), typeof(KUrl), startDir, typeof(string), filter);
        }
        public static string GetSaveFileName(KUrl startDir) {
            return (string) staticInterceptor.Invoke("getSaveFileName#", "getSaveFileName(const KUrl&)", typeof(string), typeof(KUrl), startDir);
        }
        public static string GetSaveFileName() {
            return (string) staticInterceptor.Invoke("getSaveFileName", "getSaveFileName()", typeof(string));
        }
        /// <remarks>
        ///  This function accepts the window id of the parent window, instead
        ///  of QWidget. It should be used only when necessary.
        ///      </remarks>        <short>    This function accepts the window id of the parent window, instead  of QWidget .</short>
        public static string GetSaveFileNameWId(KUrl startDir, string filter, uint parent_id, string caption) {
            return (string) staticInterceptor.Invoke("getSaveFileNameWId#$$$", "getSaveFileNameWId(const KUrl&, const QString&, WId, const QString&)", typeof(string), typeof(KUrl), startDir, typeof(string), filter, typeof(uint), parent_id, typeof(string), caption);
        }
        /// <remarks>
        ///  Creates a modal file dialog and returns the selected
        ///  filename or an empty string if none was chosen.
        ///  Note that with this
        ///  method the user need not select an existing filename.
        /// <param> name="startDir" This can either be
        /// </param>
        /// <li>
        /// The URL of the directory to start in.
        /// </li>
        /// 
        /// <li>
        /// A KUrl() to start in the current working
        ///              directory, or the last directory where a file has been
        ///              selected.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;' to start in the
        ///              directory last used by a filedialog in the same application that specified
        ///              the same keyword.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;?global' to start
        ///              in the directory last used by a filedialog in any application that specified the
        ///              same keyword.
        /// </li>
        /// <param> name="filter" A shell glob or a mime-type-filter that specifies which files to display.
        ///     The preferred option is to set a list of mimetype names, see setMimeFilter() for details.
        ///     Otherwise you can set the text to be displayed for the each glob, and
        ///     provide multiple globs, see setFilter() for details.
        /// </param><param> name="parent" The widget the dialog will be centered on initially.
        /// </param><param> name="caption" The name of the dialog widget.
        ///      </param></remarks>        <short>    Creates a modal file dialog and returns the selected  filename or an empty string if none was chosen.</short>
        public static KUrl GetSaveUrl(KUrl startDir, string filter, QWidget parent, string caption) {
            return (KUrl) staticInterceptor.Invoke("getSaveUrl#$#$", "getSaveUrl(const KUrl&, const QString&, QWidget*, const QString&)", typeof(KUrl), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent, typeof(string), caption);
        }
        public static KUrl GetSaveUrl(KUrl startDir, string filter, QWidget parent) {
            return (KUrl) staticInterceptor.Invoke("getSaveUrl#$#", "getSaveUrl(const KUrl&, const QString&, QWidget*)", typeof(KUrl), typeof(KUrl), startDir, typeof(string), filter, typeof(QWidget), parent);
        }
        public static KUrl GetSaveUrl(KUrl startDir, string filter) {
            return (KUrl) staticInterceptor.Invoke("getSaveUrl#$", "getSaveUrl(const KUrl&, const QString&)", typeof(KUrl), typeof(KUrl), startDir, typeof(string), filter);
        }
        public static KUrl GetSaveUrl(KUrl startDir) {
            return (KUrl) staticInterceptor.Invoke("getSaveUrl#", "getSaveUrl(const KUrl&)", typeof(KUrl), typeof(KUrl), startDir);
        }
        public static KUrl GetSaveUrl() {
            return (KUrl) staticInterceptor.Invoke("getSaveUrl", "getSaveUrl()", typeof(KUrl));
        }
        /// <remarks>
        ///  Creates a modal directory-selection dialog and returns the selected
        ///  directory (local only) or an empty string if none was chosen.
        /// <param> name="startDir" This can either be
        /// </param>
        /// <li>
        /// The URL of the directory to start in.
        /// </li>
        /// 
        /// <li>
        /// A KUrl() to start in the current working
        ///              directory, or the last directory where a file has been
        ///              selected.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;' to start in the
        ///              directory last used by a filedialog in the same application that specified
        ///              the same keyword.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;?global' to start
        ///              in the directory last used by a filedialog in any application that specified the
        ///              same keyword.
        /// </li>
        /// <param> name="parent" The widget the dialog will be centered on initially.
        /// </param><param> name="caption" The name of the dialog widget.
        /// </param></remarks>        <return> the path to an existing local directory.
        ///      </return>
        ///         <short>    Creates a modal directory-selection dialog and returns the selected  directory (local only) or an empty string if none was chosen.</short>
        public static string GetExistingDirectory(KUrl startDir, QWidget parent, string caption) {
            return (string) staticInterceptor.Invoke("getExistingDirectory##$", "getExistingDirectory(const KUrl&, QWidget*, const QString&)", typeof(string), typeof(KUrl), startDir, typeof(QWidget), parent, typeof(string), caption);
        }
        public static string GetExistingDirectory(KUrl startDir, QWidget parent) {
            return (string) staticInterceptor.Invoke("getExistingDirectory##", "getExistingDirectory(const KUrl&, QWidget*)", typeof(string), typeof(KUrl), startDir, typeof(QWidget), parent);
        }
        public static string GetExistingDirectory(KUrl startDir) {
            return (string) staticInterceptor.Invoke("getExistingDirectory#", "getExistingDirectory(const KUrl&)", typeof(string), typeof(KUrl), startDir);
        }
        public static string GetExistingDirectory() {
            return (string) staticInterceptor.Invoke("getExistingDirectory", "getExistingDirectory()", typeof(string));
        }
        /// <remarks>
        ///  Creates a modal directory-selection dialog and returns the selected
        ///  directory or an empty string if none was chosen.
        ///  This version supports remote urls.
        /// <param> name="startDir" This can either be
        /// </param>
        /// <li>
        /// The URL of the directory to start in.
        /// </li>
        /// 
        /// <li>
        /// A KUrl() to start in the current working
        ///              directory, or the last directory where a file has been
        ///              selected.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;' to start in the
        ///              directory last used by a filedialog in the same application that specified
        ///              the same keyword.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;?global' to start
        ///              in the directory last used by a filedialog in any application that specified the
        ///              same keyword.
        /// </li>
        /// <param> name="parent" The widget the dialog will be centered on initially.
        /// </param><param> name="caption" The name of the dialog widget.
        /// </param></remarks>        <return> the url to an existing directory (local or remote).
        ///      </return>
        ///         <short>    Creates a modal directory-selection dialog and returns the selected  directory or an empty string if none was chosen.</short>
        public static KUrl GetExistingDirectoryUrl(KUrl startDir, QWidget parent, string caption) {
            return (KUrl) staticInterceptor.Invoke("getExistingDirectoryUrl##$", "getExistingDirectoryUrl(const KUrl&, QWidget*, const QString&)", typeof(KUrl), typeof(KUrl), startDir, typeof(QWidget), parent, typeof(string), caption);
        }
        public static KUrl GetExistingDirectoryUrl(KUrl startDir, QWidget parent) {
            return (KUrl) staticInterceptor.Invoke("getExistingDirectoryUrl##", "getExistingDirectoryUrl(const KUrl&, QWidget*)", typeof(KUrl), typeof(KUrl), startDir, typeof(QWidget), parent);
        }
        public static KUrl GetExistingDirectoryUrl(KUrl startDir) {
            return (KUrl) staticInterceptor.Invoke("getExistingDirectoryUrl#", "getExistingDirectoryUrl(const KUrl&)", typeof(KUrl), typeof(KUrl), startDir);
        }
        public static KUrl GetExistingDirectoryUrl() {
            return (KUrl) staticInterceptor.Invoke("getExistingDirectoryUrl", "getExistingDirectoryUrl()", typeof(KUrl));
        }
        /// <remarks>
        ///  Creates a modal file dialog with an image previewer and returns the
        ///  selected url or an empty string if none was chosen.
        /// <param> name="startDir" This can either be
        /// </param>
        /// <li>
        /// The URL of the directory to start in.
        /// </li>
        /// 
        /// <li>
        /// A KUrl() to start in the current working
        ///              directory, or the last directory where a file has been
        ///              selected.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;' to start in the
        ///              directory last used by a filedialog in the same application that specified
        ///              the same keyword.
        /// </li>
        /// 
        /// <li>
        /// An URL starting with 'kfiledialog:///&lt;keyword&gt;?global' to start
        ///              in the directory last used by a filedialog in any application that specified the
        ///              same keyword.
        /// </li>
        /// <param> name="parent" The widget the dialog will be centered on initially.
        /// </param><param> name="caption" The name of the dialog widget.
        ///      </param></remarks>        <short>    Creates a modal file dialog with an image previewer and returns the  selected url or an empty string if none was chosen.</short>
        public static KUrl GetImageOpenUrl(KUrl startDir, QWidget parent, string caption) {
            return (KUrl) staticInterceptor.Invoke("getImageOpenUrl##$", "getImageOpenUrl(const KUrl&, QWidget*, const QString&)", typeof(KUrl), typeof(KUrl), startDir, typeof(QWidget), parent, typeof(string), caption);
        }
        public static KUrl GetImageOpenUrl(KUrl startDir, QWidget parent) {
            return (KUrl) staticInterceptor.Invoke("getImageOpenUrl##", "getImageOpenUrl(const KUrl&, QWidget*)", typeof(KUrl), typeof(KUrl), startDir, typeof(QWidget), parent);
        }
        public static KUrl GetImageOpenUrl(KUrl startDir) {
            return (KUrl) staticInterceptor.Invoke("getImageOpenUrl#", "getImageOpenUrl(const KUrl&)", typeof(KUrl), typeof(KUrl), startDir);
        }
        public static KUrl GetImageOpenUrl() {
            return (KUrl) staticInterceptor.Invoke("getImageOpenUrl", "getImageOpenUrl()", typeof(KUrl));
        }
        /// <remarks>
        ///  This method implements the logic to determine the user's default directory
        ///  to be listed. E.g. the documents directory, home directory or a recently
        ///  used directory.
        /// <param> name="startDir" A url, to be used. May use the 'kfiledialog:///keyword' and
        ///                  'kfiledialog:///keyword?global' syntax
        ///                  as documented in the KFileDialog() constructor.
        /// </param><param> name="recentDirClass" If the 'kfiledialog:///' syntax is used, recentDirClass
        ///         will contain the string to be used later for KRecentDir.Dir()
        /// </param></remarks>        <return> The URL that should be listed by default (e.g. by KFileDialog or
        ///          KDirSelectDialog).
        ///      </return>
        ///         <short>    This method implements the logic to determine the user's default directory  to be listed.</short>
        public static KUrl GetStartUrl(KUrl startDir, StringBuilder recentDirClass) {
            return (KUrl) staticInterceptor.Invoke("getStartUrl#$", "getStartUrl(const KUrl&, QString&)", typeof(KUrl), typeof(KUrl), startDir, typeof(StringBuilder), recentDirClass);
        }
        /// <remarks>
        ///  Used by KDirSelectDialog to share the dialog's start directory.
        ///      </remarks>        <short>   </short>
        public static void SetStartDir(KUrl directory) {
            staticInterceptor.Invoke("setStartDir#", "setStartDir(const KUrl&)", typeof(void), typeof(KUrl), directory);
        }
        protected new IKFileDialogSignals Emit {
            get { return (IKFileDialogSignals) Q_EMIT; }
        }
    }

    public interface IKFileDialogSignals : IKDialogSignals {
        /// <remarks>
        ///  Emitted when the user selects a file. It is only emitted in single-
        ///  selection mode. The best way to get notified about selected file(s)
        ///  is to connect to the okClicked() signal inherited from KDialog
        ///  and call selectedFile(), selectedFiles(),
        ///  selectedUrl() or selectedUrls().
        ///       </remarks>        <short>    Emitted when the user selects a file.</short>
        [Q_SIGNAL("void fileSelected(QString)")]
        void FileSelected(string arg1);
        /// <remarks>
        ///  Emitted when the user highlights a file.
        ///       </remarks>        <short>    Emitted when the user highlights a file.</short>
        [Q_SIGNAL("void fileHighlighted(QString)")]
        void FileHighlighted(string arg1);
        /// <remarks>
        ///  Emitted when the user hilights one or more files in multiselection mode.
        ///  Note: fileHighlighted() or fileSelected() are <b>not</b>
        ///  emitted in multiselection mode. You may use selectedItems() to
        ///  ask for the current highlighted items.
        /// </remarks>        <short>    Emitted when the user hilights one or more files in multiselection mode.</short>
        ///         <see> fileSelected</see>
        [Q_SIGNAL("void selectionChanged()")]
        void SelectionChanged();
        /// <remarks>
        ///  Emitted when the filter changed, i.e. the user entered an own filter
        ///  or chose one of the predefined set via setFilter().
        /// <param> name="filter" contains the new filter (only the extension part,
        ///  not the explanation), i.e. "*.cpp" or "*.cpp .cc".
        /// </param></remarks>        <short>    Emitted when the filter changed, i.</short>
        ///         <see> setFilter</see>
        ///         <see> currentFilter</see>
        [Q_SIGNAL("void filterChanged(QString)")]
        void FilterChanged(string filter);
    }
}
