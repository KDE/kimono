//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  The base class for widget based job trackers.
    ///   See <see cref="IKAbstractWidgetJobTrackerSignals"></see> for signals emitted by KAbstractWidgetJobTracker
    /// </remarks>        <short>    The base class for widget based job trackers.</short>
    [SmokeClass("KAbstractWidgetJobTracker")]
    public abstract class KAbstractWidgetJobTracker : KJobTrackerInterface {
        protected KAbstractWidgetJobTracker(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KAbstractWidgetJobTracker), this);
        }
        /// <remarks>
        ///  Creates a new KAbstractWidgetJobTracker
        /// <param> name="parent" the parent of this object and of the widget displaying the job progresses
        ///      </param></remarks>        <short>    Creates a new KAbstractWidgetJobTracker </short>
        public KAbstractWidgetJobTracker(QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KAbstractWidgetJobTracker#", "KAbstractWidgetJobTracker(QWidget*)", typeof(void), typeof(QWidget), parent);
        }
        public KAbstractWidgetJobTracker() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KAbstractWidgetJobTracker", "KAbstractWidgetJobTracker()", typeof(void));
        }
        /// <remarks>
        ///  The widget associated to this tracker.
        /// <param> name="job" the job that is assigned the widget we want to return
        /// </param></remarks>        <return> the widget displaying the job progresses
        ///      </return>
        ///         <short>    The widget associated to this tracker.</short>
        [SmokeMethod("widget(KJob*)")]
        public abstract QWidget Widget(KJob job);
        /// <remarks>
        ///  This controls whether the job should be canceled if the dialog is closed.
        /// <param> name="job" the job's widget that will be stopped when closing
        /// </param><param> name="stopOnClose" If true the job will be stopped if the dialog is closed,
        ///  otherwise the job will continue even on close.
        /// </param></remarks>        <short>    This controls whether the job should be canceled if the dialog is closed.</short>
        ///         <see> stopOnClose</see>
        public void SetStopOnClose(KJob job, bool stopOnClose) {
            interceptor.Invoke("setStopOnClose#$", "setStopOnClose(KJob*, bool)", typeof(void), typeof(KJob), job, typeof(bool), stopOnClose);
        }
        /// <remarks>
        ///  Checks whether the job will be killed when the dialog is closed.
        /// <param> name="job" the job's widget that will be stopped when closing
        /// </param></remarks>        <return> true if the job is killed on close event, false otherwise.
        /// </return>
        ///         <short>    Checks whether the job will be killed when the dialog is closed.</short>
        ///         <see> setStopOnClose</see>
        public bool StopOnClose(KJob job) {
            return (bool) interceptor.Invoke("stopOnClose#", "stopOnClose(KJob*) const", typeof(bool), typeof(KJob), job);
        }
        /// <remarks>
        ///  This controls whether the dialog should be deleted or only cleaned when
        ///  the KJob is finished (or canceled).
        ///  If your dialog is an embedded widget and not a separate window, you should
        ///  setAutoDelete(false) in the constructor of your custom dialog.
        /// <param> name="job" the job's widget that is going to be auto-deleted
        /// </param><param> name="autoDelete" If false the dialog will only call method slotClean.
        ///  If true the dialog will be deleted.
        /// </param></remarks>        <short>    This controls whether the dialog should be deleted or only cleaned when  the KJob is finished (or canceled).</short>
        ///         <see> autoDelete</see>
        public void SetAutoDelete(KJob job, bool autoDelete) {
            interceptor.Invoke("setAutoDelete#$", "setAutoDelete(KJob*, bool)", typeof(void), typeof(KJob), job, typeof(bool), autoDelete);
        }
        /// <remarks>
        ///  Checks whether the dialog should be deleted or cleaned.
        /// <param> name="job" the job's widget that will be auto-deleted
        /// </param></remarks>        <return> false if the dialog only calls slotClean, true if it will be
        ///          deleted
        /// </return>
        ///         <short>    Checks whether the dialog should be deleted or cleaned.</short>
        ///         <see> setAutoDelete</see>
        public bool AutoDelete(KJob job) {
            return (bool) interceptor.Invoke("autoDelete#", "autoDelete(KJob*) const", typeof(bool), typeof(KJob), job);
        }
        /// <remarks>
        ///  Register a new job in this tracker.
        ///  Note that job trackers inheriting from this class can have only one job
        ///  registered at a time.
        /// <param> name="job" the job to register
        ///      </param></remarks>        <short>    Register a new job in this tracker.</short>
        [Q_SLOT("void registerJob(KJob*)")]
        [SmokeMethod("registerJob(KJob*)")]
        public override void RegisterJob(KJob job) {
            interceptor.Invoke("registerJob#", "registerJob(KJob*)", typeof(void), typeof(KJob), job);
        }
        /// <remarks>
        ///  Unregister a job from this tracker.
        /// <param> name="job" the job to unregister
        ///      </param></remarks>        <short>    Unregister a job from this tracker.</short>
        [Q_SLOT("void unregisterJob(KJob*)")]
        [SmokeMethod("unregisterJob(KJob*)")]
        public override void UnregisterJob(KJob job) {
            interceptor.Invoke("unregisterJob#", "unregisterJob(KJob*)", typeof(void), typeof(KJob), job);
        }
        /// <remarks>
        ///  Called when a job is finished, in any case. It is used to notify
        ///  that the job is terminated and that progress UI (if any) can be hidden.
        /// <param> name="job" the job that emitted this signal
        ///      </param></remarks>        <short>    Called when a job is finished, in any case.</short>
        [Q_SLOT("void finished(KJob*)")]
        [SmokeMethod("finished(KJob*)")]
        protected override void Finished(KJob job) {
            interceptor.Invoke("finished#", "finished(KJob*)", typeof(void), typeof(KJob), job);
        }
        /// <remarks>
        ///  This method should be called for correct cancellation of IO operation
        ///  Connect this to the progress widgets buttons etc.
        /// <param> name="job" The job that is being stopped
        ///      </param></remarks>        <short>    This method should be called for correct cancellation of IO operation  Connect this to the progress widgets buttons etc.</short>
        [Q_SLOT("void slotStop(KJob*)")]
        [SmokeMethod("slotStop(KJob*)")]
        protected virtual void SlotStop(KJob job) {
            interceptor.Invoke("slotStop#", "slotStop(KJob*)", typeof(void), typeof(KJob), job);
        }
        /// <remarks>
        ///  This method should be called for pause/resume
        ///  Connect this to the progress widgets buttons etc.
        /// <param> name="job" The job that is being suspended
        ///      </param></remarks>        <short>    This method should be called for pause/resume  Connect this to the progress widgets buttons etc.</short>
        [Q_SLOT("void slotSuspend(KJob*)")]
        [SmokeMethod("slotSuspend(KJob*)")]
        protected virtual void SlotSuspend(KJob job) {
            interceptor.Invoke("slotSuspend#", "slotSuspend(KJob*)", typeof(void), typeof(KJob), job);
        }
        /// <remarks>
        ///  This method should be called for pause/resume
        ///  Connect this to the progress widgets buttons etc.
        /// <param> name="job" The job that is being resumed
        ///      </param></remarks>        <short>    This method should be called for pause/resume  Connect this to the progress widgets buttons etc.</short>
        [Q_SLOT("void slotResume(KJob*)")]
        [SmokeMethod("slotResume(KJob*)")]
        protected virtual void SlotResume(KJob job) {
            interceptor.Invoke("slotResume#", "slotResume(KJob*)", typeof(void), typeof(KJob), job);
        }
        /// <remarks>
        ///  This method is called when the widget should be cleaned (after job is finished).
        ///  redefine this for custom behavior.
        /// <param> name="job" The job that is being cleaned
        ///      </param></remarks>        <short>    This method is called when the widget should be cleaned (after job is finished).</short>
        [Q_SLOT("void slotClean(KJob*)")]
        [SmokeMethod("slotClean(KJob*)")]
        protected virtual void SlotClean(KJob job) {
            interceptor.Invoke("slotClean#", "slotClean(KJob*)", typeof(void), typeof(KJob), job);
        }
        protected new IKAbstractWidgetJobTrackerSignals Emit {
            get { return (IKAbstractWidgetJobTrackerSignals) Q_EMIT; }
        }
    }

    public interface IKAbstractWidgetJobTrackerSignals : IKJobTrackerInterfaceSignals {
        /// <remarks>
        ///  Emitted when the user aborted the operation
        /// <param> name="job" The job that has been stopped
        ///      </param></remarks>        <short>    Emitted when the user aborted the operation </short>
        [Q_SIGNAL("void stopped(KJob*)")]
        void Stopped(KJob job);
        /// <remarks>
        ///  Emitted when the user suspended the operation
        /// <param> name="job" The job that has been suspended
        ///      </param></remarks>        <short>    Emitted when the user suspended the operation </short>
        [Q_SIGNAL("void suspend(KJob*)")]
        void Suspend(KJob job);
        /// <remarks>
        ///  Emitted when the user resumed the operation
        /// <param> name="job" The job that has been resumed
        ///      </param></remarks>        <short>    Emitted when the user resumed the operation </short>
        [Q_SIGNAL("void resume(KJob*)")]
        void Resume(KJob job);
    }
}
