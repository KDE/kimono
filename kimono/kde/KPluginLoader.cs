//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  \class KPluginLoader kpluginloader.h <KPluginLoader>
    ///  This class can be used to dynamically load a plugin library at runtime.
    ///  This class makes sure that the Qt and KDE versions used to compile this library aren't newer then
    ///  the ones currently used.
    ///  This class is reentrant, you can load plugins from different threads. You can also have multiple
    ///  PluginLoaders for one library without negative effects.
    ///  The object obtained with factory() or the inherited method QPluginLoader.Instance() is
    ///  cached inside the library. If you call factory() or instance() multiple times, you will always get
    ///  the same object, even from different threads and different KPluginLoader instances.
    ///  You can delete this object easily, a new one will be created if factory() or instance() is called
    ///  afterwards. factory() uses instance() internally.
    ///  KPluginLoader inherits QPluginLoader.Unload(). It safe to call this method if you loaded a plugin
    ///  and decide not to use it for some reason. But as soon as you start to use the factory from the plugin,
    ///  you should stay away from it. It's nearly impossible to keep track of all objects created directly or
    ///  indirectly from the plugin and all other pointers into plugin code. Using unload() in this case is asking
    ///  for trouble. If you really need to unload your plugins, you have to take care to convert the clipboard
    ///  content to text, because the plugin could have registered a custom mime source. You also have to delete
    ///  the factory of the plugin, otherwise you will create a leak.
    ///  The destructor of KPluginLoader doesn't call unload.
    ///  Sample code:
    ///  <pre>
    ///   KPluginLoader loader( ...library or kservice... );
    ///   KPluginFactory factory = loader.factory();
    ///   if (!factory) {
    ///       kWarning() << "Error loading plugin:" << loader.errorString();
    ///   } else {
    ///       MyInterface obj = factory.Create<MyInterface>();
    ///       if (!obj) {
    ///           kWarning() << "Error creating object";
    ///       }
    ///   }
    ///  </pre>
    ///  \see KPluginFactory
    ///  \author Bernhard Loos <nhuh.put@web.de>
    ///  </remarks>        <short>    \class KPluginLoader kpluginloader.</short>
    [SmokeClass("KPluginLoader")]
    public class KPluginLoader : QPluginLoader, IDisposable {
        protected KPluginLoader(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KPluginLoader), this);
        }
        [Q_PROPERTY("QString", "fileName")]
        public new string FileName {
            get { return (string) interceptor.Invoke("fileName", "fileName()", typeof(string)); }
        }
        [Q_PROPERTY("QString", "pluginName")]
        public string PluginName {
            get { return (string) interceptor.Invoke("fileName", "fileName()", typeof(string)); }
        }
        // KPluginFactory* factory(); >>>> NOT CONVERTED
        /// <remarks>
        ///  Used this constructor to load a plugin with a given library name. Plugin libraries shouldn't have a 'lib' prefix.
        ///  \param plugin The name of the plugin library.
        ///  \param componentdata The KStandardDirs object from componentdata is used to search the library.
        ///  \param parent A parent object.
        ///      </remarks>        <short>    Used this constructor to load a plugin with a given library name.</short>
        public KPluginLoader(string plugin, KComponentData componentdata, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KPluginLoader$##", "KPluginLoader(const QString&, const KComponentData&, QObject*)", typeof(void), typeof(string), plugin, typeof(KComponentData), componentdata, typeof(QObject), parent);
        }
        public KPluginLoader(string plugin, KComponentData componentdata) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KPluginLoader$#", "KPluginLoader(const QString&, const KComponentData&)", typeof(void), typeof(string), plugin, typeof(KComponentData), componentdata);
        }
        public KPluginLoader(string plugin) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KPluginLoader$", "KPluginLoader(const QString&)", typeof(void), typeof(string), plugin);
        }
        /// <remarks>
        ///  Used this constructor to load a plugin from a service. The service must contain a library.
        ///  \param service The service for which the library should be loaded.
        ///  \param componentdata The KStandardDirs object from componentdata is used to search the library.
        ///  \param parent A parent object.
        ///      </remarks>        <short>    Used this constructor to load a plugin from a service.</short>
        public KPluginLoader(KService service, KComponentData componentdata, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KPluginLoader###", "KPluginLoader(const KService&, const KComponentData&, QObject*)", typeof(void), typeof(KService), service, typeof(KComponentData), componentdata, typeof(QObject), parent);
        }
        public KPluginLoader(KService service, KComponentData componentdata) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KPluginLoader##", "KPluginLoader(const KService&, const KComponentData&)", typeof(void), typeof(KService), service, typeof(KComponentData), componentdata);
        }
        public KPluginLoader(KService service) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KPluginLoader#", "KPluginLoader(const KService&)", typeof(void), typeof(KService), service);
        }
        /// <remarks>
        ///  Used to obtain the factory object of the plugin. You have to give a class which inherits KPluginFactory
        ///  to K_EXPORT_PLUGIN to use this method.
        ///  \returns The factory of the plugin or 0 on error.
        ///      </remarks>        <short>    Used to obtain the factory object of the plugin.</short>
        /// <remarks>
        ///  Queries the plugin version.
        ///  \returns The version given to K_EXPORT_PLUGIN_VERSION or (quint32) -1 if not set.
        ///      </remarks>        <short>    Queries the plugin version.</short>
        public uint PluginVersion() {
            return (uint) interceptor.Invoke("pluginVersion", "pluginVersion() const", typeof(uint));
        }
        /// <remarks>
        ///  Queries the last error.
        ///  \returns The description of the last error.
        ///      </remarks>        <short>    Queries the last error.</short>
        public new string ErrorString() {
            return (string) interceptor.Invoke("errorString", "errorString() const", typeof(string));
        }
        public new bool IsLoaded() {
            return (bool) interceptor.Invoke("isLoaded", "isLoaded() const", typeof(bool));
        }
        /// <remarks>
        ///  Performs the loading of the plugin.
        ///      </remarks>        <short>    Performs the loading of the plugin.</short>
        protected new bool Load() {
            return (bool) interceptor.Invoke("load", "load()", typeof(bool));
        }
        ~KPluginLoader() {
            interceptor.Invoke("~KPluginLoader", "~KPluginLoader()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KPluginLoader", "~KPluginLoader()", typeof(void));
        }
        protected new IKPluginLoaderSignals Emit {
            get { return (IKPluginLoaderSignals) Q_EMIT; }
        }
    }

    public interface IKPluginLoaderSignals : IQPluginLoaderSignals {
    }
}
