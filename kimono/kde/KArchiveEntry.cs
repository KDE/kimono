//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  A base class for entries in an KArchive.
    /// </remarks>        <short> Base class for the archive-file's directory structure. </short>
    ///         <see> KArchiveFile</see>
    ///         <see> KArchiveDirectory</see>
    [SmokeClass("KArchiveEntry")]
    public class KArchiveEntry : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KArchiveEntry(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KArchiveEntry), this);
        }
        /// <remarks>
        ///  Creates a new entry.
        /// <param> name="archive" the entries archive
        /// </param><param> name="name" the name of the entry
        /// </param><param> name="access" the permissions in unix format
        /// </param><param> name="date" the date (in seconds since 1970)
        /// </param><param> name="user" the user that owns the entry
        /// </param><param> name="group" the group that owns the entry
        /// </param><param> name="symlink" the symlink, or string()
        ///      </param></remarks>        <short>    Creates a new entry.</short>
        public KArchiveEntry(KArchive archive, string name, int access, int date, string user, string group, string symlink) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KArchiveEntry#$$$$$$", "KArchiveEntry(KArchive*, const QString&, int, int, const QString&, const QString&, const QString&)", typeof(void), typeof(KArchive), archive, typeof(string), name, typeof(int), access, typeof(int), date, typeof(string), user, typeof(string), group, typeof(string), symlink);
        }
        /// <remarks>
        ///  Creation date of the file.
        /// </remarks>        <return> the creation date
        ///      </return>
        ///         <short>    Creation date of the file.</short>
        public QDateTime Datetime() {
            return (QDateTime) interceptor.Invoke("datetime", "datetime() const", typeof(QDateTime));
        }
        /// <remarks>
        ///  Creation date of the file.
        /// </remarks>        <return> the creation date in seconds since 1970
        ///      </return>
        ///         <short>    Creation date of the file.</short>
        public int Date() {
            return (int) interceptor.Invoke("date", "date() const", typeof(int));
        }
        /// <remarks>
        ///  Name of the file without path.
        /// </remarks>        <return> the file name without path
        ///      </return>
        ///         <short>    Name of the file without path.</short>
        public string Name() {
            return (string) interceptor.Invoke("name", "name() const", typeof(string));
        }
        /// <remarks>
        ///  The permissions and mode flags as returned by the stat() function
        ///  in st_mode.
        /// </remarks>        <return> the permissions
        ///      </return>
        ///         <short>    The permissions and mode flags as returned by the stat() function  in st_mode.</short>
        public long Permissions() {
            return (long) interceptor.Invoke("permissions", "permissions() const", typeof(long));
        }
        /// <remarks>
        ///  User who created the file.
        /// </remarks>        <return> the owner of the file
        ///      </return>
        ///         <short>    User who created the file.</short>
        public string User() {
            return (string) interceptor.Invoke("user", "user() const", typeof(string));
        }
        /// <remarks>
        ///  Group of the user who created the file.
        /// </remarks>        <return> the group of the file
        ///      </return>
        ///         <short>    Group of the user who created the file.</short>
        public string Group() {
            return (string) interceptor.Invoke("group", "group() const", typeof(string));
        }
        /// <remarks>
        ///  Symlink if there is one.
        /// </remarks>        <return> the symlink, or string()
        ///      </return>
        ///         <short>    Symlink if there is one.</short>
        public string SymLinkTarget() {
            return (string) interceptor.Invoke("symLinkTarget", "symLinkTarget() const", typeof(string));
        }
        /// <remarks>
        ///  Checks whether the entry is a file.
        /// </remarks>        <return> true if this entry is a file
        ///      </return>
        ///         <short>    Checks whether the entry is a file.</short>
        [SmokeMethod("isFile() const")]
        public virtual bool IsFile() {
            return (bool) interceptor.Invoke("isFile", "isFile() const", typeof(bool));
        }
        /// <remarks>
        ///  Checks whether the entry is a directory.
        /// </remarks>        <return> true if this entry is a directory
        ///      </return>
        ///         <short>    Checks whether the entry is a directory.</short>
        [SmokeMethod("isDirectory() const")]
        public virtual bool IsDirectory() {
            return (bool) interceptor.Invoke("isDirectory", "isDirectory() const", typeof(bool));
        }
        protected KArchive Archive() {
            return (KArchive) interceptor.Invoke("archive", "archive() const", typeof(KArchive));
        }
        ~KArchiveEntry() {
            interceptor.Invoke("~KArchiveEntry", "~KArchiveEntry()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KArchiveEntry", "~KArchiveEntry()", typeof(void));
        }
    }
}
