//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  @brief KCModuleContainer is a convenience class encapsulating several KCModules.
    ///  The KCModuleContainer class is a convenience class for organizing a multiple set
    ///  of KCModule. KCModuleContainer is a sub class of KCModule and builds an interface mainly
    ///  consisting of a tab widget where each tab contains one of the modules specified via one of the
    ///  constructors. KCModuleContainer can handle modules which requires root permissions. What you
    ///  most likely want is the KCMODULECONTAINER macro. \n
    ///  Sometimes it is of interest to detect in runtime whether a module should be loaded or not. This
    ///  can be achieved by sub classing KCModuleContainer, doing the probing/testing checks and then manually
    ///  call addModule for each module which should be displayed. When all calls to addModule is done, call
    ///  finalize() which performs some necessary final steps.
    /// </remarks>        <author> Frans Englich <frans.englich@telia.com>
    ///  </author>
    ///         <short>    @brief KCModuleContainer is a convenience class encapsulating several KCModules.</short>
    [SmokeClass("KCModuleContainer")]
    public class KCModuleContainer : KCModule, IDisposable {
        protected KCModuleContainer(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KCModuleContainer), this);
        }
        /// <remarks>
        ///  Creates a KCModuleContainer with tabs, each one containing one of the
        ///  specified modules in <code>mods.</code>
        /// <param> name="parent" the parent QWidget.
        /// </param><param> name="mods" The list of KCModules to be loaded. The name of each
        ///  KCModule is its service name, that is the name of the desktop file without
        ///  the ".desktop" part
        /// </param>		 </remarks>        <short>    Creates a KCModuleContainer with tabs, each one containing one of the  specified modules in <code>mods.</code></short>
        public KCModuleContainer(QWidget parent, List<string> mods) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCModuleContainer#?", "KCModuleContainer(QWidget*, const QStringList&)", typeof(void), typeof(QWidget), parent, typeof(List<string>), mods);
        }
        /// <remarks>
        ///  This is a convenience function, instead of building a List<string> you
        ///  can specify the modules in a comma separated string. For example;
        ///  <pre>
        ///  KCModuleContainer cont = KCModuleContainer( this, "kcm_misc", string("kcm_energy, kcm_keyboard ,kcm_useraccount, kcm_mouse") );
        ///  </pre>
        ///  The other constructor takes its modules in a stringlist which also can be constructed from a
        ///  string and thus you will have to be explicit on the data type.
        ///  What you probably want is the KCMODULECONTAINER macro which builds an KCModule
        ///  for you, taking the modules you want as argument.
        /// <param> name="parent" The parent widget
        /// </param><param> name="mods" The modules to load
        /// </param></remarks>        <return> The KCModule containing the requested modules.
        /// 		 </return>
        ///         <short>    This is a convenience function, instead of building a List<string> you  can specify the modules in a comma separated string.</short>
        public KCModuleContainer(QWidget parent, string mods) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCModuleContainer#$", "KCModuleContainer(QWidget*, const QString&)", typeof(void), typeof(QWidget), parent, typeof(string), mods);
        }
        public KCModuleContainer(QWidget parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KCModuleContainer#", "KCModuleContainer(QWidget*)", typeof(void), typeof(QWidget), parent);
        }
        /// <remarks>
        ///  Adds the specified module to the tab widget. Setting the tab icon, text,
        ///  tool tip, connecting the signals is what it does.
        /// <param> name="module" the name of the module to add. The name is the desktop file's name
        ///  without the ".desktop" part.
        /// 		 </param></remarks>        <short>    Adds the specified module to the tab widget.</short>
        public void AddModule(string module) {
            interceptor.Invoke("addModule$", "addModule(const QString&)", typeof(void), typeof(string), module);
        }
        /// <remarks>
        ///  Reimplemented for internal purposes.
        /// 		 </remarks>        <short>    Reimplemented for internal purposes.</short>
        [SmokeMethod("save()")]
        public override void Save() {
            interceptor.Invoke("save", "save()", typeof(void));
        }
        /// <remarks>
        ///  Reimplemented for internal purposes.
        /// 		 </remarks>        <short>    Reimplemented for internal purposes.</short>
        [SmokeMethod("load()")]
        public override void Load() {
            interceptor.Invoke("load", "load()", typeof(void));
        }
        /// <remarks>
        ///  Reimplemented for internal purposes.
        /// 		 </remarks>        <short>    Reimplemented for internal purposes.</short>
        [SmokeMethod("defaults()")]
        public override void Defaults() {
            interceptor.Invoke("defaults", "defaults()", typeof(void));
        }
        ~KCModuleContainer() {
            interceptor.Invoke("~KCModuleContainer", "~KCModuleContainer()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KCModuleContainer", "~KCModuleContainer()", typeof(void));
        }
        protected new IKCModuleContainerSignals Emit {
            get { return (IKCModuleContainerSignals) Q_EMIT; }
        }
    }

    public interface IKCModuleContainerSignals : IKCModuleSignals {
    }
}
