//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Collections.Generic;
    /// <remarks>
    ///  KToolInvocation: for starting other programs
    ///  @section desktopfiles Desktop files for startServiceBy
    ///  The way a service gets started depends on the 'X-DBUS-StartupType'
    ///  entry in the desktop file of the service:
    ///  There are three possibilities:
    /// 
    /// <li>
    /// X-DBUS-StartupType=None (default)
    ///     Always start a new service,
    ///     don't wait till the service registers with dbus.
    /// </li>
    /// 
    /// <li>
    /// X-DBUS-StartupType=Multi
    ///     Always start a new service,
    ///     wait until the service has registered with dbus.
    /// </li>
    /// 
    /// <li>
    /// X-DBUS-StartupType=Unique
    ///     Only start the service if it isn't already running,
    ///     wait until the service has registered with dbus.
    ///  The .desktop file can specify the name that the application will use when registering
    ///  using X-DBUS-ServiceName=org.domain.mykapp. Otherwise org.kde.binaryname is assumed.
    /// </li>
    ///  @section thread Multi-threading
    ///  The static members (apart from self()), have to be called from the QApplication main thread.
    ///  Calls to members are only allowed if there is a Q(Core)Application object created
    ///  If you call the members with signal/slot connections across threads, you can't use the return values
    ///  If a function is called from the wrong thread and it has a return value -1 is returned
    ///  Investigate if this is really needed or if DCOP/DBUS is threadsafe anyway
    ///  </remarks>        <short>    KToolInvocation: for starting other programs </short>
    [SmokeClass("KToolInvocation")]
    public class KToolInvocation : QObject {
        protected KToolInvocation(Type dummy) : base((Type) null) {}
        private static SmokeInvocation staticInterceptor = null;
        static KToolInvocation() {
            staticInterceptor = new SmokeInvocation(typeof(KToolInvocation), null);
        }
        public static KToolInvocation Self() {
            return (KToolInvocation) staticInterceptor.Invoke("self", "self()", typeof(KToolInvocation));
        }
        /// <remarks>
        ///  Invokes the KHelpCenter HTML help viewer from docbook sources.
        /// <param> name="anchor" This has to be a defined anchor in your
        ///                     docbook sources. If empty the main index
        ///                     is loaded
        /// </param><param> name="appname" This allows you to show the help of another
        ///                     application. If empty the current name() is
        ///                     used
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        ///    </param></remarks>        <short>    Invokes the KHelpCenter HTML help viewer from docbook sources.</short>
        public static void InvokeHelp(string anchor, string appname, QByteArray startup_id) {
            staticInterceptor.Invoke("invokeHelp$$#", "invokeHelp(const QString&, const QString&, const QByteArray&)", typeof(void), typeof(string), anchor, typeof(string), appname, typeof(QByteArray), startup_id);
        }
        public static void InvokeHelp(string anchor, string appname) {
            staticInterceptor.Invoke("invokeHelp$$", "invokeHelp(const QString&, const QString&)", typeof(void), typeof(string), anchor, typeof(string), appname);
        }
        public static void InvokeHelp(string anchor) {
            staticInterceptor.Invoke("invokeHelp$", "invokeHelp(const QString&)", typeof(void), typeof(string), anchor);
        }
        public static void InvokeHelp() {
            staticInterceptor.Invoke("invokeHelp", "invokeHelp()", typeof(void));
        }
        /// <remarks>
        ///  Convenience method; invokes the standard email application.
        /// <param> name="address" The destination address
        /// </param><param> name="subject" Subject string. Can be string().
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        ///    </param></remarks>        <short>    Convenience method; invokes the standard email application.</short>
        public static void InvokeMailer(string address, string subject, QByteArray startup_id) {
            staticInterceptor.Invoke("invokeMailer$$#", "invokeMailer(const QString&, const QString&, const QByteArray&)", typeof(void), typeof(string), address, typeof(string), subject, typeof(QByteArray), startup_id);
        }
        public static void InvokeMailer(string address, string subject) {
            staticInterceptor.Invoke("invokeMailer$$", "invokeMailer(const QString&, const QString&)", typeof(void), typeof(string), address, typeof(string), subject);
        }
        /// <remarks>
        ///  Invokes the standard email application.
        /// <param> name="mailtoURL" A mailto URL.
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        /// </param><param> name="allowAttachments" whether attachments specified in mailtoURL should be honoured.
        ///                The default is false; do not honor requests for attachments.
        ///    </param></remarks>        <short>    Invokes the standard email application.</short>
        public static void InvokeMailer(KUrl mailtoURL, QByteArray startup_id, bool allowAttachments) {
            staticInterceptor.Invoke("invokeMailer##$", "invokeMailer(const KUrl&, const QByteArray&, bool)", typeof(void), typeof(KUrl), mailtoURL, typeof(QByteArray), startup_id, typeof(bool), allowAttachments);
        }
        public static void InvokeMailer(KUrl mailtoURL, QByteArray startup_id) {
            staticInterceptor.Invoke("invokeMailer##", "invokeMailer(const KUrl&, const QByteArray&)", typeof(void), typeof(KUrl), mailtoURL, typeof(QByteArray), startup_id);
        }
        public static void InvokeMailer(KUrl mailtoURL) {
            staticInterceptor.Invoke("invokeMailer#", "invokeMailer(const KUrl&)", typeof(void), typeof(KUrl), mailtoURL);
        }
        /// <remarks>
        ///  Convenience method; invokes the standard email application.
        ///  All parameters are optional.
        /// <param> name="to" The destination address.
        /// </param><param> name="cc" The Cc field
        /// </param><param> name="bcc" The Bcc field
        /// </param><param> name="subject" Subject string
        /// </param><param> name="body" A string containing the body of the mail (exclusive with messageFile)
        /// </param><param> name="messageFile" A file (URL) containing the body of the mail (exclusive with body) - currently unsupported
        /// </param><param> name="attachURLs" List of URLs to be attached to the mail.
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        ///    </param></remarks>        <short>    Convenience method; invokes the standard email application.</short>
        public static void InvokeMailer(string to, string cc, string bcc, string subject, string body, string messageFile, List<string> attachURLs, QByteArray startup_id) {
            staticInterceptor.Invoke("invokeMailer$$$$$$?#", "invokeMailer(const QString&, const QString&, const QString&, const QString&, const QString&, const QString&, const QStringList&, const QByteArray&)", typeof(void), typeof(string), to, typeof(string), cc, typeof(string), bcc, typeof(string), subject, typeof(string), body, typeof(string), messageFile, typeof(List<string>), attachURLs, typeof(QByteArray), startup_id);
        }
        public static void InvokeMailer(string to, string cc, string bcc, string subject, string body, string messageFile, List<string> attachURLs) {
            staticInterceptor.Invoke("invokeMailer$$$$$$?", "invokeMailer(const QString&, const QString&, const QString&, const QString&, const QString&, const QString&, const QStringList&)", typeof(void), typeof(string), to, typeof(string), cc, typeof(string), bcc, typeof(string), subject, typeof(string), body, typeof(string), messageFile, typeof(List<string>), attachURLs);
        }
        public static void InvokeMailer(string to, string cc, string bcc, string subject, string body, string messageFile) {
            staticInterceptor.Invoke("invokeMailer$$$$$$", "invokeMailer(const QString&, const QString&, const QString&, const QString&, const QString&, const QString&)", typeof(void), typeof(string), to, typeof(string), cc, typeof(string), bcc, typeof(string), subject, typeof(string), body, typeof(string), messageFile);
        }
        public static void InvokeMailer(string to, string cc, string bcc, string subject, string body) {
            staticInterceptor.Invoke("invokeMailer$$$$$", "invokeMailer(const QString&, const QString&, const QString&, const QString&, const QString&)", typeof(void), typeof(string), to, typeof(string), cc, typeof(string), bcc, typeof(string), subject, typeof(string), body);
        }
        /// <remarks>
        ///  Invokes the standard browser.
        ///  Note that you should only do this when you know for sure that the browser can
        ///  handle the URL (i.e. its mimetype). In doubt, if the URL can point to an image
        ///  or anything else than directory or HTML, prefer to use new KRun( url ).
        /// <param> name="url" The destination address
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        ///    </param></remarks>        <short>    Invokes the standard browser.</short>
        public static void InvokeBrowser(string url, QByteArray startup_id) {
            staticInterceptor.Invoke("invokeBrowser$#", "invokeBrowser(const QString&, const QByteArray&)", typeof(void), typeof(string), url, typeof(QByteArray), startup_id);
        }
        public static void InvokeBrowser(string url) {
            staticInterceptor.Invoke("invokeBrowser$", "invokeBrowser(const QString&)", typeof(void), typeof(string), url);
        }
        /// <remarks>
        ///  Invokes the standard terminal application.
        /// <param> name="command" the command to execute, can be empty.
        /// </param><param> name="workdir" the initial working directory, can be empty.
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        /// </param></remarks>        <short>    Invokes the standard terminal application.</short>
        public static void InvokeTerminal(string command, string workdir, QByteArray startup_id) {
            staticInterceptor.Invoke("invokeTerminal$$#", "invokeTerminal(const QString&, const QString&, const QByteArray&)", typeof(void), typeof(string), command, typeof(string), workdir, typeof(QByteArray), startup_id);
        }
        public static void InvokeTerminal(string command, string workdir) {
            staticInterceptor.Invoke("invokeTerminal$$", "invokeTerminal(const QString&, const QString&)", typeof(void), typeof(string), command, typeof(string), workdir);
        }
        public static void InvokeTerminal(string command) {
            staticInterceptor.Invoke("invokeTerminal$", "invokeTerminal(const QString&)", typeof(void), typeof(string), command);
        }
        /// <remarks>
        ///  Returns the DBus interface of the service launcher.
        ///  The returned object is owned by KApplication, do not delete it!
        ///    </remarks>        <short>    Returns the DBus interface of the service launcher.</short>
        public static OrgKdeKLauncherInterface Klauncher() {
            return (OrgKdeKLauncherInterface) staticInterceptor.Invoke("klauncher", "klauncher()", typeof(OrgKdeKLauncherInterface));
        }
        /// <remarks>
        ///  Starts a service based on the (translated) name of the service.
        ///  E.g. "Web Browser"
        /// <param> name="_name" the name of the service
        /// </param><param> name="URL" if not empty this URL is passed to the service
        /// </param><param> name="error" On failure, error contains a description of the error
        ///          that occurred. If the pointer is 0, the argument will be
        ///          ignored
        /// </param><param> name="serviceName" On success, serviceName contains the DCOP name
        ///          under which this service is available. If empty, the service does
        ///          not provide DCOP services. If the pointer is 0 the argument
        ///          will be ignored
        /// </param><param> name="pid" On success, the process id of the new service will be written
        ///         here. If the pointer is 0, the argument will be ignored.
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        /// </param><param> name="noWait" if set, the function does not wait till the service is running.
        /// </param></remarks>        <return> an error code indicating success (== 0) or failure (> 0).
        ///    </return>
        ///         <short>    Starts a service based on the (translated) name of the service.</short>
        public static int StartServiceByName(string _name, string URL, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id, bool noWait) {
            StackItem[] stack = new StackItem[8];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URL);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URL);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            stack[7].s_bool = noWait;
            staticInterceptor.Invoke("startServiceByName$$$$$#$", "startServiceByName(const QString&, const QString&, QString*, QString*, int*, const QByteArray&, bool)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByName(string _name, string URL, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id) {
            StackItem[] stack = new StackItem[7];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URL);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URL);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            staticInterceptor.Invoke("startServiceByName$$$$$#", "startServiceByName(const QString&, const QString&, QString*, QString*, int*, const QByteArray&)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByName(string _name, string URL, StringBuilder error, StringBuilder serviceName, ref int pid) {
            StackItem[] stack = new StackItem[6];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URL);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URL);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
            staticInterceptor.Invoke("startServiceByName$$$$$", "startServiceByName(const QString&, const QString&, QString*, QString*, int*)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
            return stack[0].s_int;
        }
        public static int StartServiceByName(string _name, string URL, StringBuilder error, StringBuilder serviceName) {
            return (int) staticInterceptor.Invoke("startServiceByName$$$$", "startServiceByName(const QString&, const QString&, QString*, QString*)", typeof(int), typeof(string), _name, typeof(string), URL, typeof(StringBuilder), error, typeof(StringBuilder), serviceName);
        }
        public static int StartServiceByName(string _name, string URL, StringBuilder error) {
            return (int) staticInterceptor.Invoke("startServiceByName$$$", "startServiceByName(const QString&, const QString&, QString*)", typeof(int), typeof(string), _name, typeof(string), URL, typeof(StringBuilder), error);
        }
        public static int StartServiceByName(string _name, string URL) {
            return (int) staticInterceptor.Invoke("startServiceByName$$", "startServiceByName(const QString&, const QString&)", typeof(int), typeof(string), _name, typeof(string), URL);
        }
        /// <remarks>
        ///  Starts a service based on the (translated) name of the service.
        ///  E.g. "Web Browser"
        /// <param> name="_name" the name of the service
        /// </param><param> name="URLs" if not empty these URLs will be passed to the service
        /// </param><param> name="error" On failure, <code>error</code> contains a description of the error
        ///          that occurred. If the pointer is 0, the argument will be
        ///          ignored
        /// </param><param> name="serviceName" On success, <code>serviceName</code> contains the DCOP name
        ///          under which this service is available. If empty, the service does
        ///          not provide DCOP services. If the pointer is 0 the argument
        ///          will be ignored
        /// </param><param> name="pid" On success, the process id of the new service will be written
        ///         here. If the pointer is 0, the argument will be ignored.
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        /// </param><param> name="noWait" if set, the function does not wait till the service is running.
        /// </param></remarks>        <return> an error code indicating success (== 0) or failure (> 0).
        ///    </return>
        ///         <short>    Starts a service based on the (translated) name of the service.</short>
        public static int StartServiceByName(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id, bool noWait) {
            StackItem[] stack = new StackItem[8];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URLs);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URLs);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            stack[7].s_bool = noWait;
            staticInterceptor.Invoke("startServiceByName$?$$$#$", "startServiceByName(const QString&, const QStringList&, QString*, QString*, int*, const QByteArray&, bool)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByName(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id) {
            StackItem[] stack = new StackItem[7];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URLs);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URLs);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            staticInterceptor.Invoke("startServiceByName$?$$$#", "startServiceByName(const QString&, const QStringList&, QString*, QString*, int*, const QByteArray&)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByName(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName, ref int pid) {
            StackItem[] stack = new StackItem[6];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URLs);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URLs);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
            staticInterceptor.Invoke("startServiceByName$?$$$", "startServiceByName(const QString&, const QStringList&, QString*, QString*, int*)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
            return stack[0].s_int;
        }
        public static int StartServiceByName(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName) {
            return (int) staticInterceptor.Invoke("startServiceByName$?$$", "startServiceByName(const QString&, const QStringList&, QString*, QString*)", typeof(int), typeof(string), _name, typeof(List<string>), URLs, typeof(StringBuilder), error, typeof(StringBuilder), serviceName);
        }
        public static int StartServiceByName(string _name, List<string> URLs, StringBuilder error) {
            return (int) staticInterceptor.Invoke("startServiceByName$?$", "startServiceByName(const QString&, const QStringList&, QString*)", typeof(int), typeof(string), _name, typeof(List<string>), URLs, typeof(StringBuilder), error);
        }
        public static int StartServiceByName(string _name, List<string> URLs) {
            return (int) staticInterceptor.Invoke("startServiceByName$?", "startServiceByName(const QString&, const QStringList&)", typeof(int), typeof(string), _name, typeof(List<string>), URLs);
        }
        public static int StartServiceByName(string _name) {
            return (int) staticInterceptor.Invoke("startServiceByName$", "startServiceByName(const QString&)", typeof(int), typeof(string), _name);
        }
        /// <remarks>
        ///  Starts a service based on the desktop path of the service.
        ///  E.g. "Applications/konqueror.desktop" or "/home/user/bla/myfile.desktop"
        /// <param> name="_name" the path of the desktop file
        /// </param><param> name="URL" if not empty this URL is passed to the service
        /// </param><param> name="error" On failure, <code>error</code> contains a description of the error
        ///          that occurred. If the pointer is 0, the argument will be
        ///          ignored
        /// </param><param> name="serviceName" On success, <code>serviceName</code> contains the DCOP name
        ///          under which this service is available. If empty, the service does
        ///          not provide DCOP services. If the pointer is 0 the argument
        ///          will be ignored
        /// </param><param> name="pid" On success, the process id of the new service will be written
        ///         here. If the pointer is 0, the argument will be ignored.
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        /// </param><param> name="noWait" if set, the function does not wait till the service is running.
        /// </param></remarks>        <return> an error code indicating success (== 0) or failure (> 0).
        ///    </return>
        ///         <short>    Starts a service based on the desktop path of the service.</short>
        public static int StartServiceByDesktopPath(string _name, string URL, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id, bool noWait) {
            StackItem[] stack = new StackItem[8];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URL);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URL);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            stack[7].s_bool = noWait;
            staticInterceptor.Invoke("startServiceByDesktopPath$$$$$#$", "startServiceByDesktopPath(const QString&, const QString&, QString*, QString*, int*, const QByteArray&, bool)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopPath(string _name, string URL, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id) {
            StackItem[] stack = new StackItem[7];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URL);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URL);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            staticInterceptor.Invoke("startServiceByDesktopPath$$$$$#", "startServiceByDesktopPath(const QString&, const QString&, QString*, QString*, int*, const QByteArray&)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopPath(string _name, string URL, StringBuilder error, StringBuilder serviceName, ref int pid) {
            StackItem[] stack = new StackItem[6];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URL);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URL);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
            staticInterceptor.Invoke("startServiceByDesktopPath$$$$$", "startServiceByDesktopPath(const QString&, const QString&, QString*, QString*, int*)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopPath(string _name, string URL, StringBuilder error, StringBuilder serviceName) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopPath$$$$", "startServiceByDesktopPath(const QString&, const QString&, QString*, QString*)", typeof(int), typeof(string), _name, typeof(string), URL, typeof(StringBuilder), error, typeof(StringBuilder), serviceName);
        }
        public static int StartServiceByDesktopPath(string _name, string URL, StringBuilder error) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopPath$$$", "startServiceByDesktopPath(const QString&, const QString&, QString*)", typeof(int), typeof(string), _name, typeof(string), URL, typeof(StringBuilder), error);
        }
        public static int StartServiceByDesktopPath(string _name, string URL) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopPath$$", "startServiceByDesktopPath(const QString&, const QString&)", typeof(int), typeof(string), _name, typeof(string), URL);
        }
        /// <remarks>
        ///  Starts a service based on the desktop path of the service.
        ///  E.g. "Applications/konqueror.desktop" or "/home/user/bla/myfile.desktop"
        /// <param> name="_name" the path of the desktop file
        /// </param><param> name="URLs" if not empty these URLs will be passed to the service
        /// </param><param> name="error" On failure, <code>error</code> contains a description of the error
        ///          that occurred. If the pointer is 0, the argument will be
        ///          ignored    @param serviceName On success, <code>serviceName</code> contains the DCOP name
        ///          under which this service is available. If empty, the service does
        ///          not provide DCOP services. If the pointer is 0 the argument
        ///          will be ignored
        /// </param><param> name="pid" On success, the process id of the new service will be written
        ///         here. If the pointer is 0, the argument will be ignored.
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        /// </param><param> name="noWait" if set, the function does not wait till the service is running.
        /// </param></remarks>        <return> an error code indicating success (== 0) or failure (> 0).
        ///    </return>
        ///         <short>    Starts a service based on the desktop path of the service.</short>
        public static int StartServiceByDesktopPath(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id, bool noWait) {
            StackItem[] stack = new StackItem[8];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URLs);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URLs);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            stack[7].s_bool = noWait;
            staticInterceptor.Invoke("startServiceByDesktopPath$?$$$#$", "startServiceByDesktopPath(const QString&, const QStringList&, QString*, QString*, int*, const QByteArray&, bool)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopPath(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id) {
            StackItem[] stack = new StackItem[7];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URLs);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URLs);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            staticInterceptor.Invoke("startServiceByDesktopPath$?$$$#", "startServiceByDesktopPath(const QString&, const QStringList&, QString*, QString*, int*, const QByteArray&)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopPath(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName, ref int pid) {
            StackItem[] stack = new StackItem[6];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URLs);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URLs);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
            staticInterceptor.Invoke("startServiceByDesktopPath$?$$$", "startServiceByDesktopPath(const QString&, const QStringList&, QString*, QString*, int*)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopPath(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopPath$?$$", "startServiceByDesktopPath(const QString&, const QStringList&, QString*, QString*)", typeof(int), typeof(string), _name, typeof(List<string>), URLs, typeof(StringBuilder), error, typeof(StringBuilder), serviceName);
        }
        public static int StartServiceByDesktopPath(string _name, List<string> URLs, StringBuilder error) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopPath$?$", "startServiceByDesktopPath(const QString&, const QStringList&, QString*)", typeof(int), typeof(string), _name, typeof(List<string>), URLs, typeof(StringBuilder), error);
        }
        public static int StartServiceByDesktopPath(string _name, List<string> URLs) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopPath$?", "startServiceByDesktopPath(const QString&, const QStringList&)", typeof(int), typeof(string), _name, typeof(List<string>), URLs);
        }
        public static int StartServiceByDesktopPath(string _name) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopPath$", "startServiceByDesktopPath(const QString&)", typeof(int), typeof(string), _name);
        }
        /// <remarks>
        ///  Starts a service based on the desktop name of the service.
        ///  E.g. "konqueror"
        /// <param> name="_name" the desktop name of the service
        /// </param><param> name="URL" if not empty this URL is passed to the service
        /// </param><param> name="error" On failure, <code>error</code> contains a description of the error
        ///          that occurred. If the pointer is 0, the argument will be
        ///          ignored
        /// </param><param> name="serviceName" On success, <code>serviceName</code> contains the D-Bus service name
        ///          under which this service is available. If empty, the service does
        ///          not provide D-Bus services. If the pointer is 0 the argument
        ///          will be ignored
        /// </param><param> name="pid" On success, the process id of the new service will be written
        ///         here. If the pointer is 0, the argument will be ignored.
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        /// </param><param> name="noWait" if set, the function does not wait till the service is running.
        /// </param></remarks>        <return> an error code indicating success (== 0) or failure (> 0).
        ///    </return>
        ///         <short>    Starts a service based on the desktop name of the service.</short>
        public static int StartServiceByDesktopName(string _name, string URL, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id, bool noWait) {
            StackItem[] stack = new StackItem[8];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URL);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URL);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            stack[7].s_bool = noWait;
            staticInterceptor.Invoke("startServiceByDesktopName$$$$$#$", "startServiceByDesktopName(const QString&, const QString&, QString*, QString*, int*, const QByteArray&, bool)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopName(string _name, string URL, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id) {
            StackItem[] stack = new StackItem[7];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URL);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URL);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            staticInterceptor.Invoke("startServiceByDesktopName$$$$$#", "startServiceByDesktopName(const QString&, const QString&, QString*, QString*, int*, const QByteArray&)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopName(string _name, string URL, StringBuilder error, StringBuilder serviceName, ref int pid) {
            StackItem[] stack = new StackItem[6];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URL);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URL);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
            staticInterceptor.Invoke("startServiceByDesktopName$$$$$", "startServiceByDesktopName(const QString&, const QString&, QString*, QString*, int*)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopName(string _name, string URL, StringBuilder error, StringBuilder serviceName) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopName$$$$", "startServiceByDesktopName(const QString&, const QString&, QString*, QString*)", typeof(int), typeof(string), _name, typeof(string), URL, typeof(StringBuilder), error, typeof(StringBuilder), serviceName);
        }
        public static int StartServiceByDesktopName(string _name, string URL, StringBuilder error) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopName$$$", "startServiceByDesktopName(const QString&, const QString&, QString*)", typeof(int), typeof(string), _name, typeof(string), URL, typeof(StringBuilder), error);
        }
        public static int StartServiceByDesktopName(string _name, string URL) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopName$$", "startServiceByDesktopName(const QString&, const QString&)", typeof(int), typeof(string), _name, typeof(string), URL);
        }
        /// <remarks>
        ///  Starts a service based on the desktop name of the service.
        ///  E.g. "konqueror"
        /// <param> name="_name" the desktop name of the service
        /// </param><param> name="URLs" if not empty these URLs will be passed to the service
        /// </param><param> name="error" On failure, <code>error</code> contains a description of the error
        ///          that occurred. If the pointer is 0, the argument will be
        ///          ignored
        /// </param><param> name="serviceName" On success, <code>serviceName</code> contains the D-Bus service name
        ///          under which this service is available. If empty, the service does
        ///          not provide D-Bus services. If the pointer is 0 the argument
        ///          will be ignored
        /// </param><param> name="pid" On success, the process id of the new service will be written
        ///         here. If the pointer is 0, the argument will be ignored.
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        /// </param><param> name="noWait" if set, the function does not wait till the service is running.
        /// </param></remarks>        <return> an error code indicating success (== 0) or failure (> 0).
        ///    </return>
        ///         <short>    Starts a service based on the desktop name of the service.</short>
        public static int StartServiceByDesktopName(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id, bool noWait) {
            StackItem[] stack = new StackItem[8];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URLs);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URLs);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            stack[7].s_bool = noWait;
            staticInterceptor.Invoke("startServiceByDesktopName$?$$$#$", "startServiceByDesktopName(const QString&, const QStringList&, QString*, QString*, int*, const QByteArray&, bool)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopName(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName, ref int pid, QByteArray startup_id) {
            StackItem[] stack = new StackItem[7];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URLs);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URLs);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
#if DEBUG
            stack[6].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[6].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            staticInterceptor.Invoke("startServiceByDesktopName$?$$$#", "startServiceByDesktopName(const QString&, const QStringList&, QString*, QString*, int*, const QByteArray&)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[6].s_class);
#else
            ((GCHandle) stack[6].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopName(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName, ref int pid) {
            StackItem[] stack = new StackItem[6];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(_name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(_name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(URLs);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(URLs);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
#if DEBUG
            stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(serviceName);
#else
            stack[4].s_class = (IntPtr) GCHandle.Alloc(serviceName);
#endif
            stack[5].s_int = pid;
            staticInterceptor.Invoke("startServiceByDesktopName$?$$$", "startServiceByDesktopName(const QString&, const QStringList&, QString*, QString*, int*)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
            ((GCHandle) stack[4].s_class).SynchronizedFree();
#endif
            pid = stack[5].s_int;
            return stack[0].s_int;
        }
        public static int StartServiceByDesktopName(string _name, List<string> URLs, StringBuilder error, StringBuilder serviceName) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopName$?$$", "startServiceByDesktopName(const QString&, const QStringList&, QString*, QString*)", typeof(int), typeof(string), _name, typeof(List<string>), URLs, typeof(StringBuilder), error, typeof(StringBuilder), serviceName);
        }
        public static int StartServiceByDesktopName(string _name, List<string> URLs, StringBuilder error) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopName$?$", "startServiceByDesktopName(const QString&, const QStringList&, QString*)", typeof(int), typeof(string), _name, typeof(List<string>), URLs, typeof(StringBuilder), error);
        }
        public static int StartServiceByDesktopName(string _name, List<string> URLs) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopName$?", "startServiceByDesktopName(const QString&, const QStringList&)", typeof(int), typeof(string), _name, typeof(List<string>), URLs);
        }
        public static int StartServiceByDesktopName(string _name) {
            return (int) staticInterceptor.Invoke("startServiceByDesktopName$", "startServiceByDesktopName(const QString&)", typeof(int), typeof(string), _name);
        }
        /// <remarks>
        ///  Starts a program via kdeinit.
        ///  program name and arguments are converted to according to the
        ///  local encoding and passed as is to kdeinit.
        /// <param> name="name" Name of the program to start
        /// </param><param> name="args" Arguments to pass to the program
        /// </param><param> name="error" On failure, <code>error</code> contains a description of the error
        ///          that occurred. If the pointer is 0, the argument will be
        ///          ignored
        /// </param><param> name="pid" On success, the process id of the new service will be written
        ///         here. If the pointer is 0, the argument will be ignored.
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        /// </param></remarks>        <return> an error code indicating success (== 0) or failure (> 0).
        ///    </return>
        ///         <short>    Starts a program via kdeinit.</short>
        public static int KdeinitExec(string name, List<string> args, StringBuilder error, ref int pid, QByteArray startup_id) {
            StackItem[] stack = new StackItem[6];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(args);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(args);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
            stack[4].s_int = pid;
#if DEBUG
            stack[5].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[5].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            staticInterceptor.Invoke("kdeinitExec$?$$#", "kdeinitExec(const QString&, const QStringList&, QString*, int*, const QByteArray&)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
            pid = stack[4].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[5].s_class);
#else
            ((GCHandle) stack[5].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int KdeinitExec(string name, List<string> args, StringBuilder error, ref int pid) {
            StackItem[] stack = new StackItem[5];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(args);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(args);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
            stack[4].s_int = pid;
            staticInterceptor.Invoke("kdeinitExec$?$$", "kdeinitExec(const QString&, const QStringList&, QString*, int*)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
            pid = stack[4].s_int;
            return stack[0].s_int;
        }
        public static int KdeinitExec(string name, List<string> args, StringBuilder error) {
            return (int) staticInterceptor.Invoke("kdeinitExec$?$", "kdeinitExec(const QString&, const QStringList&, QString*)", typeof(int), typeof(string), name, typeof(List<string>), args, typeof(StringBuilder), error);
        }
        public static int KdeinitExec(string name, List<string> args) {
            return (int) staticInterceptor.Invoke("kdeinitExec$?", "kdeinitExec(const QString&, const QStringList&)", typeof(int), typeof(string), name, typeof(List<string>), args);
        }
        public static int KdeinitExec(string name) {
            return (int) staticInterceptor.Invoke("kdeinitExec$", "kdeinitExec(const QString&)", typeof(int), typeof(string), name);
        }
        /// <remarks>
        ///  Starts a program via kdeinit and wait for it to finish.
        ///  Like kdeinitExec(), but it waits till the program is finished.
        ///  As such it behaves similar to the system(...) function.
        /// <param> name="name" Name of the program to start
        /// </param><param> name="args" Arguments to pass to the program
        /// </param><param> name="error" On failure, <code>error</code> contains a description of the error
        ///          that occurred. If the pointer is 0, the argument will be
        ///          ignored
        /// </param><param> name="pid" On success, the process id of the new service will be written
        ///         here. If the pointer is 0, the argument will be ignored.
        /// </param><param> name="startup_id" for app startup notification, "0" for none,
        ///            "" ( empty string ) is the default
        /// </param></remarks>        <return> an error code indicating success (== 0) or failure (> 0).
        ///    </return>
        ///         <short>    Starts a program via kdeinit and wait for it to finish.</short>
        public static int KdeinitExecWait(string name, List<string> args, StringBuilder error, ref int pid, QByteArray startup_id) {
            StackItem[] stack = new StackItem[6];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(args);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(args);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
            stack[4].s_int = pid;
#if DEBUG
            stack[5].s_class = (IntPtr) DebugGCHandle.Alloc(startup_id);
#else
            stack[5].s_class = (IntPtr) GCHandle.Alloc(startup_id);
#endif
            staticInterceptor.Invoke("kdeinitExecWait$?$$#", "kdeinitExecWait(const QString&, const QStringList&, QString*, int*, const QByteArray&)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
            pid = stack[4].s_int;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[5].s_class);
#else
            ((GCHandle) stack[5].s_class).SynchronizedFree();
#endif
            return stack[0].s_int;
        }
        public static int KdeinitExecWait(string name, List<string> args, StringBuilder error, ref int pid) {
            StackItem[] stack = new StackItem[5];
#if DEBUG
            stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(name);
#else
            stack[1].s_class = (IntPtr) GCHandle.Alloc(name);
#endif
#if DEBUG
            stack[2].s_class = (IntPtr) DebugGCHandle.Alloc(args);
#else
            stack[2].s_class = (IntPtr) GCHandle.Alloc(args);
#endif
#if DEBUG
            stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(error);
#else
            stack[3].s_class = (IntPtr) GCHandle.Alloc(error);
#endif
            stack[4].s_int = pid;
            staticInterceptor.Invoke("kdeinitExecWait$?$$", "kdeinitExecWait(const QString&, const QStringList&, QString*, int*)", stack);
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
            ((GCHandle) stack[1].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[2].s_class);
#else
            ((GCHandle) stack[2].s_class).SynchronizedFree();
#endif
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
            ((GCHandle) stack[3].s_class).SynchronizedFree();
#endif
            pid = stack[4].s_int;
            return stack[0].s_int;
        }
        public static int KdeinitExecWait(string name, List<string> args, StringBuilder error) {
            return (int) staticInterceptor.Invoke("kdeinitExecWait$?$", "kdeinitExecWait(const QString&, const QStringList&, QString*)", typeof(int), typeof(string), name, typeof(List<string>), args, typeof(StringBuilder), error);
        }
        public static int KdeinitExecWait(string name, List<string> args) {
            return (int) staticInterceptor.Invoke("kdeinitExecWait$?", "kdeinitExecWait(const QString&, const QStringList&)", typeof(int), typeof(string), name, typeof(List<string>), args);
        }
        public static int KdeinitExecWait(string name) {
            return (int) staticInterceptor.Invoke("kdeinitExecWait$", "kdeinitExecWait(const QString&)", typeof(int), typeof(string), name);
        }
        protected new IKToolInvocationSignals Emit {
            get { return (IKToolInvocationSignals) Q_EMIT; }
        }
    }

    public interface IKToolInvocationSignals : IQObjectSignals {
    }
}
