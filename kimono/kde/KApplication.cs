//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  Controls and provides information to all KDE applications.
    ///  Only one object of this class can be instantiated in a single app.
    ///  This instance is always accessible via the 'kapp' global variable.
    ///  This class provides the following services to all KDE applications.
    /// 
    /// <li>
    /// It controls the event queue (see QApplication ).
    /// </li>
    /// 
    /// <li>
    /// It provides the application with KDE resources such as
    ///  accelerators, common menu entries, a KConfig object. session
    ///  management events, help invocation etc.
    /// </li>
    /// 
    /// <li>
    /// Installs an empty signal handler for the SIGPIPE signal.
    ///  If you want to catch this signal
    ///  yourself, you have set a new signal handler after KApplication's
    ///  constructor has run.
    /// </li>
    /// 
    /// <li>
    /// It can start new services
    /// </li>
    ///  See <see cref="IKApplicationSignals"></see> for signals emitted by KApplication
    /// </remarks>        <author> Matthias Kalle Dalheimer <kalle@kde.org>
    /// </author>
    ///         <short> Controls and provides information to all KDE applications. </short>
    [SmokeClass("KApplication")]
    public class KApplication : QApplication, IDisposable {
        protected KApplication(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KApplication), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KApplication() {
            staticInterceptor = new SmokeInvocation(typeof(KApplication), null);
        }
        public static bool LoadedByKdeinit() {
            return (bool) staticInterceptor.Invoke("loadedByKdeinit", "loadedByKdeinit()", typeof(bool));
        }
        // int xErrhandler(Display* arg1,void* arg2); >>>> NOT CONVERTED
        // int xioErrhandler(Display* arg1); >>>> NOT CONVERTED
        // void iceIOErrorHandler(_IceConn* arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  This constructor is the one you should use.
        ///  It takes aboutData and command line arguments from KCmdLineArgs.
        /// <param> name="GUIenabled" Set to false to disable all GUI stuff.
        ///  Note that for a non-GUI daemon, you might want to use QCoreApplication
        ///  and a KComponentData instance instead. The main difference will be
        ///  that you'll have to register to DBus yourself, but there is no
        ///  point in a kdeui dependency in a non-GUI daemon.
        ///    </param></remarks>        <short>    This constructor is the one you should use.</short>
        public KApplication(bool GUIenabled) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KApplication$", "KApplication(bool)", typeof(void), typeof(bool), GUIenabled);
        }
        public KApplication() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KApplication", "KApplication()", typeof(void));
        }
        /// <remarks>
        ///  Returns the application session config object.
        /// </remarks>        <return> A pointer to the application's instance specific
        ///  KConfig object.
        /// </return>
        ///         <short>    Returns the application session config object.</short>
        ///         <see> KConfig</see>
        public KConfig SessionConfig() {
            return (KConfig) interceptor.Invoke("sessionConfig", "sessionConfig()", typeof(KConfig));
        }
        /// <remarks>
        ///  Disables session management for this application.
        ///  Useful in case  your application is started by the
        ///  initial "startkde" script.
        ///    </remarks>        <short>    Disables session management for this application.</short>
        public void DisableSessionManagement() {
            interceptor.Invoke("disableSessionManagement", "disableSessionManagement()", typeof(void));
        }
        /// <remarks>
        ///  Enables session management for this application, formerly
        ///  disabled by calling disableSessionManagement(). You usually
        ///  shouldn't call this function, as session management is enabled
        ///  by default.
        ///    </remarks>        <short>    Enables session management for this application, formerly  disabled by calling disableSessionManagement().</short>
        public void EnableSessionManagement() {
            interceptor.Invoke("enableSessionManagement", "enableSessionManagement()", typeof(void));
        }
        /// <remarks>
        ///  Reimplemented for internal purposes, mainly the highlevel
        ///   handling of session management with KSessionManager.
        ///      </remarks>        <short>    Reimplemented for internal purposes, mainly the highlevel   handling of session management with KSessionManager.</short>
        [SmokeMethod("commitData(QSessionManager&)")]
        public override void CommitData(QSessionManager sm) {
            interceptor.Invoke("commitData#", "commitData(QSessionManager&)", typeof(void), typeof(QSessionManager), sm);
        }
        /// <remarks>
        ///  Reimplemented for internal purposes, mainly the highlevel
        ///   handling of session management with KSessionManager.
        ///      </remarks>        <short>    Reimplemented for internal purposes, mainly the highlevel   handling of session management with KSessionManager.</short>
        [SmokeMethod("saveState(QSessionManager&)")]
        public override void SaveState(QSessionManager sm) {
            interceptor.Invoke("saveState#", "saveState(QSessionManager&)", typeof(void), typeof(QSessionManager), sm);
        }
        /// <remarks>
        ///  Returns true if the application is currently saving its session
        ///  data (most probably before KDE logout). This is intended for use
        ///  mainly in KMainWindow.QueryClose() and KMainWindow.QueryExit().
        /// </remarks>        <short>    Returns true if the application is currently saving its session  data (most probably before KDE logout).</short>
        ///         <see> KMainWindow.QueryClose</see>
        ///         <see> KMainWindow.QueryExit</see>
        public bool SessionSaving() {
            return (bool) interceptor.Invoke("sessionSaving", "sessionSaving() const", typeof(bool));
        }
        /// <remarks>
        ///   Sets the top widget of the application.
        ///   This means basically applying the right window caption.
        ///   An application may have several top widgets. You don't
        ///   need to call this function manually when using KMainWindow.
        /// <param> name="topWidget" A top widget of the application.
        /// </param></remarks>        <short>     Sets the top widget of the application.</short>
        ///         <see> icon</see>
        ///         <see> caption</see>
        public void SetTopWidget(QWidget topWidget) {
            interceptor.Invoke("setTopWidget#", "setTopWidget(QWidget*)", typeof(void), typeof(QWidget), topWidget);
        }
        /// <remarks>
        ///   Installs widget filter as global X11 event filter.
        ///  The widget
        ///   filter receives XEvents in its standard QWidget.X11Event() function.
        ///   Warning: Only do this when absolutely necessary. An installed X11 filter
        ///   can slow things down.
        /// </remarks>        <short>     Installs widget filter as global X11 event filter.</short>
        public void InstallX11EventFilter(QWidget filter) {
            interceptor.Invoke("installX11EventFilter#", "installX11EventFilter(QWidget*)", typeof(void), typeof(QWidget), filter);
        }
        /// <remarks>
        ///  Removes global X11 event filter previously installed by
        ///  installX11EventFilter().
        ///    </remarks>        <short>    Removes global X11 event filter previously installed by  installX11EventFilter().</short>
        public void RemoveX11EventFilter(QWidget filter) {
            interceptor.Invoke("removeX11EventFilter#", "removeX11EventFilter(const QWidget*)", typeof(void), typeof(QWidget), filter);
        }
        /// <remarks>
        ///  Returns the app startup notification identifier for this running
        ///  application.
        /// </remarks>        <return> the startup notification identifier
        ///    </return>
        ///         <short>    Returns the app startup notification identifier for this running  application.</short>
        public QByteArray StartupId() {
            return (QByteArray) interceptor.Invoke("startupId", "startupId() const", typeof(QByteArray));
        }
        /// <remarks>
        ///  Sets a new value for the application startup notification window property for newly
        ///  created toplevel windows.
        /// <param> name="startup_id" the startup notification identifier
        /// </param></remarks>        <short>   </short>
        ///         <see> KStartupInfo.SetNewStartupId</see>
        public void SetStartupId(QByteArray startup_id) {
            interceptor.Invoke("setStartupId#", "setStartupId(const QByteArray&)", typeof(void), typeof(QByteArray), startup_id);
        }
        /// <remarks>
        ///  Used only by KStartupId.
        ///    </remarks>        <short>   </short>
        public void ClearStartupId() {
            interceptor.Invoke("clearStartupId", "clearStartupId()", typeof(void));
        }
        /// <remarks>
        ///  Sets how the primary and clipboard selections are synchronized in an X11 environment
        ///    </remarks>        <short>    Sets how the primary and clipboard selections are synchronized in an X11 environment    </short>
        public void SetSynchronizeClipboard(bool synchronize) {
            interceptor.Invoke("setSynchronizeClipboard$", "setSynchronizeClipboard(bool)", typeof(void), typeof(bool), synchronize);
        }
        /// <remarks>
        ///  Returns the last user action timestamp or 0 if no user activity has taken place yet.
        /// </remarks>        <short>    Returns the last user action timestamp or 0 if no user activity has taken place yet.</short>
        ///         <see> updateuserTimestamp</see>
        public ulong UserTimestamp() {
            return (ulong) interceptor.Invoke("userTimestamp", "userTimestamp() const", typeof(ulong));
        }
        /// <remarks>
        ///  Updates the last user action timestamp in the application registered to DBUS with id service
        ///  to the given time, or to this application's user time, if 0 is given.
        ///  Use before causing user interaction in the remote application, e.g. invoking a dialog
        ///  in the application using a DCOP call.
        ///  Consult focus stealing prevention section in kdebase/kwin/README.
        ///    </remarks>        <short>    Updates the last user action timestamp in the application registered to DBUS with id service  to the given time, or to this application's user time, if 0 is given.</short>
        public void UpdateRemoteUserTimestamp(string service, int time) {
            interceptor.Invoke("updateRemoteUserTimestamp$$", "updateRemoteUserTimestamp(const QString&, int)", typeof(void), typeof(string), service, typeof(int), time);
        }
        public void UpdateRemoteUserTimestamp(string service) {
            interceptor.Invoke("updateRemoteUserTimestamp$", "updateRemoteUserTimestamp(const QString&)", typeof(void), typeof(string), service);
        }
        /// <remarks>
        ///     </remarks>        <short>   </short>
        [SmokeMethod("notify(QObject*, QEvent*)")]
        public override bool Notify(QObject receiver, QEvent arg2) {
            return (bool) interceptor.Invoke("notify##", "notify(QObject*, QEvent*)", typeof(bool), typeof(QObject), receiver, typeof(QEvent), arg2);
        }
        /// <remarks>
        ///     </remarks>        <short>   </short>
        /// <remarks>
        ///     </remarks>        <short>   </short>
        /// <remarks>
        ///    </remarks>        <short>   </short>
        /// <remarks>
        ///  Updates the last user action timestamp to the given time, or to the current time,
        ///  if 0 is given. Do not use unless you're really sure what you're doing.
        ///  Consult focus stealing prevention section in kdebase/kwin/README.
        ///    </remarks>        <short>    Updates the last user action timestamp to the given time, or to the current time,  if 0 is given.</short>
        [Q_SLOT("void updateUserTimestamp(int)")]
        public void UpdateUserTimestamp(int time) {
            interceptor.Invoke("updateUserTimestamp$", "updateUserTimestamp(int)", typeof(void), typeof(int), time);
        }
        [Q_SLOT("void updateUserTimestamp()")]
        public void UpdateUserTimestamp() {
            interceptor.Invoke("updateUserTimestamp", "updateUserTimestamp()", typeof(void));
        }
        [Q_SLOT("void reparseConfiguration()")]
        public void ReparseConfiguration() {
            interceptor.Invoke("reparseConfiguration", "reparseConfiguration()", typeof(void));
        }
        [Q_SLOT("void quit()")]
        public new void Quit() {
            interceptor.Invoke("quit", "quit()", typeof(void));
        }
        /// <remarks>
        ///    </remarks>        <short>   </short>
        public KApplication(bool GUIenabled, KComponentData cData) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KApplication$#", "KApplication(bool, const KComponentData&)", typeof(void), typeof(bool), GUIenabled, typeof(KComponentData), cData);
        }
        ~KApplication() {
            interceptor.Invoke("~KApplication", "~KApplication()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KApplication", "~KApplication()", typeof(void));
        }
        /// <remarks>
        ///  Returns the current application object.
        ///  This is similar to the global QApplication pointer qApp. It
        ///  allows access to the single global KApplication object, since
        ///  more than one cannot be created in the same application. It
        ///  saves you the trouble of having to pass the pointer explicitly
        ///  to every function that may require it.
        /// </remarks>        <return> the current application object
        ///    </return>
        ///         <short>    Returns the current application object.</short>
        public static KApplication kApplication() {
            return (KApplication) staticInterceptor.Invoke("kApplication", "kApplication()", typeof(KApplication));
        }
        /// <remarks>
        ///  Check whether  an auto-save file exists for the document you want to
        ///  open.
        /// <param> name="pFilename" The full path to the document you want to open.
        /// </param><param> name="bRecover" This gets set to true if there was a recover
        ///  file.
        /// </param></remarks>        <return> The full path of the file to open.
        ///    </return>
        ///         <short>    Check whether  an auto-save file exists for the document you want to  open.</short>
        public static string CheckRecoverFile(string pFilename, bool bRecover) {
            return (string) staticInterceptor.Invoke("checkRecoverFile$$", "checkRecoverFile(const QString&, bool&)", typeof(string), typeof(string), pFilename, typeof(bool), bRecover);
        }
        protected new IKApplicationSignals Emit {
            get { return (IKApplicationSignals) Q_EMIT; }
        }
    }

    public interface IKApplicationSignals : IQApplicationSignals {
        /// <remarks>
        ///       Session management asks you to save the state of your application.
        ///      This signal is provided for compatibility only. For new
        ///      applications, simply use KMainWindow. By reimplementing
        ///      KMainWindow.QueryClose(), KMainWindow.SaveProperties() and
        ///      KMainWindow.ReadProperties() you can simply handle session
        ///      management for applications with multiple toplevel windows.
        ///      For purposes without KMainWindow, create an instance of
        ///      KSessionManager and reimplement the functions
        ///      KSessionManager.CommitData() and/or
        ///      KSessionManager.SaveState()
        ///      If you still want to use this signal, here is what you should do:
        ///      Connect to this signal in order to save your data. Do NOT
        ///      manipulate the UI in that slot, it is blocked by the session
        ///      manager.
        ///      Use the sessionConfig() KConfig object to store all your
        ///      instance specific data.
        ///      Do not do any closing at this point! The user may still select
        ///      Cancel  wanting to continue working with your
        ///      application. Cleanups could be done after aboutToQuit().
        ///   </remarks>        <short>         Session management asks you to save the state of your application.</short>
        [Q_SIGNAL("void saveYourself()")]
        void SaveYourself();
    }
}
