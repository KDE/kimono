//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Text;
    using System.Collections.Generic;
    /// <remarks>
    ///  Base class for all Sycoca entries.
    ///  You can't create an instance of KSycocaEntry, but it provides
    ///  the common functionality for servicetypes and services.
    /// </remarks>        <short>    Base class for all Sycoca entries.</short>
    ///         <see> http://techbase.kde.org/Development/Architecture/KDE3/System_Configuration_Cache</see>
    [SmokeClass("KSycocaEntry")]
    public class KSycocaEntry : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KSycocaEntry(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KSycocaEntry), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KSycocaEntry() {
            staticInterceptor = new SmokeInvocation(typeof(KSycocaEntry), null);
        }
        // KSycocaEntry* KSycocaEntry(KSycocaEntryPrivate& arg1); >>>> NOT CONVERTED
        public KSycocaEntry() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KSycocaEntry", "KSycocaEntry()", typeof(void));
        }
        /// <remarks>
        ///  internal
        ///     </remarks>        <short>    internal     </short>
        public bool IsType(int t) {
            return (bool) interceptor.Invoke("isType?", "isType(KSycocaType) const", typeof(bool), typeof(int), t);
        }
        /// <remarks>
        ///  internal
        ///     </remarks>        <short>    internal     </short>
        public int SycocaType() {
            return (int) interceptor.Invoke("sycocaType", "sycocaType() const", typeof(int));
        }
        /// <remarks>
        /// </remarks>        <return> the name of this entry
        ///     </return>
        ///         <short>   </short>
        public string Name() {
            return (string) interceptor.Invoke("name", "name() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> the path of this entry
        ///  The path can be absolute or relative.
        ///  The corresponding factory should know relative to what.
        ///     </return>
        ///         <short>   </short>
        public string EntryPath() {
            return (string) interceptor.Invoke("entryPath", "entryPath() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> true if valid
        ///     </return>
        ///         <short>   </short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        /// </remarks>        <return> true if deleted
        ///     </return>
        ///         <short>   </short>
        public bool IsDeleted() {
            return (bool) interceptor.Invoke("isDeleted", "isDeleted() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns the requested property. Some often used properties
        ///  have convenience access functions like exec(),
        ///  serviceTypes etc.
        /// <param> name="_name" the name of the property
        /// </param></remarks>        <return> the property, or invalid if not found
        ///      </return>
        ///         <short>    Returns the requested property.</short>
        public QVariant Property(string name) {
            return (QVariant) interceptor.Invoke("property$", "property(const QString&) const", typeof(QVariant), typeof(string), name);
        }
        /// <remarks>
        ///  Returns the list of all properties that this service can have.
        ///  That means, that some of these properties may be empty.
        /// </remarks>        <return> the list of supported properties
        ///      </return>
        ///         <short>    Returns the list of all properties that this service can have.</short>
        public List<string> PropertyNames() {
            return (List<string>) interceptor.Invoke("propertyNames", "propertyNames() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Sets whether or not this service is deleted
        ///     </remarks>        <short>    Sets whether or not this service is deleted     </short>
        public void SetDeleted(bool deleted) {
            interceptor.Invoke("setDeleted$", "setDeleted(bool)", typeof(void), typeof(bool), deleted);
        }
        public bool IsSeparator() {
            return (bool) interceptor.Invoke("isSeparator", "isSeparator() const", typeof(bool));
        }
        /// <remarks>
        /// </remarks>        <return> the position of the entry in the sycoca file
        ///     </return>
        ///         <short>   </short>
        public int Offset() {
            return (int) interceptor.Invoke("offset", "offset() const", typeof(int));
        }
        /// <remarks>
        ///  Save ourselves to the database. Don't forget to call the parent class
        ///  first if you override this function.
        ///     </remarks>        <short>   </short>
        public void Save(QDataStream s) {
            interceptor.Invoke("save#", "save(QDataStream&)", typeof(void), typeof(QDataStream), s);
        }
        ~KSycocaEntry() {
            interceptor.Invoke("~KSycocaEntry", "~KSycocaEntry()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KSycocaEntry", "~KSycocaEntry()", typeof(void));
        }
        /// <remarks>
        ///  Safe demarshalling functions.
        ///     </remarks>        <short>    Safe demarshalling functions.</short>
        public static void Read(QDataStream s, StringBuilder str) {
            staticInterceptor.Invoke("read#$", "read(QDataStream&, QString&)", typeof(void), typeof(QDataStream), s, typeof(StringBuilder), str);
        }
        public static void Read(QDataStream s, List<string> list) {
            staticInterceptor.Invoke("read#?", "read(QDataStream&, QStringList&)", typeof(void), typeof(QDataStream), s, typeof(List<string>), list);
        }
    }
}
