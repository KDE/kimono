//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  Read-only SYstem COnfiguration CAche
    ///   See <see cref="IKSycocaSignals"></see> for signals emitted by KSycoca
    /// </remarks>        <short>   </short>
    [SmokeClass("KSycoca")]
    public class KSycoca : QObject, IDisposable {
        protected KSycoca(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KSycoca), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KSycoca() {
            staticInterceptor = new SmokeInvocation(typeof(KSycoca), null);
        }
        // void addFactory(KSycocaFactory* arg1); >>>> NOT CONVERTED
        // QString absoluteFilePath(KSycoca::DatabaseType arg1); >>>> NOT CONVERTED
        // KSycocaFactoryList* factories(); >>>> NOT CONVERTED
        /// <remarks>
        ///  Read-only database
        ///     </remarks>        <short>    Read-only database     </short>
        public KSycoca() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KSycoca", "KSycoca()", typeof(void));
        }
        /// <remarks>
        ///  This is how factories get a stream to an entry
        ///     </remarks>        <short>   </short>
        public QDataStream FindEntry(int offset, int type) {
            return (QDataStream) interceptor.Invoke("findEntry$?", "findEntry(int, KSycocaType&)", typeof(QDataStream), typeof(int), offset, typeof(int), type);
        }
        /// <remarks>
        ///     </remarks>        <short>   </short>
        public QDataStream FindFactory(int id) {
            return (QDataStream) interceptor.Invoke("findFactory?", "findFactory(KSycocaFactoryId)", typeof(QDataStream), typeof(int), id);
        }
        /// <remarks>
        ///     </remarks>        <short>   </short>
        public string Kfsstnd_prefixes() {
            return (string) interceptor.Invoke("kfsstnd_prefixes", "kfsstnd_prefixes()", typeof(string));
        }
        /// <remarks>
        ///     </remarks>        <short>   </short>
        public string Language() {
            return (string) interceptor.Invoke("language", "language()", typeof(string));
        }
        /// <remarks>
        ///  The database contains all changes made _before_ this time and
        ///  _might_ contain changes made after that.
        ///     </remarks>        <short>   </short>
        public uint TimeStamp() {
            return (uint) interceptor.Invoke("timeStamp", "timeStamp()", typeof(uint));
        }
        /// <remarks>
        ///  Signature that keeps track of changes to
        ///  $KDEDIR/share/services/update_ksycoca
        ///  Touching this file causes the database to be recreated
        ///  from scratch.
        ///     </remarks>        <short>   </short>
        public uint UpdateSignature() {
            return (uint) interceptor.Invoke("updateSignature", "updateSignature()", typeof(uint));
        }
        /// <remarks>
        ///  stored inside sycoca.
        ///     </remarks>        <short>   </short>
        public List<string> AllResourceDirs() {
            return (List<string>) interceptor.Invoke("allResourceDirs", "allResourceDirs()", typeof(List<string>));
        }
        /// <remarks>
        ///     </remarks>        <short>   </short>
        /// <remarks>
        /// </remarks>        <return> true if building (i.e. if a KBuildSycoca);
        ///     </return>
        ///         <short>   </short>
        [SmokeMethod("isBuilding()")]
        public virtual bool IsBuilding() {
            return (bool) interceptor.Invoke("isBuilding", "isBuilding()", typeof(bool));
        }
        /// <remarks>
        ///     </remarks>        <short>   </short>
        public void DisableAutoRebuild() {
            interceptor.Invoke("disableAutoRebuild", "disableAutoRebuild()", typeof(void));
        }
        /// <remarks>
        ///  Building database
        ///     </remarks>        <short>   </short>
        public KSycoca(bool arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KSycoca$", "KSycoca(bool)", typeof(void), typeof(bool), arg1);
        }
        ~KSycoca() {
            interceptor.Invoke("~KSycoca", "~KSycoca()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KSycoca", "~KSycoca()", typeof(void));
        }
        /// <remarks>
        ///  Get or create the only instance of KSycoca (read-only)
        ///     </remarks>        <short>    Get or create the only instance of KSycoca (read-only)     </short>
        public static KSycoca Self() {
            return (KSycoca) staticInterceptor.Invoke("self", "self()", typeof(KSycoca));
        }
        /// <remarks>
        /// </remarks>        <return> the compiled-in version, i.e. the one used when writing a new ksycoca
        ///     </return>
        ///         <short>   </short>
        public static int Version() {
            return (int) staticInterceptor.Invoke("version", "version()", typeof(int));
        }
        /// <remarks>
        /// </remarks>        <return> true if the ksycoca database is available
        ///  This is usually the case, except if KDE isn't installed yet,
        ///  or before kded is started.
        ///     </return>
        ///         <short>   </short>
        public static bool IsAvailable() {
            return (bool) staticInterceptor.Invoke("isAvailable", "isAvailable()", typeof(bool));
        }
        /// <remarks>
        ///  for global database type the database is searched under 
        ///  the 'services' install path. 
        ///  Otherwise, the value from the environment variable KDESYCOCA 
        ///  is returned if set. If not set the path is build based on  
        ///  KStandardDirs cache save location. 
        ///     </remarks>        <short>   </short>
        /// <remarks>
        ///  When you receive a "databaseChanged" signal, you can query here if
        ///  a change has occurred in a specific resource type.
        /// </remarks>        <short>    When you receive a "databaseChanged" signal, you can query here if  a change has occurred in a specific resource type.</short>
        ///         <see> KStandardDirs</see>
        ///         <see> for</see>
        ///         <see> the</see>
        ///         <see> various</see>
        ///         <see> resource</see>
        ///         <see> types.</see>
        public static bool IsChanged(string type) {
            return (bool) staticInterceptor.Invoke("isChanged$", "isChanged(const char*)", typeof(bool), typeof(string), type);
        }
        /// <remarks>
        ///  A read error occurs.
        ///     </remarks>        <short>    A read error occurs.</short>
        public static void FlagError() {
            staticInterceptor.Invoke("flagError", "flagError()", typeof(void));
        }
        /// <remarks>
        ///  Returns read error status and clears flag.
        ///     </remarks>        <short>    Returns read error status and clears flag.</short>
        public static bool ReadError() {
            return (bool) staticInterceptor.Invoke("readError", "readError()", typeof(bool));
        }
        protected new IKSycocaSignals Emit {
            get { return (IKSycocaSignals) Q_EMIT; }
        }
    }

    public interface IKSycocaSignals : IQObjectSignals {
        /// <remarks>
        ///  Connect to this to get notified when the database changes
        ///  (Usually apps showing icons do a 'refresh' to take into account the new mimetypes)
        ///     </remarks>        <short>    Connect to this to get notified when the database changes  (Usually apps showing icons do a 'refresh' to take into account the new mimetypes)     </short>
        [Q_SIGNAL("void databaseChanged()")]
        void DatabaseChanged();
    }
}
