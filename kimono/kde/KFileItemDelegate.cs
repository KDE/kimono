//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  KFileItemDelegate is intended to be used to provide a KDE file system
    ///  view, when using one of the standard item views in Qt with KDirModel.
    ///  While primarily intended to be used with KDirModel, it uses
    ///  Qt.DecorationRole and Qt.DisplayRole for the icons and text labels,
    ///  just like QItemDelegate, and can thus be used with any standard model.
    ///  When used with KDirModel however, KFileItemDelegate can change the way
    ///  the display and/or decoration roles are drawn, based on properties
    ///  of the file items. For example, if the file item is a symbolic link,
    ///  it will use an italic font to draw the file name.
    ///  KFileItemDelegate also supports showing additional information about
    ///  the file items below the icon labels.
    ///  Which information should be shown, if any, is controlled by the
    ///  <see cref="#information"></see> property, which is a list that can be set by calling
    ///  setShowInformation(), and read by calling showInformation().
    ///  By default this list is empty.
    ///  To use KFileItemDelegate, instantiate an object from the delegate,
    ///  and call setItemDelegate() in one of the standard item views in Qt:
    ///  @code
    ///  QListView listview = new QListView(this);
    ///  KFileItemDelegate delegate = new KFileItemDelegate(this);
    ///  listview.SetItemDelegate(delegate);
    ///  @endcode
    ///  </remarks>        <short>    KFileItemDelegate is intended to be used to provide a KDE file system  view, when using one of the standard item views in Qt with KDirModel.</short>
    [SmokeClass("KFileItemDelegate")]
    public class KFileItemDelegate : QAbstractItemDelegate, IDisposable {
        protected KFileItemDelegate(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KFileItemDelegate), this);
        }
        /// <remarks>
        ///  This enum defines the additional information that can be displayed below item
        ///  labels in icon views.
        ///  The information will only be shown for indexes for which the model provides
        ///  a valid value for KDirModel.FileItemRole, and only when there's sufficient vertical
        ///  space to display at least one line of the information, along with the display label.
        ///  For the number of items to be shown for folders, the model must provide a valid
        ///  value for KDirMode.ChildCountRole, in addition to KDirModel.FileItemRole.
        ///  Note that KFileItemDelegate will not call KFileItem.DetermineMimeType() if
        ///  KFileItem.IsMimeTypeKnown() returns false, so if you want to display mime types
        ///  you should use a KMimeTypeResolver with the model and the view, to ensure that mime
        ///  types are resolved. If the mime type isn't known, "Unknown" will be displayed until
        ///  the mime type has been successfully resolved.
        /// </remarks>        <short>    This enum defines the additional information that can be displayed below item  labels in icon views.</short>
        ///         <see> setShowInformation</see>
        ///         <see> showInformation</see>
        ///         <see> information</see>
        public enum Information {
            NoInformation = 0,
            Size = 1,
            Permissions = 2,
            OctalPermissions = 3,
            Owner = 4,
            OwnerAndGroup = 5,
            CreationTime = 6,
            ModificationTime = 7,
            AccessTime = 8,
            MimeType = 9,
            FriendlyMimeType = 10,
        }
        [Q_PROPERTY("QList<KFileItemDelegate::Information>", "information")]
        public List<KFileItemDelegate.Information> information {
            get { return (List<KFileItemDelegate.Information>) interceptor.Invoke("showInformation", "showInformation()", typeof(List<KFileItemDelegate.Information>)); }
            set { interceptor.Invoke("setShowInformation?", "setShowInformation(QList<KFileItemDelegate::Information>)", typeof(void), typeof(List<KFileItemDelegate.Information>), value); }
        }
        [Q_PROPERTY("QColor", "shadowColor")]
        public QColor ShadowColor {
            get { return (QColor) interceptor.Invoke("shadowColor", "shadowColor()", typeof(QColor)); }
            set { interceptor.Invoke("setShadowColor#", "setShadowColor(QColor)", typeof(void), typeof(QColor), value); }
        }
        [Q_PROPERTY("QPointF", "shadowOffset")]
        public QPointF ShadowOffset {
            get { return (QPointF) interceptor.Invoke("shadowOffset", "shadowOffset()", typeof(QPointF)); }
            set { interceptor.Invoke("setShadowOffset#", "setShadowOffset(QPointF)", typeof(void), typeof(QPointF), value); }
        }
        [Q_PROPERTY("qreal", "shadowBlur")]
        public double ShadowBlur {
            get { return (double) interceptor.Invoke("shadowBlur", "shadowBlur()", typeof(double)); }
            set { interceptor.Invoke("setShadowBlur$", "setShadowBlur(qreal)", typeof(void), typeof(double), value); }
        }
        [Q_PROPERTY("QSize", "maximumSize")]
        public QSize MaximumSize {
            get { return (QSize) interceptor.Invoke("maximumSize", "maximumSize()", typeof(QSize)); }
            set { interceptor.Invoke("setMaximumSize#", "setMaximumSize(QSize)", typeof(void), typeof(QSize), value); }
        }
        /// <remarks>
        ///  Constructs a new KFileItemDelegate.
        /// <param> name="parent" The parent object for the delegate.
        ///          </param></remarks>        <short>    Constructs a new KFileItemDelegate.</short>
        public KFileItemDelegate(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KFileItemDelegate#", "KFileItemDelegate(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public KFileItemDelegate() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KFileItemDelegate", "KFileItemDelegate()", typeof(void));
        }
        /// <remarks>
        ///  Returns the nominal size for the item referred to by <code>index</code>, given the
        ///  provided options.
        ///  If the model provides a valid Qt.FontRole and/or Qt.AlignmentRole for the item,
        ///  those will be used instead of the ones specified in the style options.
        ///  This function is reimplemented from <see cref="QAbstractItemDelegate"></see>.
        /// <param> name="option" The style options that should be used when painting the item.
        /// </param><param> name="index" The index to the item for which to return the size hint.
        ///          </param></remarks>        <short>    Returns the nominal size for the item referred to by <code>index</code>, given the  provided options.</short>
        [SmokeMethod("sizeHint(const QStyleOptionViewItem&, const QModelIndex&) const")]
        public override QSize SizeHint(QStyleOptionViewItem option, QModelIndex index) {
            return (QSize) interceptor.Invoke("sizeHint##", "sizeHint(const QStyleOptionViewItem&, const QModelIndex&) const", typeof(QSize), typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
        }
        /// <remarks>
        ///  Paints the item indicated by <code>index</code>, using <code>painter.</code>
        ///  The item will be drawn in the rectangle specified by option.rect.
        ///  The correct size for that rectangle can be obtained by calling
        ///  <see cref="#sizeHint"></see>.
        ///  This function will use the following data values if the model provides
        ///  them for the item, in place of the values in <code>option</code>:
        /// 
        /// <li>
        /// Qt.FontRole        The font that should be used for the display role.
        /// </li>
        /// 
        /// <li>
        /// Qt.AlignmentRole   The alignment of the display role.
        /// </li>
        /// 
        /// <li>
        /// Qt.ForegroundRole  The text color for the display role.
        /// </li>
        /// 
        /// <li>
        /// Qt.BackgroundRole  The background color for the item.
        /// </li>
        ///  This function is reimplemented from <see cref="QAbstractItemDelegate"></see>.
        /// <param> name="painter" The painter with which to draw the item.
        /// </param><param> name="option" The style options that should be used when painting the item.
        /// </param><param> name="index" The index to the item that should be painted.
        ///          </param></remarks>        <short>    Paints the item indicated by <code>index</code>, using <code>painter.</code></short>
        [SmokeMethod("paint(QPainter*, const QStyleOptionViewItem&, const QModelIndex&) const")]
        public override void Paint(QPainter painter, QStyleOptionViewItem option, QModelIndex index) {
            interceptor.Invoke("paint###", "paint(QPainter*, const QStyleOptionViewItem&, const QModelIndex&) const", typeof(void), typeof(QPainter), painter, typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
        }
        /// <remarks>
        ///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
        ///          </remarks>        <short>    Reimplemented from @ref QAbstractItemDelegate.</short>
        [SmokeMethod("createEditor(QWidget*, const QStyleOptionViewItem&, const QModelIndex&) const")]
        public override QWidget CreateEditor(QWidget parent, QStyleOptionViewItem option, QModelIndex index) {
            return (QWidget) interceptor.Invoke("createEditor###", "createEditor(QWidget*, const QStyleOptionViewItem&, const QModelIndex&) const", typeof(QWidget), typeof(QWidget), parent, typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
        }
        /// <remarks>
        ///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
        ///          </remarks>        <short>    Reimplemented from @ref QAbstractItemDelegate.</short>
        [SmokeMethod("editorEvent(QEvent*, QAbstractItemModel*, const QStyleOptionViewItem&, const QModelIndex&)")]
        public override bool EditorEvent(QEvent arg1, QAbstractItemModel model, QStyleOptionViewItem option, QModelIndex index) {
            return (bool) interceptor.Invoke("editorEvent####", "editorEvent(QEvent*, QAbstractItemModel*, const QStyleOptionViewItem&, const QModelIndex&)", typeof(bool), typeof(QEvent), arg1, typeof(QAbstractItemModel), model, typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
        }
        /// <remarks>
        ///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
        ///          </remarks>        <short>    Reimplemented from @ref QAbstractItemDelegate.</short>
        [SmokeMethod("setEditorData(QWidget*, const QModelIndex&) const")]
        public override void SetEditorData(QWidget editor, QModelIndex index) {
            interceptor.Invoke("setEditorData##", "setEditorData(QWidget*, const QModelIndex&) const", typeof(void), typeof(QWidget), editor, typeof(QModelIndex), index);
        }
        /// <remarks>
        ///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
        ///          </remarks>        <short>    Reimplemented from @ref QAbstractItemDelegate.</short>
        [SmokeMethod("setModelData(QWidget*, QAbstractItemModel*, const QModelIndex&) const")]
        public override void SetModelData(QWidget editor, QAbstractItemModel model, QModelIndex index) {
            interceptor.Invoke("setModelData###", "setModelData(QWidget*, QAbstractItemModel*, const QModelIndex&) const", typeof(void), typeof(QWidget), editor, typeof(QAbstractItemModel), model, typeof(QModelIndex), index);
        }
        /// <remarks>
        ///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
        ///          </remarks>        <short>    Reimplemented from @ref QAbstractItemDelegate.</short>
        [SmokeMethod("updateEditorGeometry(QWidget*, const QStyleOptionViewItem&, const QModelIndex&) const")]
        public override void UpdateEditorGeometry(QWidget editor, QStyleOptionViewItem option, QModelIndex index) {
            interceptor.Invoke("updateEditorGeometry###", "updateEditorGeometry(QWidget*, const QStyleOptionViewItem&, const QModelIndex&) const", typeof(void), typeof(QWidget), editor, typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
        }
        /// <remarks>
        ///  Sets the list of information lines that are shown below the icon label in list views.
        ///  You will typically construct the list like this:
        ///  @code
        ///  KFileItemDelegate.InformationList list;
        ///  list << KFileItemDelegate.FriendlyMimeType << KFileItemDelegate.Size;
        ///  delegate.SetShowInformation(list);
        ///  @endcode
        ///  The information lines will be displayed in the list order.
        ///  The delegate will first draw the item label, and then as many information
        ///  lines as will fit in the available space.
        /// <param> name="list" A list of information items that should be shown
        ///          </param></remarks>        <short>    Sets the list of information lines that are shown below the icon label in list views.</short>
        public void SetShowInformation(List<KFileItemDelegate.Information> list) {
            interceptor.Invoke("setShowInformation?", "setShowInformation(const QList<KFileItemDelegate::Information>&)", typeof(void), typeof(List<KFileItemDelegate.Information>), list);
        }
        /// <remarks>
        ///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
        ///          </remarks>        <short>    Reimplemented from @ref QAbstractItemDelegate.</short>
        [SmokeMethod("eventFilter(QObject*, QEvent*)")]
        public override bool EventFilter(QObject arg1, QEvent arg2) {
            return (bool) interceptor.Invoke("eventFilter##", "eventFilter(QObject*, QEvent*)", typeof(bool), typeof(QObject), arg1, typeof(QEvent), arg2);
        }
        /// <remarks>
        ///  Reimplemented from <see cref="QAbstractItemDelegate"></see>.
        ///          </remarks>        <short>    Reimplemented from @ref QAbstractItemDelegate.</short>
        [Q_SLOT("bool helpEvent(QHelpEvent*, QAbstractItemView*, QStyleOptionViewItem, QModelIndex)")]
        public new bool HelpEvent(QHelpEvent arg1, QAbstractItemView view, QStyleOptionViewItem option, QModelIndex index) {
            return (bool) interceptor.Invoke("helpEvent####", "helpEvent(QHelpEvent*, QAbstractItemView*, const QStyleOptionViewItem&, const QModelIndex&)", typeof(bool), typeof(QHelpEvent), arg1, typeof(QAbstractItemView), view, typeof(QStyleOptionViewItem), option, typeof(QModelIndex), index);
        }
        ~KFileItemDelegate() {
            interceptor.Invoke("~KFileItemDelegate", "~KFileItemDelegate()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KFileItemDelegate", "~KFileItemDelegate()", typeof(void));
        }
        protected new IKFileItemDelegateSignals Emit {
            get { return (IKFileItemDelegateSignals) Q_EMIT; }
        }
    }

    public interface IKFileItemDelegateSignals : IQAbstractItemDelegateSignals {
    }
}
