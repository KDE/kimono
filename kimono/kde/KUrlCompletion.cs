//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    using System.Text;
    using System.Collections.Generic;
    /// <remarks>
    ///  This class does completion of URLs including user directories (~user)
    ///  and environment variables.  Remote URLs are passed to KIO.
    /// </remarks>        <author> David Smith <dsmith@algonet.se>
    ///  </author>
    ///         <short> Completion of a single URL.</short>
    [SmokeClass("KUrlCompletion")]
    public class KUrlCompletion : KCompletion, IDisposable {
        protected KUrlCompletion(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KUrlCompletion), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KUrlCompletion() {
            staticInterceptor = new SmokeInvocation(typeof(KUrlCompletion), null);
        }
        /// <remarks>
        ///  Determines how completion is done.
        /// 
        /// <li>
        /// ExeCompletion - executables in $PATH or with full path.
        /// </li>
        /// 
        /// <li>
        /// FileCompletion - all files with full path or in dir(), URLs
        ///  are listed using KIO.
        /// </li>
        /// 
        /// <li>
        /// DirCompletion - Same as FileCompletion but only returns directories.
        /// 	 
        /// </li></remarks>        <short>    Determines how completion is done.</short>
        public enum Mode {
            ExeCompletion = 1,
            FileCompletion = 2,
            DirCompletion = 3,
        }
        /// <remarks>
        ///  Constructs a KUrlCompletion object in FileCompletion mode.
        /// 	 </remarks>        <short>    Constructs a KUrlCompletion object in FileCompletion mode.</short>
        public KUrlCompletion() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KUrlCompletion", "KUrlCompletion()", typeof(void));
        }
        /// <remarks>
        ///  This overloaded constructor allows you to set the Mode to ExeCompletion
        ///  or FileCompletion without using setMode. Default is FileCompletion.
        /// 	 </remarks>        <short>    This overloaded constructor allows you to set the Mode to ExeCompletion  or FileCompletion without using setMode.</short>
        public KUrlCompletion(KUrlCompletion.Mode arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KUrlCompletion$", "KUrlCompletion(KUrlCompletion::Mode)", typeof(void), typeof(KUrlCompletion.Mode), arg1);
        }
        /// <remarks>
        ///  Finds completions to the given text.
        ///  Remote URLs are listed with KIO. For performance reasons, local files
        ///  are listed with KIO only if KURLCOMPLETION_LOCAL_KIO is set.
        ///  The completion is done asyncronously if KIO is used.
        ///  Returns the first match for user, environment, and local dir completion
        ///  and string() for asynchronous completion (KIO or threaded).
        /// <param> name="text" the text to complete
        /// </param></remarks>        <return> the first match, or string() if not found
        /// 	 </return>
        ///         <short>    Finds completions to the given text.</short>
        [SmokeMethod("makeCompletion(const QString&)")]
        public override string MakeCompletion(string text) {
            return (string) interceptor.Invoke("makeCompletion$", "makeCompletion(const QString&)", typeof(string), typeof(string), text);
        }
        /// <remarks>
        ///  Sets the current directory (used as base for completion).
        ///  Default = $HOME.
        /// <param> name="dir" the current directory, either as a path or URL
        /// 	 </param></remarks>        <short>    Sets the current directory (used as base for completion).</short>
        [SmokeMethod("setDir(const QString&)")]
        public virtual void SetDir(string dir) {
            interceptor.Invoke("setDir$", "setDir(const QString&)", typeof(void), typeof(string), dir);
        }
        /// <remarks>
        ///  Returns the current directory, as it was given in setDir
        /// </remarks>        <return> the current directory (path or URL)
        /// 	 </return>
        ///         <short>    Returns the current directory, as it was given in setDir </short>
        [SmokeMethod("dir() const")]
        public virtual string Dir() {
            return (string) interceptor.Invoke("dir", "dir() const", typeof(string));
        }
        /// <remarks>
        ///  Check whether asynchronous completion is in progress.
        /// </remarks>        <return> true if asynchronous completion is in progress
        /// 	 </return>
        ///         <short>    Check whether asynchronous completion is in progress.</short>
        [SmokeMethod("isRunning() const")]
        public virtual bool IsRunning() {
            return (bool) interceptor.Invoke("isRunning", "isRunning() const", typeof(bool));
        }
        /// <remarks>
        ///  Stops asynchronous completion.
        /// 	 </remarks>        <short>    Stops asynchronous completion.</short>
        [SmokeMethod("stop()")]
        public virtual void Stop() {
            interceptor.Invoke("stop", "stop()", typeof(void));
        }
        /// <remarks>
        ///  Returns the completion mode: exe or file completion (default FileCompletion).
        /// </remarks>        <return> the completion mode
        /// 	 </return>
        ///         <short>    Returns the completion mode: exe or file completion (default FileCompletion).</short>
        [SmokeMethod("mode() const")]
        public virtual KUrlCompletion.Mode mode() {
            return (KUrlCompletion.Mode) interceptor.Invoke("mode", "mode() const", typeof(KUrlCompletion.Mode));
        }
        /// <remarks>
        ///  Changes the completion mode: exe or file completion
        /// <param> name="mode" the new completion mode
        /// 	 </param></remarks>        <short>    Changes the completion mode: exe or file completion </short>
        [SmokeMethod("setMode(KUrlCompletion::Mode)")]
        public virtual void SetMode(KUrlCompletion.Mode mode) {
            interceptor.Invoke("setMode$", "setMode(KUrlCompletion::Mode)", typeof(void), typeof(KUrlCompletion.Mode), mode);
        }
        /// <remarks>
        ///  Checks whether environment variables are completed and
        ///  whether they are replaced internally while finding completions.
        ///  Default is enabled.
        /// </remarks>        <return> true if environment vvariables will be replaced
        /// 	 </return>
        ///         <short>    Checks whether environment variables are completed and  whether they are replaced internally while finding completions.</short>
        [SmokeMethod("replaceEnv() const")]
        public virtual bool ReplaceEnv() {
            return (bool) interceptor.Invoke("replaceEnv", "replaceEnv() const", typeof(bool));
        }
        /// <remarks>
        ///  Enables/disables completion and replacement (internally) of
        ///  environment variables in URLs. Default is enabled.
        /// <param> name="replace" true to replace environment variables
        /// 	 </param></remarks>        <short>    Enables/disables completion and replacement (internally) of  environment variables in URLs.</short>
        [SmokeMethod("setReplaceEnv(bool)")]
        public virtual void SetReplaceEnv(bool replace) {
            interceptor.Invoke("setReplaceEnv$", "setReplaceEnv(bool)", typeof(void), typeof(bool), replace);
        }
        /// <remarks>
        ///  Returns whether ~username is completed and whether ~username
        ///  is replaced internally with the user's home directory while
        ///  finding completions. Default is enabled.
        /// </remarks>        <return> true to replace tilde with the home directory
        /// 	 </return>
        ///         <short>    Returns whether ~username is completed and whether ~username  is replaced internally with the user's home directory while  finding completions.</short>
        [SmokeMethod("replaceHome() const")]
        public virtual bool ReplaceHome() {
            return (bool) interceptor.Invoke("replaceHome", "replaceHome() const", typeof(bool));
        }
        /// <remarks>
        ///  Enables/disables completion of ~username and replacement
        ///  (internally) of ~username with the user's home directory.
        ///  Default is enabled.
        /// <param> name="replace" true to replace tilde with the home directory
        /// 	 </param></remarks>        <short>    Enables/disables completion of ~username and replacement  (internally) of ~username with the user's home directory.</short>
        [SmokeMethod("setReplaceHome(bool)")]
        public virtual void SetReplaceHome(bool replace) {
            interceptor.Invoke("setReplaceHome$", "setReplaceHome(bool)", typeof(void), typeof(bool), replace);
        }
        /// <remarks>
        ///  Replaces username and/or environment variables, depending on the
        ///  current settings and returns the filtered url. Only works with
        ///  local files, i.e. returns back the original string for non-local
        ///  urls.
        /// <param> name="text" the text to process
        /// </param></remarks>        <return> the path or URL resulting from this operation. If you
        ///  want to convert it to a KUrl, use KUrl.FromPathOrUrl.
        /// 	 </return>
        ///         <short>    Replaces username and/or environment variables, depending on the  current settings and returns the filtered url.</short>
        public string ReplacedPath(string text) {
            return (string) interceptor.Invoke("replacedPath$", "replacedPath(const QString&) const", typeof(string), typeof(string), text);
        }
        [SmokeMethod("postProcessMatch(QString*) const")]
        protected override void PostProcessMatch(StringBuilder match) {
            interceptor.Invoke("postProcessMatch$", "postProcessMatch(QString*) const", typeof(void), typeof(StringBuilder), match);
        }
        [SmokeMethod("postProcessMatches(QStringList*) const")]
        protected override void PostProcessMatches(List<string> matches) {
            interceptor.Invoke("postProcessMatches?", "postProcessMatches(QStringList*) const", typeof(void), typeof(List<string>), matches);
        }
        [SmokeMethod("customEvent(QEvent*)")]
        protected override void CustomEvent(QEvent e) {
            interceptor.Invoke("customEvent#", "customEvent(QEvent*)", typeof(void), typeof(QEvent), e);
        }
        ~KUrlCompletion() {
            interceptor.Invoke("~KUrlCompletion", "~KUrlCompletion()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~KUrlCompletion", "~KUrlCompletion()", typeof(void));
        }
        /// <remarks>
        /// 	</remarks>        <short>   </short>
        public static string ReplacedPath(string text, bool replaceHome, bool replaceEnv) {
            return (string) staticInterceptor.Invoke("replacedPath$$$", "replacedPath(const QString&, bool, bool)", typeof(string), typeof(string), text, typeof(bool), replaceHome, typeof(bool), replaceEnv);
        }
        public static string ReplacedPath(string text, bool replaceHome) {
            return (string) staticInterceptor.Invoke("replacedPath$$", "replacedPath(const QString&, bool)", typeof(string), typeof(string), text, typeof(bool), replaceHome);
        }
        protected new IKUrlCompletionSignals Emit {
            get { return (IKUrlCompletionSignals) Q_EMIT; }
        }
    }

    public interface IKUrlCompletionSignals : IKCompletionSignals {
    }
}
