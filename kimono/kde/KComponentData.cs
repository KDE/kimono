//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
    using System;
    using Qyoto;
    /// <remarks>
    ///  This class holds a KAboutData object or only a component name, a KStandardDirs object and a
    ///  KSharedConfig object. Those objects normally are different per component but the same per
    ///  instance of one component.
    ///  The application component data can always be accessed using KGlobal.MainComponent() (or the
    ///  convenience function KGlobal.Dirs() and KGlobal.Config()) while the
    ///  component data of the currently active component (mainly used for KParts) can be accessed using
    ///  KGlobal.ActiveComponent().
    /// </remarks>        <author> Matthias Kretz <kretz@kde.org>
    ///  </author>
    ///         <short> Per component data. </short>
    [SmokeClass("KComponentData")]
    public class KComponentData : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected KComponentData(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(KComponentData), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static KComponentData() {
            staticInterceptor = new SmokeInvocation(typeof(KComponentData), null);
        }
        public enum MainComponentRegistration {
            RegisterAsMainComponent = 0,
            SkipMainComponentRegistration = 1,
        }
        /// <remarks>
        ///  Creates an invalid KComponentData object.
        /// </remarks>        <short>    Creates an invalid KComponentData object.</short>
        ///         <see> isValid</see>
        public KComponentData() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KComponentData", "KComponentData()", typeof(void));
        }
        /// <remarks>
        ///  Copy constructor.
        ///  It does not copy the data. The data is shared between the old and new objects.
        ///      </remarks>        <short>    Copy constructor.</short>
        public KComponentData(KComponentData arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KComponentData#", "KComponentData(const KComponentData&)", typeof(void), typeof(KComponentData), arg1);
        }
        /// <remarks>
        ///  Returns whether two KComponentData objects reference the same data.
        ///      </remarks>        <short>    Returns whether two KComponentData objects reference the same data.</short>
        public override bool Equals(object o) {
            if (!(o is KComponentData)) { return false; }
            return this == (KComponentData) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        /// <remarks>
        ///  Constructor.
        /// <param> name="componentName" the name of the component.
        /// </param><param> name="catalogName" the name of the translation catalog;
        ///                     if left empty <code>componentName</code> is used
        /// </param><param> name="registerAsMain" whether to register the component as the main component
        ///                        of the application. This has no effect, if the application
        ///                        already has a main component.
        /// </param></remarks>        <short>    Constructor.</short>
        ///         <see> KGlobal.MainComponent</see>
        public KComponentData(QByteArray componentName, QByteArray catalogName, KComponentData.MainComponentRegistration registerAsMain) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KComponentData##$", "KComponentData(const QByteArray&, const QByteArray&, KComponentData::MainComponentRegistration)", typeof(void), typeof(QByteArray), componentName, typeof(QByteArray), catalogName, typeof(KComponentData.MainComponentRegistration), registerAsMain);
        }
        public KComponentData(QByteArray componentName, QByteArray catalogName) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KComponentData##", "KComponentData(const QByteArray&, const QByteArray&)", typeof(void), typeof(QByteArray), componentName, typeof(QByteArray), catalogName);
        }
        public KComponentData(QByteArray componentName) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KComponentData#", "KComponentData(const QByteArray&)", typeof(void), typeof(QByteArray), componentName);
        }
        /// <remarks>
        ///  Constructor.
        ///  A copy of the aboutData object is made.
        /// <param> name="aboutData" data about this component
        /// </param><param> name="registerAsMain" whether to register the component as the main component
        ///                        of the application. This has no effect, if the application
        ///                        already has a main component.
        /// </param></remarks>        <short>    Constructor.</short>
        ///         <see> KGlobal.MainComponent</see>
        ///         <see> KAboutData</see>
        public KComponentData(KAboutData aboutData, KComponentData.MainComponentRegistration registerAsMain) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KComponentData#$", "KComponentData(const KAboutData&, KComponentData::MainComponentRegistration)", typeof(void), typeof(KAboutData), aboutData, typeof(KComponentData.MainComponentRegistration), registerAsMain);
        }
        public KComponentData(KAboutData aboutData) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("KComponentData#", "KComponentData(const KAboutData&)", typeof(void), typeof(KAboutData), aboutData);
        }
        /// <remarks>
        ///  Returns whether this is a valid object.
        ///  Don't call any functions on invalid objects, that will crash. Assignment (and of course
        ///  destruction) is the only valid operation you may do.
        ///      </remarks>        <short>    Returns whether this is a valid object.</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        ///  Returns the application standard dirs object.
        /// </remarks>        <return> The KStandardDirs of the application.
        ///      </return>
        ///         <short>    Returns the application standard dirs object.</short>
        public KStandardDirs Dirs() {
            return (KStandardDirs) interceptor.Invoke("dirs", "dirs() const", typeof(KStandardDirs));
        }
        /// <remarks>
        ///  Returns the general config object ("appnamerc").
        /// </remarks>        <return> the KConfig object for the component.
        ///      </return>
        ///         <short>    Returns the general config object ("appnamerc").</short>
        public KSharedConfig Config() {
            return (KSharedConfig) interceptor.Invoke("config", "config() const", typeof(KSharedConfig));
        }
        /// <remarks>
        ///  Returns the about data of this component.
        /// </remarks>        <return> The about data of the component. If none has been set in the
        ///          constructor but a component name was set, a default constructed
        ///          KAboutData object is returned.
        ///      </return>
        ///         <short>    Returns the about data of this component.</short>
        public KAboutData AboutData() {
            return (KAboutData) interceptor.Invoke("aboutData", "aboutData() const", typeof(KAboutData));
        }
        /// <remarks>
        ///  Returns the name of the component.
        /// </remarks>        <return> The component name.
        ///      </return>
        ///         <short>    Returns the name of the component.</short>
        public string ComponentName() {
            return (string) interceptor.Invoke("componentName", "componentName() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the name of the translation catalog.
        /// </remarks>        <return> The catalog name.
        ///      </return>
        ///         <short>    Returns the name of the translation catalog.</short>
        public string CatalogName() {
            return (string) interceptor.Invoke("catalogName", "catalogName() const", typeof(string));
        }
        /// <remarks>
        ///  Set name of default config file.
        /// <param> name="name" the name of the default config file
        ///      </param></remarks>        <short>    Set name of default config file.</short>
        protected void SetConfigName(string name) {
            interceptor.Invoke("setConfigName$", "setConfigName(const QString&)", typeof(void), typeof(string), name);
        }
        ~KComponentData() {
            interceptor.Invoke("~KComponentData", "~KComponentData()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~KComponentData", "~KComponentData()", typeof(void));
        }
        public static bool operator==(KComponentData lhs, KComponentData arg1) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KComponentData&) const", typeof(bool), typeof(KComponentData), lhs, typeof(KComponentData), arg1);
        }
        public static bool operator!=(KComponentData lhs, KComponentData arg1) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KComponentData&) const", typeof(bool), typeof(KComponentData), lhs, typeof(KComponentData), arg1);
        }
    }
}
