//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
    using System;
    using System.Collections.Generic;
    [SmokeClass("QSslCertificate")]
    public class QSslCertificate : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected QSslCertificate(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(QSslCertificate), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static QSslCertificate() {
            staticInterceptor = new SmokeInvocation(typeof(QSslCertificate), null);
        }
        public enum SubjectInfo {
            Organization = 0,
            CommonName = 1,
            LocalityName = 2,
            OrganizationalUnitName = 3,
            CountryName = 4,
            StateOrProvinceName = 5,
        }
        // QMultiMap<QSsl::AlternateNameEntryType,QString> alternateSubjectNames(); >>>> NOT CONVERTED
        public QSslCertificate(QIODevice device, QSsl.EncodingFormat format) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QSslCertificate#$", "QSslCertificate(QIODevice*, QSsl::EncodingFormat)", typeof(void), typeof(QIODevice), device, typeof(QSsl.EncodingFormat), format);
        }
        public QSslCertificate(QIODevice device) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QSslCertificate#", "QSslCertificate(QIODevice*)", typeof(void), typeof(QIODevice), device);
        }
        public QSslCertificate(QByteArray encoded, QSsl.EncodingFormat format) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QSslCertificate#$", "QSslCertificate(const QByteArray&, QSsl::EncodingFormat)", typeof(void), typeof(QByteArray), encoded, typeof(QSsl.EncodingFormat), format);
        }
        public QSslCertificate(QByteArray encoded) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QSslCertificate#", "QSslCertificate(const QByteArray&)", typeof(void), typeof(QByteArray), encoded);
        }
        public QSslCertificate() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QSslCertificate", "QSslCertificate()", typeof(void));
        }
        public QSslCertificate(QSslCertificate other) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QSslCertificate#", "QSslCertificate(const QSslCertificate&)", typeof(void), typeof(QSslCertificate), other);
        }
        public override bool Equals(object o) {
            if (!(o is QSslCertificate)) { return false; }
            return this == (QSslCertificate) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        public bool IsNull() {
            return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
        }
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        public void Clear() {
            interceptor.Invoke("clear", "clear()", typeof(void));
        }
        public QByteArray Version() {
            return (QByteArray) interceptor.Invoke("version", "version() const", typeof(QByteArray));
        }
        public QByteArray SerialNumber() {
            return (QByteArray) interceptor.Invoke("serialNumber", "serialNumber() const", typeof(QByteArray));
        }
        public QByteArray Digest(QCryptographicHash.Algorithm algorithm) {
            return (QByteArray) interceptor.Invoke("digest$", "digest(QCryptographicHash::Algorithm) const", typeof(QByteArray), typeof(QCryptographicHash.Algorithm), algorithm);
        }
        public QByteArray Digest() {
            return (QByteArray) interceptor.Invoke("digest", "digest() const", typeof(QByteArray));
        }
        public string IssuerInfo(QSslCertificate.SubjectInfo info) {
            return (string) interceptor.Invoke("issuerInfo$", "issuerInfo(QSslCertificate::SubjectInfo) const", typeof(string), typeof(QSslCertificate.SubjectInfo), info);
        }
        public string IssuerInfo(QByteArray tag) {
            return (string) interceptor.Invoke("issuerInfo#", "issuerInfo(const QByteArray&) const", typeof(string), typeof(QByteArray), tag);
        }
        public string subjectInfo(QSslCertificate.SubjectInfo info) {
            return (string) interceptor.Invoke("subjectInfo$", "subjectInfo(QSslCertificate::SubjectInfo) const", typeof(string), typeof(QSslCertificate.SubjectInfo), info);
        }
        public string subjectInfo(QByteArray tag) {
            return (string) interceptor.Invoke("subjectInfo#", "subjectInfo(const QByteArray&) const", typeof(string), typeof(QByteArray), tag);
        }
        public QDateTime EffectiveDate() {
            return (QDateTime) interceptor.Invoke("effectiveDate", "effectiveDate() const", typeof(QDateTime));
        }
        public QDateTime ExpiryDate() {
            return (QDateTime) interceptor.Invoke("expiryDate", "expiryDate() const", typeof(QDateTime));
        }
        public QSslKey PublicKey() {
            return (QSslKey) interceptor.Invoke("publicKey", "publicKey() const", typeof(QSslKey));
        }
        public QByteArray ToPem() {
            return (QByteArray) interceptor.Invoke("toPem", "toPem() const", typeof(QByteArray));
        }
        public QByteArray ToDer() {
            return (QByteArray) interceptor.Invoke("toDer", "toDer() const", typeof(QByteArray));
        }
        ~QSslCertificate() {
            interceptor.Invoke("~QSslCertificate", "~QSslCertificate()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~QSslCertificate", "~QSslCertificate()", typeof(void));
        }
        public static bool operator==(QSslCertificate lhs, QSslCertificate other) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const QSslCertificate&) const", typeof(bool), typeof(QSslCertificate), lhs, typeof(QSslCertificate), other);
        }
        public static bool operator!=(QSslCertificate lhs, QSslCertificate other) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const QSslCertificate&) const", typeof(bool), typeof(QSslCertificate), lhs, typeof(QSslCertificate), other);
        }
        public static List<QSslCertificate> FromPath(string path, QSsl.EncodingFormat format, QRegExp.PatternSyntax syntax) {
            return (List<QSslCertificate>) staticInterceptor.Invoke("fromPath$$$", "fromPath(const QString&, QSsl::EncodingFormat, QRegExp::PatternSyntax)", typeof(List<QSslCertificate>), typeof(string), path, typeof(QSsl.EncodingFormat), format, typeof(QRegExp.PatternSyntax), syntax);
        }
        public static List<QSslCertificate> FromPath(string path, QSsl.EncodingFormat format) {
            return (List<QSslCertificate>) staticInterceptor.Invoke("fromPath$$", "fromPath(const QString&, QSsl::EncodingFormat)", typeof(List<QSslCertificate>), typeof(string), path, typeof(QSsl.EncodingFormat), format);
        }
        public static List<QSslCertificate> FromPath(string path) {
            return (List<QSslCertificate>) staticInterceptor.Invoke("fromPath$", "fromPath(const QString&)", typeof(List<QSslCertificate>), typeof(string), path);
        }
        public static List<QSslCertificate> FromDevice(QIODevice device, QSsl.EncodingFormat format) {
            return (List<QSslCertificate>) staticInterceptor.Invoke("fromDevice#$", "fromDevice(QIODevice*, QSsl::EncodingFormat)", typeof(List<QSslCertificate>), typeof(QIODevice), device, typeof(QSsl.EncodingFormat), format);
        }
        public static List<QSslCertificate> FromDevice(QIODevice device) {
            return (List<QSslCertificate>) staticInterceptor.Invoke("fromDevice#", "fromDevice(QIODevice*)", typeof(List<QSslCertificate>), typeof(QIODevice), device);
        }
        public static List<QSslCertificate> FromData(QByteArray data, QSsl.EncodingFormat format) {
            return (List<QSslCertificate>) staticInterceptor.Invoke("fromData#$", "fromData(const QByteArray&, QSsl::EncodingFormat)", typeof(List<QSslCertificate>), typeof(QByteArray), data, typeof(QSsl.EncodingFormat), format);
        }
        public static List<QSslCertificate> FromData(QByteArray data) {
            return (List<QSslCertificate>) staticInterceptor.Invoke("fromData#", "fromData(const QByteArray&)", typeof(List<QSslCertificate>), typeof(QByteArray), data);
        }
    }
}
