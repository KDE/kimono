//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
    using System;
    [SmokeClass("QLineF")]
    public partial class QLineF : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected QLineF(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(QLineF), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static QLineF() {
            staticInterceptor = new SmokeInvocation(typeof(QLineF), null);
        }
        public enum IntersectType {
            NoIntersection = 0,
            BoundedIntersection = 1,
            UnboundedIntersection = 2,
        }
        public QLineF() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QLineF", "QLineF()", typeof(void));
        }
        public QLineF(QPointF pt1, QPointF pt2) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QLineF##", "QLineF(const QPointF&, const QPointF&)", typeof(void), typeof(QPointF), pt1, typeof(QPointF), pt2);
        }
        public QLineF(double x1, double y1, double x2, double y2) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QLineF$$$$", "QLineF(qreal, qreal, qreal, qreal)", typeof(void), typeof(double), x1, typeof(double), y1, typeof(double), x2, typeof(double), y2);
        }
        public QLineF(QLine line) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QLineF#", "QLineF(const QLine&)", typeof(void), typeof(QLine), line);
        }
        public bool IsNull() {
            return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
        }
        public QPointF P1() {
            return (QPointF) interceptor.Invoke("p1", "p1() const", typeof(QPointF));
        }
        public QPointF P2() {
            return (QPointF) interceptor.Invoke("p2", "p2() const", typeof(QPointF));
        }
        public double X1() {
            return (double) interceptor.Invoke("x1", "x1() const", typeof(double));
        }
        public double Y1() {
            return (double) interceptor.Invoke("y1", "y1() const", typeof(double));
        }
        public double X2() {
            return (double) interceptor.Invoke("x2", "x2() const", typeof(double));
        }
        public double Y2() {
            return (double) interceptor.Invoke("y2", "y2() const", typeof(double));
        }
        public double Dx() {
            return (double) interceptor.Invoke("dx", "dx() const", typeof(double));
        }
        public double Dy() {
            return (double) interceptor.Invoke("dy", "dy() const", typeof(double));
        }
        public double Length() {
            return (double) interceptor.Invoke("length", "length() const", typeof(double));
        }
        public void SetLength(double len) {
            interceptor.Invoke("setLength$", "setLength(qreal)", typeof(void), typeof(double), len);
        }
        public double Angle() {
            return (double) interceptor.Invoke("angle", "angle() const", typeof(double));
        }
        public void SetAngle(double angle) {
            interceptor.Invoke("setAngle$", "setAngle(qreal)", typeof(void), typeof(double), angle);
        }
        public double AngleTo(QLineF l) {
            return (double) interceptor.Invoke("angleTo#", "angleTo(const QLineF&) const", typeof(double), typeof(QLineF), l);
        }
        public QLineF UnitVector() {
            return (QLineF) interceptor.Invoke("unitVector", "unitVector() const", typeof(QLineF));
        }
        public QLineF NormalVector() {
            return (QLineF) interceptor.Invoke("normalVector", "normalVector() const", typeof(QLineF));
        }
        public QLineF.IntersectType Intersect(QLineF l, QPointF intersectionPoint) {
            return (QLineF.IntersectType) interceptor.Invoke("intersect##", "intersect(const QLineF&, QPointF*) const", typeof(QLineF.IntersectType), typeof(QLineF), l, typeof(QPointF), intersectionPoint);
        }
        public double Angle(QLineF l) {
            return (double) interceptor.Invoke("angle#", "angle(const QLineF&) const", typeof(double), typeof(QLineF), l);
        }
        public QPointF PointAt(double t) {
            return (QPointF) interceptor.Invoke("pointAt$", "pointAt(qreal) const", typeof(QPointF), typeof(double), t);
        }
        public void Translate(QPointF p) {
            interceptor.Invoke("translate#", "translate(const QPointF&)", typeof(void), typeof(QPointF), p);
        }
        public void Translate(double dx, double dy) {
            interceptor.Invoke("translate$$", "translate(qreal, qreal)", typeof(void), typeof(double), dx, typeof(double), dy);
        }
        public QLineF Translated(QPointF p) {
            return (QLineF) interceptor.Invoke("translated#", "translated(const QPointF&) const", typeof(QLineF), typeof(QPointF), p);
        }
        public QLineF Translated(double dx, double dy) {
            return (QLineF) interceptor.Invoke("translated$$", "translated(qreal, qreal) const", typeof(QLineF), typeof(double), dx, typeof(double), dy);
        }
        public void SetP1(QPointF p1) {
            interceptor.Invoke("setP1#", "setP1(const QPointF&)", typeof(void), typeof(QPointF), p1);
        }
        public void SetP2(QPointF p2) {
            interceptor.Invoke("setP2#", "setP2(const QPointF&)", typeof(void), typeof(QPointF), p2);
        }
        public void SetPoints(QPointF p1, QPointF p2) {
            interceptor.Invoke("setPoints##", "setPoints(const QPointF&, const QPointF&)", typeof(void), typeof(QPointF), p1, typeof(QPointF), p2);
        }
        public void SetLine(double x1, double y1, double x2, double y2) {
            interceptor.Invoke("setLine$$$$", "setLine(qreal, qreal, qreal, qreal)", typeof(void), typeof(double), x1, typeof(double), y1, typeof(double), x2, typeof(double), y2);
        }
        public override bool Equals(object o) {
            if (!(o is QLineF)) { return false; }
            return this == (QLineF) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        public QLine ToLine() {
            return (QLine) interceptor.Invoke("toLine", "toLine() const", typeof(QLine));
        }
        ~QLineF() {
            interceptor.Invoke("~QLineF", "~QLineF()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~QLineF", "~QLineF()", typeof(void));
        }
        public static bool operator==(QLineF lhs, QLineF d) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const QLineF&) const", typeof(bool), typeof(QLineF), lhs, typeof(QLineF), d);
        }
        public static bool operator!=(QLineF lhs, QLineF d) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const QLineF&) const", typeof(bool), typeof(QLineF), lhs, typeof(QLineF), d);
        }
        public static QLineF FromPolar(double length, double angle) {
            return (QLineF) staticInterceptor.Invoke("fromPolar$$", "fromPolar(qreal, qreal)", typeof(QLineF), typeof(double), length, typeof(double), angle);
        }
        public static QLineF operator*(QLineF l, QTransform m) {
            return (QLineF) staticInterceptor.Invoke("operator*##", "operator*(const QLineF&, const QTransform&)", typeof(QLineF), typeof(QLineF), l, typeof(QTransform), m);
        }
        public static QLineF operator*(QLineF l, QMatrix m) {
            return (QLineF) staticInterceptor.Invoke("operator*##", "operator*(const QLineF&, const QMatrix&)", typeof(QLineF), typeof(QLineF), l, typeof(QMatrix), m);
        }
    }
}
