//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
    using System;
    [SmokeClass("QChar")]
    public class QChar : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected QChar(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(QChar), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static QChar() {
            staticInterceptor = new SmokeInvocation(typeof(QChar), null);
        }
        public enum SpecialCharacter {
            Null = 0x0000,
            Nbsp = 0x00a0,
            ReplacementCharacter = 0xfffd,
            ObjectReplacementCharacter = 0xfffc,
            ByteOrderMark = 0xfeff,
            ByteOrderSwapped = 0xfffe,
            ParagraphSeparator = 0x2029,
            LineSeparator = 0x2028,
        }
        public enum Category {
            NoCategory = 0,
            Mark_NonSpacing = 1,
            Mark_SpacingCombining = 2,
            Mark_Enclosing = 3,
            Number_DecimalDigit = 4,
            Number_Letter = 5,
            Number_Other = 6,
            Separator_Space = 7,
            Separator_Line = 8,
            Separator_Paragraph = 9,
            Other_Control = 10,
            Other_Format = 11,
            Other_Surrogate = 12,
            Other_PrivateUse = 13,
            Other_NotAssigned = 14,
            Letter_Uppercase = 15,
            Letter_Lowercase = 16,
            Letter_Titlecase = 17,
            Letter_Modifier = 18,
            Letter_Other = 19,
            Punctuation_Connector = 20,
            Punctuation_Dash = 21,
            Punctuation_Open = 22,
            Punctuation_Close = 23,
            Punctuation_InitialQuote = 24,
            Punctuation_FinalQuote = 25,
            Punctuation_Other = 26,
            Symbol_Math = 27,
            Symbol_Currency = 28,
            Symbol_Modifier = 29,
            Symbol_Other = 30,
            Punctuation_Dask = Punctuation_Dash,
        }
        public enum Direction {
            DirL = 0,
            DirR = 1,
            DirEN = 2,
            DirES = 3,
            DirET = 4,
            DirAN = 5,
            DirCS = 6,
            DirB = 7,
            DirS = 8,
            DirWS = 9,
            DirON = 10,
            DirLRE = 11,
            DirLRO = 12,
            DirAL = 13,
            DirRLE = 14,
            DirRLO = 15,
            DirPDF = 16,
            DirNSM = 17,
            DirBN = 18,
        }
        public enum Decomposition {
            NoDecomposition = 0,
            Canonical = 1,
            Font = 2,
            NoBreak = 3,
            Initial = 4,
            Medial = 5,
            Final = 6,
            Isolated = 7,
            Circle = 8,
            Super = 9,
            Sub = 10,
            Vertical = 11,
            Wide = 12,
            Narrow = 13,
            Small = 14,
            Square = 15,
            Compat = 16,
            Fraction = 17,
        }
        public enum Joining {
            OtherJoining = 0,
            Dual = 1,
            Right = 2,
            Center = 3,
        }
        public enum CombiningClass {
            Combining_BelowLeftAttached = 200,
            Combining_BelowAttached = 202,
            Combining_BelowRightAttached = 204,
            Combining_LeftAttached = 208,
            Combining_RightAttached = 210,
            Combining_AboveLeftAttached = 212,
            Combining_AboveAttached = 214,
            Combining_AboveRightAttached = 216,
            Combining_BelowLeft = 218,
            Combining_Below = 220,
            Combining_BelowRight = 222,
            Combining_Left = 224,
            Combining_Right = 226,
            Combining_AboveLeft = 228,
            Combining_Above = 230,
            Combining_AboveRight = 232,
            Combining_DoubleBelow = 233,
            Combining_DoubleAbove = 234,
            Combining_IotaSubscript = 240,
        }
        public enum UnicodeVersion {
            Unicode_Unassigned = 0,
            Unicode_1_1 = 1,
            Unicode_2_0 = 2,
            Unicode_2_1_2 = 3,
            Unicode_3_0 = 4,
            Unicode_3_1 = 5,
            Unicode_3_2 = 6,
            Unicode_4_0 = 7,
            Unicode_4_1 = 8,
            Unicode_5_0 = 9,
        }
        public QChar() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QChar", "QChar()", typeof(void));
        }
        public QChar(char c) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QChar$", "QChar(char)", typeof(void), typeof(char), c);
        }
        public QChar(ushort c) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QChar$", "QChar(uchar)", typeof(void), typeof(ushort), c);
        }
        public QChar(QLatin1Char ch) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QChar#", "QChar(QLatin1Char)", typeof(void), typeof(QLatin1Char), ch);
        }
        public QChar(ushort c, ushort r) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QChar$$", "QChar(uchar, uchar)", typeof(void), typeof(ushort), c, typeof(ushort), r);
        }
        public QChar(short rc) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QChar$", "QChar(short)", typeof(void), typeof(short), rc);
        }
        public QChar(uint rc) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QChar$", "QChar(uint)", typeof(void), typeof(uint), rc);
        }
        public QChar(int rc) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QChar$", "QChar(int)", typeof(void), typeof(int), rc);
        }
        public QChar(QChar.SpecialCharacter sc) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QChar$", "QChar(QChar::SpecialCharacter)", typeof(void), typeof(QChar.SpecialCharacter), sc);
        }
        public QChar.Category category() {
            return (QChar.Category) interceptor.Invoke("category", "category() const", typeof(QChar.Category));
        }
        public QChar.Direction direction() {
            return (QChar.Direction) interceptor.Invoke("direction", "direction() const", typeof(QChar.Direction));
        }
        public QChar.Joining joining() {
            return (QChar.Joining) interceptor.Invoke("joining", "joining() const", typeof(QChar.Joining));
        }
        public bool HasMirrored() {
            return (bool) interceptor.Invoke("hasMirrored", "hasMirrored() const", typeof(bool));
        }
        public ushort combiningClass() {
            return (ushort) interceptor.Invoke("combiningClass", "combiningClass() const", typeof(ushort));
        }
        public QChar MirroredChar() {
            return (QChar) interceptor.Invoke("mirroredChar", "mirroredChar() const", typeof(QChar));
        }
        public string decomposition() {
            return (string) interceptor.Invoke("decomposition", "decomposition() const", typeof(string));
        }
        public QChar.Decomposition DecompositionTag() {
            return (QChar.Decomposition) interceptor.Invoke("decompositionTag", "decompositionTag() const", typeof(QChar.Decomposition));
        }
        public int DigitValue() {
            return (int) interceptor.Invoke("digitValue", "digitValue() const", typeof(int));
        }
        public QChar ToLower() {
            return (QChar) interceptor.Invoke("toLower", "toLower() const", typeof(QChar));
        }
        public QChar ToUpper() {
            return (QChar) interceptor.Invoke("toUpper", "toUpper() const", typeof(QChar));
        }
        public QChar ToTitleCase() {
            return (QChar) interceptor.Invoke("toTitleCase", "toTitleCase() const", typeof(QChar));
        }
        public QChar ToCaseFolded() {
            return (QChar) interceptor.Invoke("toCaseFolded", "toCaseFolded() const", typeof(QChar));
        }
        public QChar.UnicodeVersion unicodeVersion() {
            return (QChar.UnicodeVersion) interceptor.Invoke("unicodeVersion", "unicodeVersion() const", typeof(QChar.UnicodeVersion));
        }
        public char ToAscii() {
            return (char) interceptor.Invoke("toAscii", "toAscii() const", typeof(char));
        }
        public char ToLatin1() {
            return (char) interceptor.Invoke("toLatin1", "toLatin1() const", typeof(char));
        }
        public short Unicode() {
            return (short) interceptor.Invoke("unicode", "unicode()", typeof(short));
        }
        public bool IsNull() {
            return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
        }
        public bool IsPrint() {
            return (bool) interceptor.Invoke("isPrint", "isPrint() const", typeof(bool));
        }
        public bool IsPunct() {
            return (bool) interceptor.Invoke("isPunct", "isPunct() const", typeof(bool));
        }
        public bool IsSpace() {
            return (bool) interceptor.Invoke("isSpace", "isSpace() const", typeof(bool));
        }
        public bool IsMark() {
            return (bool) interceptor.Invoke("isMark", "isMark() const", typeof(bool));
        }
        public bool IsLetter() {
            return (bool) interceptor.Invoke("isLetter", "isLetter() const", typeof(bool));
        }
        public bool IsNumber() {
            return (bool) interceptor.Invoke("isNumber", "isNumber() const", typeof(bool));
        }
        public bool IsLetterOrNumber() {
            return (bool) interceptor.Invoke("isLetterOrNumber", "isLetterOrNumber() const", typeof(bool));
        }
        public bool IsDigit() {
            return (bool) interceptor.Invoke("isDigit", "isDigit() const", typeof(bool));
        }
        public bool IsSymbol() {
            return (bool) interceptor.Invoke("isSymbol", "isSymbol() const", typeof(bool));
        }
        public bool IsLower() {
            return (bool) interceptor.Invoke("isLower", "isLower() const", typeof(bool));
        }
        public bool IsUpper() {
            return (bool) interceptor.Invoke("isUpper", "isUpper() const", typeof(bool));
        }
        public bool IsTitleCase() {
            return (bool) interceptor.Invoke("isTitleCase", "isTitleCase() const", typeof(bool));
        }
        public bool IsHighSurrogate() {
            return (bool) interceptor.Invoke("isHighSurrogate", "isHighSurrogate() const", typeof(bool));
        }
        public bool IsLowSurrogate() {
            return (bool) interceptor.Invoke("isLowSurrogate", "isLowSurrogate() const", typeof(bool));
        }
        public ushort Cell() {
            return (ushort) interceptor.Invoke("cell", "cell() const", typeof(ushort));
        }
        public ushort Row() {
            return (ushort) interceptor.Invoke("row", "row() const", typeof(ushort));
        }
        public void SetCell(ushort cell) {
            interceptor.Invoke("setCell$", "setCell(uchar)", typeof(void), typeof(ushort), cell);
        }
        public void SetRow(ushort row) {
            interceptor.Invoke("setRow$", "setRow(uchar)", typeof(void), typeof(ushort), row);
        }
        ~QChar() {
            interceptor.Invoke("~QChar", "~QChar()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~QChar", "~QChar()", typeof(void));
        }
        public override bool Equals(object o) {
            if (!(o is QChar)) { return false; }
            return this == (QChar) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        public static QChar FromAscii(char c) {
            return (QChar) staticInterceptor.Invoke("fromAscii$", "fromAscii(char)", typeof(QChar), typeof(char), c);
        }
        public static QChar FromLatin1(char c) {
            return (QChar) staticInterceptor.Invoke("fromLatin1$", "fromLatin1(char)", typeof(QChar), typeof(char), c);
        }
        public static uint SurrogateToUcs4(ushort high, ushort low) {
            return (uint) staticInterceptor.Invoke("surrogateToUcs4$$", "surrogateToUcs4(unsigned short, unsigned short)", typeof(uint), typeof(ushort), high, typeof(ushort), low);
        }
        public static uint SurrogateToUcs4(QChar high, QChar low) {
            return (uint) staticInterceptor.Invoke("surrogateToUcs4##", "surrogateToUcs4(QChar, QChar)", typeof(uint), typeof(QChar), high, typeof(QChar), low);
        }
        public static ushort HighSurrogate(uint ucs4) {
            return (ushort) staticInterceptor.Invoke("highSurrogate$", "highSurrogate(uint)", typeof(ushort), typeof(uint), ucs4);
        }
        public static ushort LowSurrogate(uint ucs4) {
            return (ushort) staticInterceptor.Invoke("lowSurrogate$", "lowSurrogate(uint)", typeof(ushort), typeof(uint), ucs4);
        }
        public static QChar.Category category(uint ucs4) {
            return (QChar.Category) staticInterceptor.Invoke("category$", "category(uint)", typeof(QChar.Category), typeof(uint), ucs4);
        }
        public static QChar.Category category(ushort ucs2) {
            return (QChar.Category) staticInterceptor.Invoke("category$", "category(unsigned short)", typeof(QChar.Category), typeof(ushort), ucs2);
        }
        public static QChar.Direction direction(uint ucs4) {
            return (QChar.Direction) staticInterceptor.Invoke("direction$", "direction(uint)", typeof(QChar.Direction), typeof(uint), ucs4);
        }
        public static QChar.Direction direction(ushort ucs2) {
            return (QChar.Direction) staticInterceptor.Invoke("direction$", "direction(unsigned short)", typeof(QChar.Direction), typeof(ushort), ucs2);
        }
        public static QChar.Joining joining(uint ucs4) {
            return (QChar.Joining) staticInterceptor.Invoke("joining$", "joining(uint)", typeof(QChar.Joining), typeof(uint), ucs4);
        }
        public static QChar.Joining joining(ushort ucs2) {
            return (QChar.Joining) staticInterceptor.Invoke("joining$", "joining(unsigned short)", typeof(QChar.Joining), typeof(ushort), ucs2);
        }
        public static ushort combiningClass(uint ucs4) {
            return (ushort) staticInterceptor.Invoke("combiningClass$", "combiningClass(uint)", typeof(ushort), typeof(uint), ucs4);
        }
        public static ushort combiningClass(ushort ucs2) {
            return (ushort) staticInterceptor.Invoke("combiningClass$", "combiningClass(unsigned short)", typeof(ushort), typeof(ushort), ucs2);
        }
        public static uint MirroredChar(uint ucs4) {
            return (uint) staticInterceptor.Invoke("mirroredChar$", "mirroredChar(uint)", typeof(uint), typeof(uint), ucs4);
        }
        public static ushort MirroredChar(ushort ucs2) {
            return (ushort) staticInterceptor.Invoke("mirroredChar$", "mirroredChar(unsigned short)", typeof(ushort), typeof(ushort), ucs2);
        }
        public static QChar.Decomposition DecompositionTag(uint ucs4) {
            return (QChar.Decomposition) staticInterceptor.Invoke("decompositionTag$", "decompositionTag(uint)", typeof(QChar.Decomposition), typeof(uint), ucs4);
        }
        public static int DigitValue(uint ucs4) {
            return (int) staticInterceptor.Invoke("digitValue$", "digitValue(uint)", typeof(int), typeof(uint), ucs4);
        }
        public static int DigitValue(ushort ucs2) {
            return (int) staticInterceptor.Invoke("digitValue$", "digitValue(unsigned short)", typeof(int), typeof(ushort), ucs2);
        }
        public static uint ToLower(uint ucs4) {
            return (uint) staticInterceptor.Invoke("toLower$", "toLower(uint)", typeof(uint), typeof(uint), ucs4);
        }
        public static ushort ToLower(ushort ucs2) {
            return (ushort) staticInterceptor.Invoke("toLower$", "toLower(unsigned short)", typeof(ushort), typeof(ushort), ucs2);
        }
        public static uint ToUpper(uint ucs4) {
            return (uint) staticInterceptor.Invoke("toUpper$", "toUpper(uint)", typeof(uint), typeof(uint), ucs4);
        }
        public static ushort ToUpper(ushort ucs2) {
            return (ushort) staticInterceptor.Invoke("toUpper$", "toUpper(unsigned short)", typeof(ushort), typeof(ushort), ucs2);
        }
        public static uint ToTitleCase(uint ucs4) {
            return (uint) staticInterceptor.Invoke("toTitleCase$", "toTitleCase(uint)", typeof(uint), typeof(uint), ucs4);
        }
        public static ushort ToTitleCase(ushort ucs2) {
            return (ushort) staticInterceptor.Invoke("toTitleCase$", "toTitleCase(unsigned short)", typeof(ushort), typeof(ushort), ucs2);
        }
        public static uint ToCaseFolded(uint ucs4) {
            return (uint) staticInterceptor.Invoke("toCaseFolded$", "toCaseFolded(uint)", typeof(uint), typeof(uint), ucs4);
        }
        public static ushort ToCaseFolded(ushort ucs2) {
            return (ushort) staticInterceptor.Invoke("toCaseFolded$", "toCaseFolded(unsigned short)", typeof(ushort), typeof(ushort), ucs2);
        }
        public static QChar.UnicodeVersion unicodeVersion(uint ucs4) {
            return (QChar.UnicodeVersion) staticInterceptor.Invoke("unicodeVersion$", "unicodeVersion(uint)", typeof(QChar.UnicodeVersion), typeof(uint), ucs4);
        }
        public static QChar.UnicodeVersion unicodeVersion(ushort ucs2) {
            return (QChar.UnicodeVersion) staticInterceptor.Invoke("unicodeVersion$", "unicodeVersion(unsigned short)", typeof(QChar.UnicodeVersion), typeof(ushort), ucs2);
        }
        public static string decomposition(uint ucs4) {
            return (string) staticInterceptor.Invoke("decomposition$", "decomposition(uint)", typeof(string), typeof(uint), ucs4);
        }
        public static bool operator==(QChar c1, QChar c2) {
            return (bool) staticInterceptor.Invoke("operator==##", "operator==(QChar, QChar)", typeof(bool), typeof(QChar), c1, typeof(QChar), c2);
        }
        public static bool operator!=(QChar c1, QChar c2) {
            return !(bool) staticInterceptor.Invoke("operator==##", "operator==(QChar, QChar)", typeof(bool), typeof(QChar), c1, typeof(QChar), c2);
        }
        public static bool operator<=(QChar c1, QChar c2) {
            return (bool) staticInterceptor.Invoke("operator<=##", "operator<=(QChar, QChar)", typeof(bool), typeof(QChar), c1, typeof(QChar), c2);
        }
        public static bool operator>=(QChar c1, QChar c2) {
            return (bool) staticInterceptor.Invoke("operator>=##", "operator>=(QChar, QChar)", typeof(bool), typeof(QChar), c1, typeof(QChar), c2);
        }
        public static bool operator<(QChar c1, QChar c2) {
            return (bool) staticInterceptor.Invoke("operator<##", "operator<(QChar, QChar)", typeof(bool), typeof(QChar), c1, typeof(QChar), c2);
        }
        public static bool operator>(QChar c1, QChar c2) {
            return (bool) staticInterceptor.Invoke("operator>##", "operator>(QChar, QChar)", typeof(bool), typeof(QChar), c1, typeof(QChar), c2);
        }
        public static string operator+(string s1, QChar s2) {
            return (string) staticInterceptor.Invoke("operator+$#", "operator+(const QString&, QChar)", typeof(string), typeof(string), s1, typeof(QChar), s2);
        }
        public static string operator+(QChar s1, string s2) {
            return (string) staticInterceptor.Invoke("operator+#$", "operator+(QChar, const QString&)", typeof(string), typeof(QChar), s1, typeof(string), s2);
        }
    }
}
