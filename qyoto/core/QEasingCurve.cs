//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
    using System;
    [SmokeClass("QEasingCurve")]
    public class QEasingCurve : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected QEasingCurve(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(QEasingCurve), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static QEasingCurve() {
            staticInterceptor = new SmokeInvocation(typeof(QEasingCurve), null);
        }
        public enum TypeOf {
            Linear = 0,
            InQuad = 1,
            OutQuad = 2,
            InOutQuad = 3,
            OutInQuad = 4,
            InCubic = 5,
            OutCubic = 6,
            InOutCubic = 7,
            OutInCubic = 8,
            InQuart = 9,
            OutQuart = 10,
            InOutQuart = 11,
            OutInQuart = 12,
            InQuint = 13,
            OutQuint = 14,
            InOutQuint = 15,
            OutInQuint = 16,
            InSine = 17,
            OutSine = 18,
            InOutSine = 19,
            OutInSine = 20,
            InExpo = 21,
            OutExpo = 22,
            InOutExpo = 23,
            OutInExpo = 24,
            InCirc = 25,
            OutCirc = 26,
            InOutCirc = 27,
            OutInCirc = 28,
            InElastic = 29,
            OutElastic = 30,
            InOutElastic = 31,
            OutInElastic = 32,
            InBack = 33,
            OutBack = 34,
            InOutBack = 35,
            OutInBack = 36,
            InBounce = 37,
            OutBounce = 38,
            InOutBounce = 39,
            OutInBounce = 40,
            InCurve = 41,
            OutCurve = 42,
            SineCurve = 43,
            CosineCurve = 44,
            Custom = 45,
            NCurveTypes = 46,
        }
        // void setCustomType(EasingFunction arg1); >>>> NOT CONVERTED
        // EasingFunction customType(); >>>> NOT CONVERTED
        public QEasingCurve(QEasingCurve.TypeOf type) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QEasingCurve$", "QEasingCurve(QEasingCurve::Type)", typeof(void), typeof(QEasingCurve.TypeOf), type);
        }
        public QEasingCurve() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QEasingCurve", "QEasingCurve()", typeof(void));
        }
        public QEasingCurve(QEasingCurve other) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QEasingCurve#", "QEasingCurve(const QEasingCurve&)", typeof(void), typeof(QEasingCurve), other);
        }
        public override bool Equals(object o) {
            if (!(o is QEasingCurve)) { return false; }
            return this == (QEasingCurve) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        public double Amplitude() {
            return (double) interceptor.Invoke("amplitude", "amplitude() const", typeof(double));
        }
        public void SetAmplitude(double amplitude) {
            interceptor.Invoke("setAmplitude$", "setAmplitude(qreal)", typeof(void), typeof(double), amplitude);
        }
        public double Period() {
            return (double) interceptor.Invoke("period", "period() const", typeof(double));
        }
        public void SetPeriod(double period) {
            interceptor.Invoke("setPeriod$", "setPeriod(qreal)", typeof(void), typeof(double), period);
        }
        public double Overshoot() {
            return (double) interceptor.Invoke("overshoot", "overshoot() const", typeof(double));
        }
        public void SetOvershoot(double overshoot) {
            interceptor.Invoke("setOvershoot$", "setOvershoot(qreal)", typeof(void), typeof(double), overshoot);
        }
        public QEasingCurve.TypeOf type() {
            return (QEasingCurve.TypeOf) interceptor.Invoke("type", "type() const", typeof(QEasingCurve.TypeOf));
        }
        public void SetType(QEasingCurve.TypeOf type) {
            interceptor.Invoke("setType$", "setType(QEasingCurve::Type)", typeof(void), typeof(QEasingCurve.TypeOf), type);
        }
        public double ValueForProgress(double progress) {
            return (double) interceptor.Invoke("valueForProgress$", "valueForProgress(qreal) const", typeof(double), typeof(double), progress);
        }
        ~QEasingCurve() {
            interceptor.Invoke("~QEasingCurve", "~QEasingCurve()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~QEasingCurve", "~QEasingCurve()", typeof(void));
        }
        public static bool operator==(QEasingCurve lhs, QEasingCurve other) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const QEasingCurve&) const", typeof(bool), typeof(QEasingCurve), lhs, typeof(QEasingCurve), other);
        }
        public static bool operator!=(QEasingCurve lhs, QEasingCurve other) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const QEasingCurve&) const", typeof(bool), typeof(QEasingCurve), lhs, typeof(QEasingCurve), other);
        }
    }
}
