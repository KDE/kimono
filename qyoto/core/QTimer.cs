//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
    using System;
    /// <remarks>*************************************************
    /// 
    /// * Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
    ///  All rights reserved.
    ///  Contact: Nokia Corporation (qt-info@nokia.com)
    /// 
    /// * This file is part of the QtCore module of the Qt Toolkit.
    /// 
    /// * $QT_BEGIN_LICENSE:LGPL$
    ///  Commercial Usage
    ///  Licensees holding valid Qt Commercial licenses may use this file in
    ///  accordance with the Qt Commercial License Agreement provided with the
    ///  Software or, alternatively, in accordance with the terms contained in
    ///  a written agreement between you and Nokia.
    /// 
    /// * GNU Lesser General Public License Usage
    ///  Alternatively, this file may be used under the terms of the GNU Lesser
    ///  General Public License version 2.1 as published by the Free Software
    ///  Foundation and appearing in the file LICENSE.LGPL included in the
    ///  packaging of this file.  Please review the following information to
    ///  ensure the GNU Lesser General Public License version 2.1 requirements
    ///  will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
    /// 
    /// * In addition, as a special exception, Nokia gives you certain additional
    ///  rights.  These rights are described in the Nokia Qt LGPL Exception
    ///  version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
    /// 
    /// * GNU General Public License Usage
    ///  Alternatively, this file may be used under the terms of the GNU
    ///  General Public License version 3.0 as published by the Free Software
    ///  Foundation and appearing in the file LICENSE.GPL included in the
    ///  packaging of this file.  Please review the following information to
    ///  ensure the GNU General Public License version 3.0 requirements will be
    ///  met: http://www.gnu.org/copyleft/gpl.html.
    /// 
    /// * If you have questions regarding the use of this file, please contact
    ///  Nokia at qt-info@nokia.com.
    ///  $QT_END_LICENSE$
    /// 
    /// ************************************************** See <see cref="IQTimerSignals"></see> for signals emitted by QTimer
    /// </remarks>        <short>                                                                                 Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).</short>
    [SmokeClass("QTimer")]
    public class QTimer : QObject, IDisposable {
        protected QTimer(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(QTimer), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static QTimer() {
            staticInterceptor = new SmokeInvocation(typeof(QTimer), null);
        }
        [Q_PROPERTY("bool", "singleShot")]
        public bool SingleShot {
            get { return (bool) interceptor.Invoke("isSingleShot", "isSingleShot()", typeof(bool)); }
            set { interceptor.Invoke("setSingleShot$", "setSingleShot(bool)", typeof(void), typeof(bool), value); }
        }
        [Q_PROPERTY("int", "interval")]
        public int Interval {
            get { return (int) interceptor.Invoke("interval", "interval()", typeof(int)); }
            set { interceptor.Invoke("setInterval$", "setInterval(int)", typeof(void), typeof(int), value); }
        }
        [Q_PROPERTY("bool", "active")]
        public bool Active {
            get { return (bool) interceptor.Invoke("isActive", "isActive()", typeof(bool)); }
        }
        public QTimer(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QTimer#", "QTimer(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public QTimer() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QTimer", "QTimer()", typeof(void));
        }
        public int TimerId() {
            return (int) interceptor.Invoke("timerId", "timerId() const", typeof(int));
        }
        [Q_SLOT("void start(int)")]
        public void Start(int msec) {
            interceptor.Invoke("start$", "start(int)", typeof(void), typeof(int), msec);
        }
        [Q_SLOT("void start()")]
        public void Start() {
            interceptor.Invoke("start", "start()", typeof(void));
        }
        [Q_SLOT("void stop()")]
        public void Stop() {
            interceptor.Invoke("stop", "stop()", typeof(void));
        }
        [SmokeMethod("timerEvent(QTimerEvent*)")]
        protected override void TimerEvent(QTimerEvent arg1) {
            interceptor.Invoke("timerEvent#", "timerEvent(QTimerEvent*)", typeof(void), typeof(QTimerEvent), arg1);
        }
        ~QTimer() {
            interceptor.Invoke("~QTimer", "~QTimer()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~QTimer", "~QTimer()", typeof(void));
        }
        public static new string Tr(string s, string c) {
            return (string) staticInterceptor.Invoke("tr$$", "tr(const char*, const char*)", typeof(string), typeof(string), s, typeof(string), c);
        }
        public static new string Tr(string s) {
            return (string) staticInterceptor.Invoke("tr$", "tr(const char*)", typeof(string), typeof(string), s);
        }
        public static void singleShot(int msec, QObject receiver, string member) {
            staticInterceptor.Invoke("singleShot$#$", "singleShot(int, QObject*, const char*)", typeof(void), typeof(int), msec, typeof(QObject), receiver, typeof(string), member);
        }
        protected new IQTimerSignals Emit {
            get { return (IQTimerSignals) Q_EMIT; }
        }
    }

    public interface IQTimerSignals : IQObjectSignals {
        [Q_SIGNAL("void timeout()")]
        void Timeout();
    }
}
