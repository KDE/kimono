//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
    using System;
    using System.Collections.Generic;
    [SmokeClass("QFSFileEngine")]
    public class QFSFileEngine : QAbstractFileEngine, IDisposable {
        protected QFSFileEngine(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(QFSFileEngine), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static QFSFileEngine() {
            staticInterceptor = new SmokeInvocation(typeof(QFSFileEngine), null);
        }
        // bool extension(QAbstractFileEngine::Extension arg1,const QAbstractFileEngine::ExtensionOption* arg2,QAbstractFileEngine::ExtensionReturn* arg3); >>>> NOT CONVERTED
        // bool extension(QAbstractFileEngine::Extension arg1,const QAbstractFileEngine::ExtensionOption* arg2); >>>> NOT CONVERTED
        // QFSFileEngine* QFSFileEngine(QFSFileEnginePrivate& arg1); >>>> NOT CONVERTED
        public QFSFileEngine() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QFSFileEngine", "QFSFileEngine()", typeof(void));
        }
        public QFSFileEngine(string file) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QFSFileEngine$", "QFSFileEngine(const QString&)", typeof(void), typeof(string), file);
        }
        [SmokeMethod("open(QIODevice::OpenMode)")]
        public override bool Open(uint openMode) {
            return (bool) interceptor.Invoke("open$", "open(QIODevice::OpenMode)", typeof(bool), typeof(uint), openMode);
        }
        [SmokeMethod("close()")]
        public override bool Close() {
            return (bool) interceptor.Invoke("close", "close()", typeof(bool));
        }
        [SmokeMethod("flush()")]
        public override bool Flush() {
            return (bool) interceptor.Invoke("flush", "flush()", typeof(bool));
        }
        [SmokeMethod("size() const")]
        public override long Size() {
            return (long) interceptor.Invoke("size", "size() const", typeof(long));
        }
        [SmokeMethod("pos() const")]
        public override long Pos() {
            return (long) interceptor.Invoke("pos", "pos() const", typeof(long));
        }
        [SmokeMethod("seek(qint64)")]
        public override bool Seek(long arg1) {
            return (bool) interceptor.Invoke("seek$", "seek(qint64)", typeof(bool), typeof(long), arg1);
        }
        [SmokeMethod("isSequential() const")]
        public override bool IsSequential() {
            return (bool) interceptor.Invoke("isSequential", "isSequential() const", typeof(bool));
        }
        [SmokeMethod("remove()")]
        public override bool Remove() {
            return (bool) interceptor.Invoke("remove", "remove()", typeof(bool));
        }
        [SmokeMethod("copy(const QString&)")]
        public override bool Copy(string newName) {
            return (bool) interceptor.Invoke("copy$", "copy(const QString&)", typeof(bool), typeof(string), newName);
        }
        [SmokeMethod("rename(const QString&)")]
        public override bool Rename(string newName) {
            return (bool) interceptor.Invoke("rename$", "rename(const QString&)", typeof(bool), typeof(string), newName);
        }
        [SmokeMethod("link(const QString&)")]
        public override bool Link(string newName) {
            return (bool) interceptor.Invoke("link$", "link(const QString&)", typeof(bool), typeof(string), newName);
        }
        [SmokeMethod("mkdir(const QString&, bool) const")]
        public override bool Mkdir(string dirName, bool createParentDirectories) {
            return (bool) interceptor.Invoke("mkdir$$", "mkdir(const QString&, bool) const", typeof(bool), typeof(string), dirName, typeof(bool), createParentDirectories);
        }
        [SmokeMethod("rmdir(const QString&, bool) const")]
        public override bool Rmdir(string dirName, bool recurseParentDirectories) {
            return (bool) interceptor.Invoke("rmdir$$", "rmdir(const QString&, bool) const", typeof(bool), typeof(string), dirName, typeof(bool), recurseParentDirectories);
        }
        [SmokeMethod("setSize(qint64)")]
        public override bool SetSize(long size) {
            return (bool) interceptor.Invoke("setSize$", "setSize(qint64)", typeof(bool), typeof(long), size);
        }
        [SmokeMethod("caseSensitive() const")]
        public override bool CaseSensitive() {
            return (bool) interceptor.Invoke("caseSensitive", "caseSensitive() const", typeof(bool));
        }
        [SmokeMethod("isRelativePath() const")]
        public override bool IsRelativePath() {
            return (bool) interceptor.Invoke("isRelativePath", "isRelativePath() const", typeof(bool));
        }
        [SmokeMethod("entryList(QDir::Filters, const QStringList&) const")]
        public override List<string> EntryList(uint filters, List<string> filterNames) {
            return (List<string>) interceptor.Invoke("entryList$?", "entryList(QDir::Filters, const QStringList&) const", typeof(List<string>), typeof(uint), filters, typeof(List<string>), filterNames);
        }
        [SmokeMethod("fileFlags(QAbstractFileEngine::FileFlags) const")]
        public override uint FileFlags(uint type) {
            return (uint) interceptor.Invoke("fileFlags$", "fileFlags(QAbstractFileEngine::FileFlags) const", typeof(uint), typeof(uint), type);
        }
        [SmokeMethod("setPermissions(uint)")]
        public override bool SetPermissions(uint perms) {
            return (bool) interceptor.Invoke("setPermissions$", "setPermissions(uint)", typeof(bool), typeof(uint), perms);
        }
        [SmokeMethod("fileName(QAbstractFileEngine::FileName) const")]
        public override string fileName(QAbstractFileEngine.FileName file) {
            return (string) interceptor.Invoke("fileName$", "fileName(QAbstractFileEngine::FileName) const", typeof(string), typeof(QAbstractFileEngine.FileName), file);
        }
        [SmokeMethod("ownerId(QAbstractFileEngine::FileOwner) const")]
        public override uint OwnerId(QAbstractFileEngine.FileOwner arg1) {
            return (uint) interceptor.Invoke("ownerId$", "ownerId(QAbstractFileEngine::FileOwner) const", typeof(uint), typeof(QAbstractFileEngine.FileOwner), arg1);
        }
        [SmokeMethod("owner(QAbstractFileEngine::FileOwner) const")]
        public override string Owner(QAbstractFileEngine.FileOwner arg1) {
            return (string) interceptor.Invoke("owner$", "owner(QAbstractFileEngine::FileOwner) const", typeof(string), typeof(QAbstractFileEngine.FileOwner), arg1);
        }
        [SmokeMethod("fileTime(QAbstractFileEngine::FileTime) const")]
        public override QDateTime fileTime(QAbstractFileEngine.FileTime time) {
            return (QDateTime) interceptor.Invoke("fileTime$", "fileTime(QAbstractFileEngine::FileTime) const", typeof(QDateTime), typeof(QAbstractFileEngine.FileTime), time);
        }
        [SmokeMethod("setFileName(const QString&)")]
        public override void SetFileName(string file) {
            interceptor.Invoke("setFileName$", "setFileName(const QString&)", typeof(void), typeof(string), file);
        }
        [SmokeMethod("beginEntryList(QDir::Filters, const QStringList&)")]
        public override QAbstractFileEngineIterator BeginEntryList(uint filters, List<string> filterNames) {
            return (QAbstractFileEngineIterator) interceptor.Invoke("beginEntryList$?", "beginEntryList(QDir::Filters, const QStringList&)", typeof(QAbstractFileEngineIterator), typeof(uint), filters, typeof(List<string>), filterNames);
        }
        [SmokeMethod("endEntryList()")]
        public override QAbstractFileEngineIterator EndEntryList() {
            return (QAbstractFileEngineIterator) interceptor.Invoke("endEntryList", "endEntryList()", typeof(QAbstractFileEngineIterator));
        }
        [SmokeMethod("read(char*, qint64)")]
        public override long Read(Pointer<sbyte> data, long maxlen) {
            return (long) interceptor.Invoke("read$$", "read(char*, qint64)", typeof(long), typeof(Pointer<sbyte>), data, typeof(long), maxlen);
        }
        [SmokeMethod("readLine(char*, qint64)")]
        public override long ReadLine(Pointer<sbyte> data, long maxlen) {
            return (long) interceptor.Invoke("readLine$$", "readLine(char*, qint64)", typeof(long), typeof(Pointer<sbyte>), data, typeof(long), maxlen);
        }
        [SmokeMethod("write(const char*, qint64)")]
        public override long Write(string data, long len) {
            return (long) interceptor.Invoke("write$$", "write(const char*, qint64)", typeof(long), typeof(string), data, typeof(long), len);
        }
        [SmokeMethod("extension(QAbstractFileEngine::Extension)")]
        public override bool extension(QAbstractFileEngine.Extension extension) {
            return (bool) interceptor.Invoke("extension$", "extension(QAbstractFileEngine::Extension)", typeof(bool), typeof(QAbstractFileEngine.Extension), extension);
        }
        [SmokeMethod("supportsExtension(QAbstractFileEngine::Extension) const")]
        public override bool SupportsExtension(QAbstractFileEngine.Extension extension) {
            return (bool) interceptor.Invoke("supportsExtension$", "supportsExtension(QAbstractFileEngine::Extension) const", typeof(bool), typeof(QAbstractFileEngine.Extension), extension);
        }
        public bool Open(uint flags, int fd) {
            return (bool) interceptor.Invoke("open$$", "open(QIODevice::OpenMode, int)", typeof(bool), typeof(uint), flags, typeof(int), fd);
        }
        ~QFSFileEngine() {
            interceptor.Invoke("~QFSFileEngine", "~QFSFileEngine()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~QFSFileEngine", "~QFSFileEngine()", typeof(void));
        }
        public static bool SetCurrentPath(string path) {
            return (bool) staticInterceptor.Invoke("setCurrentPath$", "setCurrentPath(const QString&)", typeof(bool), typeof(string), path);
        }
        public static string CurrentPath(string path) {
            return (string) staticInterceptor.Invoke("currentPath$", "currentPath(const QString&)", typeof(string), typeof(string), path);
        }
        public static string CurrentPath() {
            return (string) staticInterceptor.Invoke("currentPath", "currentPath()", typeof(string));
        }
        public static string HomePath() {
            return (string) staticInterceptor.Invoke("homePath", "homePath()", typeof(string));
        }
        public static string RootPath() {
            return (string) staticInterceptor.Invoke("rootPath", "rootPath()", typeof(string));
        }
        public static string TempPath() {
            return (string) staticInterceptor.Invoke("tempPath", "tempPath()", typeof(string));
        }
        public static List<QFileInfo> Drives() {
            return (List<QFileInfo>) staticInterceptor.Invoke("drives", "drives()", typeof(List<QFileInfo>));
        }
    }
}
