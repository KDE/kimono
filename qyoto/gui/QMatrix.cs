//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
    using System;
    using System.Runtime.InteropServices;
    [SmokeClass("QMatrix")]
    public class QMatrix : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected QMatrix(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(QMatrix), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static QMatrix() {
            staticInterceptor = new SmokeInvocation(typeof(QMatrix), null);
        }
        // QMatrix& operator*=(const QMatrix& arg1); >>>> NOT CONVERTED
        public QMatrix(Qt.Initialization arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QMatrix$", "QMatrix(Qt::Initialization)", typeof(void), typeof(Qt.Initialization), arg1);
        }
        public QMatrix() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QMatrix", "QMatrix()", typeof(void));
        }
        public QMatrix(double m11, double m12, double m21, double m22, double dx, double dy) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QMatrix$$$$$$", "QMatrix(qreal, qreal, qreal, qreal, qreal, qreal)", typeof(void), typeof(double), m11, typeof(double), m12, typeof(double), m21, typeof(double), m22, typeof(double), dx, typeof(double), dy);
        }
        public QMatrix(QMatrix matrix) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QMatrix#", "QMatrix(const QMatrix&)", typeof(void), typeof(QMatrix), matrix);
        }
        public void SetMatrix(double m11, double m12, double m21, double m22, double dx, double dy) {
            interceptor.Invoke("setMatrix$$$$$$", "setMatrix(qreal, qreal, qreal, qreal, qreal, qreal)", typeof(void), typeof(double), m11, typeof(double), m12, typeof(double), m21, typeof(double), m22, typeof(double), dx, typeof(double), dy);
        }
        public double M11() {
            return (double) interceptor.Invoke("m11", "m11() const", typeof(double));
        }
        public double M12() {
            return (double) interceptor.Invoke("m12", "m12() const", typeof(double));
        }
        public double M21() {
            return (double) interceptor.Invoke("m21", "m21() const", typeof(double));
        }
        public double M22() {
            return (double) interceptor.Invoke("m22", "m22() const", typeof(double));
        }
        public double Dx() {
            return (double) interceptor.Invoke("dx", "dx() const", typeof(double));
        }
        public double Dy() {
            return (double) interceptor.Invoke("dy", "dy() const", typeof(double));
        }
        public void Map(int x, int y, ref int tx, ref int ty) {
            StackItem[] stack = new StackItem[5];
            stack[1].s_int = x;
            stack[2].s_int = y;
            stack[3].s_int = tx;
            stack[4].s_int = ty;
            interceptor.Invoke("map$$$$", "map(int, int, int*, int*) const", stack);
            tx = stack[3].s_int;
            ty = stack[4].s_int;
            return;
        }
        public void Map(double x, double y, ref double tx, ref double ty) {
            StackItem[] stack = new StackItem[5];
            stack[1].s_double = x;
            stack[2].s_double = y;
            stack[3].s_double = tx;
            stack[4].s_double = ty;
            interceptor.Invoke("map$$$$", "map(qreal, qreal, qreal*, qreal*) const", stack);
            tx = stack[3].s_double;
            ty = stack[4].s_double;
            return;
        }
        public QRect MapRect(QRect arg1) {
            return (QRect) interceptor.Invoke("mapRect#", "mapRect(const QRect&) const", typeof(QRect), typeof(QRect), arg1);
        }
        public QRectF MapRect(QRectF arg1) {
            return (QRectF) interceptor.Invoke("mapRect#", "mapRect(const QRectF&) const", typeof(QRectF), typeof(QRectF), arg1);
        }
        public QPoint Map(QPoint p) {
            return (QPoint) interceptor.Invoke("map#", "map(const QPoint&) const", typeof(QPoint), typeof(QPoint), p);
        }
        public QPointF Map(QPointF p) {
            return (QPointF) interceptor.Invoke("map#", "map(const QPointF&) const", typeof(QPointF), typeof(QPointF), p);
        }
        public QLine Map(QLine l) {
            return (QLine) interceptor.Invoke("map#", "map(const QLine&) const", typeof(QLine), typeof(QLine), l);
        }
        public QLineF Map(QLineF l) {
            return (QLineF) interceptor.Invoke("map#", "map(const QLineF&) const", typeof(QLineF), typeof(QLineF), l);
        }
        public QPolygonF Map(QPolygonF a) {
            return (QPolygonF) interceptor.Invoke("map#", "map(const QPolygonF&) const", typeof(QPolygonF), typeof(QPolygonF), a);
        }
        public QPolygon Map(QPolygon a) {
            return (QPolygon) interceptor.Invoke("map#", "map(const QPolygon&) const", typeof(QPolygon), typeof(QPolygon), a);
        }
        public QRegion Map(QRegion r) {
            return (QRegion) interceptor.Invoke("map#", "map(const QRegion&) const", typeof(QRegion), typeof(QRegion), r);
        }
        public QPainterPath Map(QPainterPath p) {
            return (QPainterPath) interceptor.Invoke("map#", "map(const QPainterPath&) const", typeof(QPainterPath), typeof(QPainterPath), p);
        }
        public QPolygon MapToPolygon(QRect r) {
            return (QPolygon) interceptor.Invoke("mapToPolygon#", "mapToPolygon(const QRect&) const", typeof(QPolygon), typeof(QRect), r);
        }
        public void Reset() {
            interceptor.Invoke("reset", "reset()", typeof(void));
        }
        public bool IsIdentity() {
            return (bool) interceptor.Invoke("isIdentity", "isIdentity() const", typeof(bool));
        }
        public QMatrix Translate(double dx, double dy) {
            return (QMatrix) interceptor.Invoke("translate$$", "translate(qreal, qreal)", typeof(QMatrix), typeof(double), dx, typeof(double), dy);
        }
        public QMatrix Scale(double sx, double sy) {
            return (QMatrix) interceptor.Invoke("scale$$", "scale(qreal, qreal)", typeof(QMatrix), typeof(double), sx, typeof(double), sy);
        }
        public QMatrix Shear(double sh, double sv) {
            return (QMatrix) interceptor.Invoke("shear$$", "shear(qreal, qreal)", typeof(QMatrix), typeof(double), sh, typeof(double), sv);
        }
        public QMatrix Rotate(double a) {
            return (QMatrix) interceptor.Invoke("rotate$", "rotate(qreal)", typeof(QMatrix), typeof(double), a);
        }
        public bool IsInvertible() {
            return (bool) interceptor.Invoke("isInvertible", "isInvertible() const", typeof(bool));
        }
        public double Determinant() {
            return (double) interceptor.Invoke("determinant", "determinant() const", typeof(double));
        }
        public QMatrix Inverted(ref bool invertible) {
            StackItem[] stack = new StackItem[2];
            stack[1].s_bool = invertible;
            interceptor.Invoke("inverted$", "inverted(bool*) const", stack);
            invertible = stack[1].s_bool;
            object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
            DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
            ((GCHandle) stack[0].s_class).SynchronizedFree();
#endif
            return (QMatrix) returnValue;
        }
        public QMatrix Inverted() {
            return (QMatrix) interceptor.Invoke("inverted", "inverted() const", typeof(QMatrix));
        }
        public override bool Equals(object o) {
            if (!(o is QMatrix)) { return false; }
            return this == (QMatrix) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        ~QMatrix() {
            interceptor.Invoke("~QMatrix", "~QMatrix()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~QMatrix", "~QMatrix()", typeof(void));
        }
        public static bool operator==(QMatrix lhs, QMatrix arg1) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const QMatrix&) const", typeof(bool), typeof(QMatrix), lhs, typeof(QMatrix), arg1);
        }
        public static bool operator!=(QMatrix lhs, QMatrix arg1) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const QMatrix&) const", typeof(bool), typeof(QMatrix), lhs, typeof(QMatrix), arg1);
        }
        public static QMatrix operator*(QMatrix lhs, QMatrix o) {
            return (QMatrix) staticInterceptor.Invoke("operator*#", "operator*(const QMatrix&) const", typeof(QMatrix), typeof(QMatrix), lhs, typeof(QMatrix), o);
        }
        public static QVariant operatorQVariant(QMatrix lhs) {
            return (QVariant) staticInterceptor.Invoke("operator QVariant", "operator QVariant() const", typeof(QVariant), typeof(QMatrix), lhs);
        }
        public static QPoint operator*(QPoint p, QMatrix m) {
            return (QPoint) staticInterceptor.Invoke("operator*##", "operator*(const QPoint&, const QMatrix&)", typeof(QPoint), typeof(QPoint), p, typeof(QMatrix), m);
        }
        public static QPointF operator*(QPointF p, QMatrix m) {
            return (QPointF) staticInterceptor.Invoke("operator*##", "operator*(const QPointF&, const QMatrix&)", typeof(QPointF), typeof(QPointF), p, typeof(QMatrix), m);
        }
        public static QLineF operator*(QLineF l, QMatrix m) {
            return (QLineF) staticInterceptor.Invoke("operator*##", "operator*(const QLineF&, const QMatrix&)", typeof(QLineF), typeof(QLineF), l, typeof(QMatrix), m);
        }
        public static QLine operator*(QLine l, QMatrix m) {
            return (QLine) staticInterceptor.Invoke("operator*##", "operator*(const QLine&, const QMatrix&)", typeof(QLine), typeof(QLine), l, typeof(QMatrix), m);
        }
        public static QPolygon operator*(QPolygon a, QMatrix m) {
            return (QPolygon) staticInterceptor.Invoke("operator*##", "operator*(const QPolygon&, const QMatrix&)", typeof(QPolygon), typeof(QPolygon), a, typeof(QMatrix), m);
        }
        public static QPolygonF operator*(QPolygonF a, QMatrix m) {
            return (QPolygonF) staticInterceptor.Invoke("operator*##", "operator*(const QPolygonF&, const QMatrix&)", typeof(QPolygonF), typeof(QPolygonF), a, typeof(QMatrix), m);
        }
        public static QRegion operator*(QRegion r, QMatrix m) {
            return (QRegion) staticInterceptor.Invoke("operator*##", "operator*(const QRegion&, const QMatrix&)", typeof(QRegion), typeof(QRegion), r, typeof(QMatrix), m);
        }
        public static QPainterPath operator*(QPainterPath p, QMatrix m) {
            return (QPainterPath) staticInterceptor.Invoke("operator*##", "operator*(const QPainterPath&, const QMatrix&)", typeof(QPainterPath), typeof(QPainterPath), p, typeof(QMatrix), m);
        }
    }
}
