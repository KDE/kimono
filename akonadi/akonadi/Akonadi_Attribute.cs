//Auto-generated by kalyptus. DO NOT EDIT.
namespace Akonadi {
    using Kimono;
    using System;
    using Qyoto;
    /// <remarks>
    ///  This class is an interface for custom attributes, that can be stored
    ///  in an entity. Attributes should be meta data, e.g. ACLs, quotas etc.
    ///  that are not part of the entities' data itself.
    ///  To provide custom attributes, you have to subclass from this interface
    ///  and reimplement the pure methods.
    ///  @code
    ///  class SecrecyAttribute : public Akonadi.Attribute
    ///  {
    ///     public       enum Secrecy
    ///       {
    ///         Public,
    ///         Private,
    ///         Confidential
    ///       }
    ///       SecrecyAttribute( Secrecy secrecy = Public )
    ///       {
    ///       }
    ///       void setSecrecy( Secrecy secrecy )
    ///       {
    ///         mSecrecy = secrecy;
    ///       }
    ///       Secrecy secrecy() const
    ///       {
    ///         return mSecrecy;
    ///       }
    ///       QByteArray type() const
    ///       {
    ///         return "secrecy";
    ///       }
    ///       Attribute clone() const
    ///       {
    ///         return new SecrecyAttribute( mSecrecy );
    ///       }
    ///       QByteArray serialized() const
    ///       {
    ///         switch ( mSecrecy ) {
    ///           case Public: return "public"; break;
    ///           case Private: return "private"; break;
    ///           case Confidential: return "confidential"; break;
    ///         }
    ///       }
    ///       void deserialize( QByteArraydata )
    ///       {
    ///         if ( data == "public" )
    ///           mSecrecy = Public;
    ///         else if ( data == "private" )
    ///           mSecrecy = Private;
    ///         else if ( data == "confidential" )
    ///           mSecrecy = Confidential;
    ///       }
    ///  }
    ///  @endcode
    ///  Additionally, you need to register your attribute with Akonadi.AttributeFactory
    ///  for automatic deserialization during retrieving of collecitons or items:
    ///  @code
    ///  AttributeFactory.RegisterAttribute<SecrecyAttribute>();
    ///  @endcode
    ///  The custom attributes can be used in the following way:
    ///  @code
    ///  Akonadi.Item item( "text/directory" );
    ///  SecrecyAttribute attr = item.attribute<SecrecyAttribute>( Item.AddIfMissing );
    ///  attr.setSecrecy( SecrecyAttribute.Confidential );
    ///  @endcode
    ///  and
    ///  @code
    ///  Akonadi.Item item = ...
    ///  if ( item.hasAttribute<SecrecyAttribute>() ) {
    ///    SecrecyAttribute attr = item.attribute<SecrecyAttribute>();
    ///    SecrecyAttribute.Secrecy secrecy = attr.Secrecy();
    ///    ...
    ///  }
    ///  @endcode
    /// </remarks>        <author> Volker Krause <vkrause@kde.org>
    ///  </author>
    ///         <short> Provides interface for custom attributes for Entity. </short>
    [SmokeClass("Akonadi::Attribute")]
    public abstract class Attribute : Object {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected Attribute(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Attribute), this);
        }
        /// <remarks>
        ///  Returns the type of the attribute.
        ///      </remarks>        <short>    Returns the type of the attribute.</short>
        [SmokeMethod("type() const")]
        public abstract QByteArray Type();
        /// <remarks>
        ///  Creates a copy of this attribute.
        ///      </remarks>        <short>    Creates a copy of this attribute.</short>
        [SmokeMethod("clone() const")]
        public abstract Akonadi.Attribute Clone();
        /// <remarks>
        ///  Returns a QByteArray representation of the attribute which will be
        ///  storaged. This can be raw binary data, no encoding needs to be applied.
        ///      </remarks>        <short>    Returns a QByteArray representation of the attribute which will be  storaged.</short>
        [SmokeMethod("serialized() const")]
        public abstract QByteArray Serialized();
        /// <remarks>
        ///  Sets the data of this attribute, using the same encoding
        ///  as returned by toByteArray().
        /// <param> name="data" The encoded attribute data.
        ///      </param></remarks>        <short>    Sets the data of this attribute, using the same encoding  as returned by toByteArray().</short>
        [SmokeMethod("deserialize(const QByteArray&)")]
        public abstract void Deserialize(QByteArray data);
        public Attribute() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Attribute", "Attribute()", typeof(void));
        }
    }
}
