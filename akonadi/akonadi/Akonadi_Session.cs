//Auto-generated by kalyptus. DO NOT EDIT.
namespace Akonadi {
    using Kimono;
    using System;
    using Qyoto;
    /// <remarks>
    ///  Every Job object has to be associated with a Session.
    ///  The session is responsible of scheduling its jobs.
    ///  For now only a simple serial execution is impleneted (the IMAP-like
    ///  protocol to communicate with the storage backend is capable of parallel
    ///  execution on a single session though).
    ///  @code
    ///  using namespace Akonadi;
    ///  Session session = new Session( "mySession" );
    ///  CollectionFetchJob job = new CollectionFetchJob( Collection.Root(),
    ///                                                    CollectionFetchJob.Recursive,
    ///                                                    session );
    ///  connect( job, SIGNAL("result( KJob )"), this, SLOT("slotResult( KJob )") );
    ///  @endcode
    /// </remarks>        <author> Volker Krause <vkrause@kde.org>
    ///  </author>
    ///         <short> A communication session with the Akonadi storage. </short>
    [SmokeClass("Akonadi::Session")]
    public class Session : QObject, IDisposable {
        protected Session(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Session), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static Session() {
            staticInterceptor = new SmokeInvocation(typeof(Session), null);
        }
        /// <remarks>
        ///  Creates a new session.
        /// <param> name="sessionId" The identifier for this session, will be a
        ///                   random value if empty.
        /// </param><param> name="parent" The parent object.
        /// </param></remarks>        <short>    Creates a new session.</short>
        ///         <see> defaultSession</see>
        public Session(QByteArray sessionId, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Session##", "Session(const QByteArray&, QObject*)", typeof(void), typeof(QByteArray), sessionId, typeof(QObject), parent);
        }
        public Session(QByteArray sessionId) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Session#", "Session(const QByteArray&)", typeof(void), typeof(QByteArray), sessionId);
        }
        public Session() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Session", "Session()", typeof(void));
        }
        /// <remarks>
        ///  Returns the session identifier.
        ///      </remarks>        <short>    Returns the session identifier.</short>
        public QByteArray SessionId() {
            return (QByteArray) interceptor.Invoke("sessionId", "sessionId() const", typeof(QByteArray));
        }
        /// <remarks>
        ///  Stops all jobs queued for execution.
        ///      </remarks>        <short>    Stops all jobs queued for execution.</short>
        public void Clear() {
            interceptor.Invoke("clear", "clear()", typeof(void));
        }
        ~Session() {
            interceptor.Invoke("~Session", "~Session()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~Session", "~Session()", typeof(void));
        }
        /// <remarks>
        ///  Returns the default session for this thread.
        ///      </remarks>        <short>    Returns the default session for this thread.</short>
        public static Akonadi.Session DefaultSession() {
            return (Akonadi.Session) staticInterceptor.Invoke("defaultSession", "defaultSession()", typeof(Akonadi.Session));
        }
        protected new ISessionSignals Emit {
            get { return (ISessionSignals) Q_EMIT; }
        }
    }

    public interface ISessionSignals : IQObjectSignals {
    }
}
