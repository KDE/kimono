//Auto-generated by kalyptus. DO NOT EDIT.
namespace Akonadi {
    using Kimono;
    using System;
    using Qyoto;
    /// <remarks>
    ///  This filter proxy model works on top of a AgentTypeModel or AgentInstanceModel
    ///  and can be used to show only AgentType or AgentInstance objects
    ///  which provide a given mime type or capability.
    ///  @code
    ///  // Show only running agent instances that provide contacts
    ///  Akonadi.AgentInstanceModel model = new Akonadi.AgentInstanceModel( this );
    ///  Akonadi.AgentFilterProxyModel proxy = new Akonadi.AgentFilterProxyModel( this );
    ///  proxy.AddMimeTypeFilter( "text/directory" );
    ///  proxy.SetSourceModel( model );
    ///  QListView view = new QListView( this );
    ///  view.SetModel( proxy );
    ///  @endcode
    /// </remarks>        <author> Volker Krause <vkrause@kde.org>
    ///  </author>
    ///         <short> A proxy model for filtering AgentType or AgentInstance.</short>
    [SmokeClass("Akonadi::AgentFilterProxyModel")]
    public class AgentFilterProxyModel : QSortFilterProxyModel, IDisposable {
        protected AgentFilterProxyModel(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(AgentFilterProxyModel), this);
        }
        /// <remarks>
        ///  Create a new agent filter proxy model.
        ///  By default no filtering is done.
        ///      </remarks>        <short>    Create a new agent filter proxy model.</short>
        public AgentFilterProxyModel(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("AgentFilterProxyModel#", "AgentFilterProxyModel(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public AgentFilterProxyModel() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("AgentFilterProxyModel", "AgentFilterProxyModel()", typeof(void));
        }
        /// <remarks>
        ///  Accept agents supporting <code>mimeType.</code>
        ///      </remarks>        <short>    Accept agents supporting <code>mimeType.</code></short>
        public void AddMimeTypeFilter(string mimeType) {
            interceptor.Invoke("addMimeTypeFilter$", "addMimeTypeFilter(const QString&)", typeof(void), typeof(string), mimeType);
        }
        /// <remarks>
        ///  Accept agents with the given <code>capability.</code>
        ///      </remarks>        <short>    Accept agents with the given <code>capability.</code></short>
        public void AddCapabilityFilter(string capability) {
            interceptor.Invoke("addCapabilityFilter$", "addCapabilityFilter(const QString&)", typeof(void), typeof(string), capability);
        }
        /// <remarks>
        ///  Clear the filters ( mimeTypes & capabilities ).
        ///      </remarks>        <short>    Clear the filters ( mimeTypes & capabilities ).</short>
        public void ClearFilters() {
            interceptor.Invoke("clearFilters", "clearFilters()", typeof(void));
        }
        [SmokeMethod("filterAcceptsRow(int, const QModelIndex&) const")]
        protected override bool FilterAcceptsRow(int row, QModelIndex parent) {
            return (bool) interceptor.Invoke("filterAcceptsRow$#", "filterAcceptsRow(int, const QModelIndex&) const", typeof(bool), typeof(int), row, typeof(QModelIndex), parent);
        }
        ~AgentFilterProxyModel() {
            interceptor.Invoke("~AgentFilterProxyModel", "~AgentFilterProxyModel()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~AgentFilterProxyModel", "~AgentFilterProxyModel()", typeof(void));
        }
        protected new IAgentFilterProxyModelSignals Emit {
            get { return (IAgentFilterProxyModelSignals) Q_EMIT; }
        }
    }

    public interface IAgentFilterProxyModelSignals : IQSortFilterProxyModelSignals {
    }
}
