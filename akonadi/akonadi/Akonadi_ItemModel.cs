//Auto-generated by kalyptus. DO NOT EDIT.
namespace Akonadi {
    using Kimono;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  A self-updating table model that shows all items of
    ///  a collection.
    ///  @code
    ///  QTableView view = new QTableView( this );
    ///  Akonadi.ItemModel model = new Akonadi.ItemModel();
    ///  view.SetModel( model );
    ///  model.SetCollection( Akonadi.Collection.Root() );
    ///  @endcode
    ///  See <see cref="IItemModelSignals"></see> for signals emitted by ItemModel
    /// </remarks>        <author> Volker Krause <vkrause@kde.org>
    ///  </author>
    ///         <short> A table model for items. </short>
    [SmokeClass("Akonadi::ItemModel")]
    public class ItemModel : QAbstractTableModel, IDisposable {
        protected ItemModel(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(ItemModel), this);
        }
        /// <remarks>
        ///  Describes the types of the columns in the model.
        ///      </remarks>        <short>    Describes the types of the columns in the model.</short>
        public enum Column {
            Id = 0,
            RemoteId = 1,
            MimeType = 2,
        }
        /// <remarks>
        ///  Describes the roles of the model.
        ///      </remarks>        <short>    Describes the roles of the model.</short>
        public enum Roles {
            IdRole = Qt.ItemDataRole.UserRole+1,
            ItemRole = 0,
            MimeTypeRole = 1,
            UserRole = Qt.ItemDataRole.UserRole+42,
        }
        /// <remarks>
        ///  Creates a new item model.
        /// <param> name="parent" The parent object.
        ///      </param></remarks>        <short>    Creates a new item model.</short>
        public ItemModel(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ItemModel#", "ItemModel(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public ItemModel() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ItemModel", "ItemModel()", typeof(void));
        }
        [SmokeMethod("columnCount(const QModelIndex&) const")]
        public override int ColumnCount(QModelIndex parent) {
            return (int) interceptor.Invoke("columnCount#", "columnCount(const QModelIndex&) const", typeof(int), typeof(QModelIndex), parent);
        }
        [SmokeMethod("columnCount() const")]
        public virtual int ColumnCount() {
            return (int) interceptor.Invoke("columnCount", "columnCount() const", typeof(int));
        }
        [SmokeMethod("data(const QModelIndex&, int) const")]
        public override QVariant Data(QModelIndex index, int role) {
            return (QVariant) interceptor.Invoke("data#$", "data(const QModelIndex&, int) const", typeof(QVariant), typeof(QModelIndex), index, typeof(int), role);
        }
        [SmokeMethod("data(const QModelIndex&) const")]
        public virtual QVariant Data(QModelIndex index) {
            return (QVariant) interceptor.Invoke("data#", "data(const QModelIndex&) const", typeof(QVariant), typeof(QModelIndex), index);
        }
        [SmokeMethod("rowCount(const QModelIndex&) const")]
        public override int RowCount(QModelIndex parent) {
            return (int) interceptor.Invoke("rowCount#", "rowCount(const QModelIndex&) const", typeof(int), typeof(QModelIndex), parent);
        }
        [SmokeMethod("rowCount() const")]
        public virtual int RowCount() {
            return (int) interceptor.Invoke("rowCount", "rowCount() const", typeof(int));
        }
        [SmokeMethod("headerData(int, Qt::Orientation, int) const")]
        public override QVariant HeaderData(int section, Qt.Orientation orientation, int role) {
            return (QVariant) interceptor.Invoke("headerData$$$", "headerData(int, Qt::Orientation, int) const", typeof(QVariant), typeof(int), section, typeof(Qt.Orientation), orientation, typeof(int), role);
        }
        [SmokeMethod("headerData(int, Qt::Orientation) const")]
        public override QVariant HeaderData(int section, Qt.Orientation orientation) {
            return (QVariant) interceptor.Invoke("headerData$$", "headerData(int, Qt::Orientation) const", typeof(QVariant), typeof(int), section, typeof(Qt.Orientation), orientation);
        }
        [SmokeMethod("flags(const QModelIndex&) const")]
        public override uint Flags(QModelIndex index) {
            return (uint) interceptor.Invoke("flags#", "flags(const QModelIndex&) const", typeof(uint), typeof(QModelIndex), index);
        }
        [SmokeMethod("mimeData(const QList<QModelIndex>&) const")]
        public override QMimeData MimeData(List<QModelIndex> indexes) {
            return (QMimeData) interceptor.Invoke("mimeData?", "mimeData(const QList<QModelIndex>&) const", typeof(QMimeData), typeof(List<QModelIndex>), indexes);
        }
        [SmokeMethod("mimeTypes() const")]
        public override List<string> MimeTypes() {
            return (List<string>) interceptor.Invoke("mimeTypes", "mimeTypes() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Sets the item fetch scope.
        ///  The ItemFetchScope controls how much of an item's data is fetched from the
        ///  server, e.g. whether to fetch the full item payload or only meta data.
        /// <param> name="fetchScope" The new scope for item fetch operations.
        /// </param></remarks>        <short>    Sets the item fetch scope.</short>
        ///         <see> fetchScope</see>
        public void SetFetchScope(Akonadi.ItemFetchScope fetchScope) {
            interceptor.Invoke("setFetchScope#", "setFetchScope(const Akonadi::ItemFetchScope&)", typeof(void), typeof(Akonadi.ItemFetchScope), fetchScope);
        }
        /// <remarks>
        ///  Returns the item fetch scope.
        ///  Since this returns a reference it can be used to conveniently modify the
        ///  current scope in-place, i.e. by calling a method on the returned reference
        ///  without storing it in a local variable. See the ItemFetchScope documentation
        ///  for an example.
        /// </remarks>        <return> a reference to the current item fetch scope.
        /// </return>
        ///         <short>    Returns the item fetch scope.</short>
        ///         <see> setFetchScope</see>
        ///         <see> for</see>
        ///         <see> replacing</see>
        ///         <see> the</see>
        ///         <see> current</see>
        ///         <see> item</see>
        ///         <see> fetch</see>
        ///         <see> scope.</see>
        public Akonadi.ItemFetchScope FetchScope() {
            return (Akonadi.ItemFetchScope) interceptor.Invoke("fetchScope", "fetchScope()", typeof(Akonadi.ItemFetchScope));
        }
        /// <remarks>
        ///  Returns the item at the given <code>index.</code>
        ///      </remarks>        <short>    Returns the item at the given <code>index.</code></short>
        public Akonadi.Item ItemForIndex(QModelIndex index) {
            return (Akonadi.Item) interceptor.Invoke("itemForIndex#", "itemForIndex(const QModelIndex&) const", typeof(Akonadi.Item), typeof(QModelIndex), index);
        }
        /// <remarks>
        ///  Returns the model index for the given item, with the given column.
        /// <param> name="item" The item to find.
        /// </param><param> name="column" The column for the returned index.
        ///      </param></remarks>        <short>    Returns the model index for the given item, with the given column.</short>
        public QModelIndex IndexForItem(Akonadi.Item item, int column) {
            return (QModelIndex) interceptor.Invoke("indexForItem#$", "indexForItem(const Akonadi::Item&, const int) const", typeof(QModelIndex), typeof(Akonadi.Item), item, typeof(int), column);
        }
        [SmokeMethod("dropMimeData(const QMimeData*, Qt::DropAction, int, int, const QModelIndex&)")]
        public override bool DropMimeData(QMimeData data, Qt.DropAction action, int row, int column, QModelIndex parent) {
            return (bool) interceptor.Invoke("dropMimeData#$$$#", "dropMimeData(const QMimeData*, Qt::DropAction, int, int, const QModelIndex&)", typeof(bool), typeof(QMimeData), data, typeof(Qt.DropAction), action, typeof(int), row, typeof(int), column, typeof(QModelIndex), parent);
        }
        /// <remarks>
        ///  Returns the collection being displayed in the model.
        ///      </remarks>        <short>    Returns the collection being displayed in the model.</short>
        public Akonadi.Collection Collection() {
            return (Akonadi.Collection) interceptor.Invoke("collection", "collection() const", typeof(Akonadi.Collection));
        }
        /// <remarks>
        ///  Sets the collection the model should display. If the collection has
        ///  changed, the model is reset and a new message listing is requested
        ///  from the Akonadi storage.
        /// <param> name="collection" The collection.
        ///      </param></remarks>        <short>    Sets the collection the model should display.</short>
        [Q_SLOT("void setCollection(Akonadi::Collection)")]
        public void SetCollection(Akonadi.Collection collection) {
            interceptor.Invoke("setCollection#", "setCollection(const Akonadi::Collection&)", typeof(void), typeof(Akonadi.Collection), collection);
        }
        /// <remarks>
        ///  Returns the Session object used for all operations by this model.
        ///      </remarks>        <short>    Returns the Session object used for all operations by this model.</short>
        protected Akonadi.Session Session() {
            return (Akonadi.Session) interceptor.Invoke("session", "session() const", typeof(Akonadi.Session));
        }
		public override QModelIndex Parent(QModelIndex child) {
            return null;
		}
        ~ItemModel() {
            interceptor.Invoke("~ItemModel", "~ItemModel()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~ItemModel", "~ItemModel()", typeof(void));
        }
        protected new IItemModelSignals Emit {
            get { return (IItemModelSignals) Q_EMIT; }
        }
    }

    public interface IItemModelSignals : IQAbstractTableModelSignals {
        /// <remarks>
        ///  This signal is emitted whenever setCollection is called.
        /// <param> name="collection" The new collection.
        ///      </param></remarks>        <short>    This signal is emitted whenever setCollection is called.</short>
        [Q_SIGNAL("void collectionChanged(Collection)")]
        void CollectionChanged(Akonadi.Collection collection);
    }
}
