//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  @class WallpaperScript plasma/scripting/wallpaperscript.h <Plasma/Scripting/WallpaperScript>
    /// </remarks>        <short> Provides a restricted interface for scripting a Wallpaper.</short>
    [SmokeClass("Plasma::WallpaperScript")]
    public class WallpaperScript : Plasma.ScriptEngine, IDisposable {
        protected WallpaperScript(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(WallpaperScript), this);
        }
        /// <remarks>
        ///  Default constructor for a WallpaperScript.
        ///  Subclasses should not attempt to access the Plasma.Wallpaper
        ///  associated with this WallpaperScript in the constructor. All
        ///  such set up that requires the Wallpaper itself should be done
        ///  in the init() method.
        ///      </remarks>        <short>    Default constructor for a WallpaperScript.</short>
        public WallpaperScript(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("WallpaperScript#", "WallpaperScript(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public WallpaperScript() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("WallpaperScript", "WallpaperScript()", typeof(void));
        }
        /// <remarks>
        ///  Sets the Plasma.Wallpaper associated with this WallpaperScript
        ///      </remarks>        <short>    Sets the Plasma.Wallpaper associated with this WallpaperScript      </short>
        public void SetWallpaper(Plasma.Wallpaper wallpaper) {
            interceptor.Invoke("setWallpaper#", "setWallpaper(Plasma::Wallpaper*)", typeof(void), typeof(Plasma.Wallpaper), wallpaper);
        }
        /// <remarks>
        ///  Returns the Plasma.Wallpaper associated with this script component
        ///      </remarks>        <short>    Returns the Plasma.Wallpaper associated with this script component      </short>
        public Plasma.Wallpaper Wallpaper() {
            return (Plasma.Wallpaper) interceptor.Invoke("wallpaper", "wallpaper() const", typeof(Plasma.Wallpaper));
        }
        /// <remarks>
        ///  This method is called once the wallpaper is loaded or mode is changed.
        ///  The mode can be retrieved using the renderingMode() method.
        /// <param> name="config" Config group to load settings
        /// </param></remarks>        <short>    This method is called once the wallpaper is loaded or mode is changed.</short>
        [SmokeMethod("initWallpaper(const KConfigGroup&)")]
        public virtual void InitWallpaper(KConfigGroup config) {
            interceptor.Invoke("initWallpaper#", "initWallpaper(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
        }
        /// <remarks>
        ///  This method is called when the wallpaper should be painted.
        /// <param> name="painter" the QPainter to use to do the painting
        /// </param><param> name="exposedRect" the rect to paint within
        /// </param></remarks>        <short>    This method is called when the wallpaper should be painted.</short>
        [SmokeMethod("paint(QPainter*, const QRectF&)")]
        public virtual void Paint(QPainter painter, QRectF exposedRect) {
            interceptor.Invoke("paint##", "paint(QPainter*, const QRectF&)", typeof(void), typeof(QPainter), painter, typeof(QRectF), exposedRect);
        }
        /// <remarks>
        ///  This method is called when settings need to be saved.
        /// <param> name="config" Config group to save settings
        /// </param></remarks>        <short>    This method is called when settings need to be saved.</short>
        [SmokeMethod("save(KConfigGroup&)")]
        public virtual void Save(KConfigGroup config) {
            interceptor.Invoke("save#", "save(KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
        }
        /// <remarks>
        ///  Returns a widget that can be used to configure the options (if any)
        ///  associated with this wallpaper. It will be deleted by the caller
        ///  when it complete. The default implementation returns a null pointer.
        ///  To signal that settings have changed connect to
        ///  settingsChanged(bool modified) in <code>parent.</code>
        ///  @code connect(this, SIGNAL(settingsChanged(bool), parent, SLOT("settingsChanged(bool)"))
        ///  @endcode
        ///  Emit settingsChanged(true) when the settings are changed and false when the original state is restored.
        ///  Implementation detail note: for best visual results, use a QGridLayout with two columns,
        ///  with the option labels in column 0
        ///      </remarks>        <short>    Returns a widget that can be used to configure the options (if any)  associated with this wallpaper.</short>
        [SmokeMethod("createConfigurationInterface(QWidget*)")]
        public virtual QWidget CreateConfigurationInterface(QWidget parent) {
            return (QWidget) interceptor.Invoke("createConfigurationInterface#", "createConfigurationInterface(QWidget*)", typeof(QWidget), typeof(QWidget), parent);
        }
        /// <remarks>
        ///  Mouse move event. To prevent further propagation of the event,
        ///  the event must be accepted.
        /// <param> name="event" the mouse event object
        ///      </param></remarks>        <short>    Mouse move event.</short>
        [SmokeMethod("mouseMoveEvent(QGraphicsSceneMouseEvent*)")]
        public virtual void MouseMoveEvent(QGraphicsSceneMouseEvent arg1) {
            interceptor.Invoke("mouseMoveEvent#", "mouseMoveEvent(QGraphicsSceneMouseEvent*)", typeof(void), typeof(QGraphicsSceneMouseEvent), arg1);
        }
        /// <remarks>
        ///  Mouse press event. To prevent further propagation of the even,
        ///  and to receive mouseMoveEvents, the event must be accepted.
        /// <param> name="event" the mouse event object
        ///      </param></remarks>        <short>    Mouse press event.</short>
        [SmokeMethod("mousePressEvent(QGraphicsSceneMouseEvent*)")]
        public virtual void MousePressEvent(QGraphicsSceneMouseEvent arg1) {
            interceptor.Invoke("mousePressEvent#", "mousePressEvent(QGraphicsSceneMouseEvent*)", typeof(void), typeof(QGraphicsSceneMouseEvent), arg1);
        }
        /// <remarks>
        ///  Mouse release event. To prevent further propagation of the event,
        ///  the event must be accepted.
        /// <param> name="event" the mouse event object
        ///      </param></remarks>        <short>    Mouse release event.</short>
        [SmokeMethod("mouseReleaseEvent(QGraphicsSceneMouseEvent*)")]
        public virtual void MouseReleaseEvent(QGraphicsSceneMouseEvent arg1) {
            interceptor.Invoke("mouseReleaseEvent#", "mouseReleaseEvent(QGraphicsSceneMouseEvent*)", typeof(void), typeof(QGraphicsSceneMouseEvent), arg1);
        }
        /// <remarks>
        ///  Mouse wheel event. To prevent further propagation of the event,
        ///  the event must be accepted.
        /// <param> name="event" the wheel event object
        ///      </param></remarks>        <short>    Mouse wheel event.</short>
        [SmokeMethod("wheelEvent(QGraphicsSceneWheelEvent*)")]
        public virtual void WheelEvent(QGraphicsSceneWheelEvent arg1) {
            interceptor.Invoke("wheelEvent#", "wheelEvent(QGraphicsSceneWheelEvent*)", typeof(void), typeof(QGraphicsSceneWheelEvent), arg1);
        }
        /// <remarks>
        /// </remarks>        <return> absolute path to the main script file for this wallpaper
        ///      </return>
        ///         <short>   </short>
        [SmokeMethod("mainScript() const")]
        protected override string MainScript() {
            return (string) interceptor.Invoke("mainScript", "mainScript() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> the Package associated with this wallpaper which can
        ///          be used to request resources, such as images and
        ///          interface files.
        ///      </return>
        ///         <short>   </short>
        [SmokeMethod("package() const")]
        protected override Plasma.Package Package() {
            return (Plasma.Package) interceptor.Invoke("package", "package() const", typeof(Plasma.Package));
        }
        /// <remarks>
        /// </remarks>        <return> the KPluginInfo associated with this wallpaper
        ///      </return>
        ///         <short>   </short>
        protected KPluginInfo Description() {
            return (KPluginInfo) interceptor.Invoke("description", "description() const", typeof(KPluginInfo));
        }
        protected bool IsInitialized() {
            return (bool) interceptor.Invoke("isInitialized", "isInitialized() const", typeof(bool));
        }
        protected QRectF BoundingRect() {
            return (QRectF) interceptor.Invoke("boundingRect", "boundingRect() const", typeof(QRectF));
        }
        protected Plasma.DataEngine DataEngine(string name) {
            return (Plasma.DataEngine) interceptor.Invoke("dataEngine$", "dataEngine(const QString&) const", typeof(Plasma.DataEngine), typeof(string), name);
        }
        protected void SetResizeMethodHint(Plasma.Wallpaper.ResizeMethod resizeMethod) {
            interceptor.Invoke("setResizeMethodHint$", "setResizeMethodHint(Plasma::Wallpaper::ResizeMethod)", typeof(void), typeof(Plasma.Wallpaper.ResizeMethod), resizeMethod);
        }
        protected void SetTargetSizeHint(QSizeF targetSize) {
            interceptor.Invoke("setTargetSizeHint#", "setTargetSizeHint(const QSizeF&)", typeof(void), typeof(QSizeF), targetSize);
        }
        protected void SetConfigurationRequired(bool needsConfiguring, string reason) {
            interceptor.Invoke("setConfigurationRequired$$", "setConfigurationRequired(bool, const QString&)", typeof(void), typeof(bool), needsConfiguring, typeof(string), reason);
        }
        protected void SetConfigurationRequired(bool needsConfiguring) {
            interceptor.Invoke("setConfigurationRequired$", "setConfigurationRequired(bool)", typeof(void), typeof(bool), needsConfiguring);
        }
        protected void Render(string sourceImagePath, QSize size, Plasma.Wallpaper.ResizeMethod resizeMethod, QColor color) {
            interceptor.Invoke("render$#$#", "render(const QString&, const QSize&, Plasma::Wallpaper::ResizeMethod, const QColor&)", typeof(void), typeof(string), sourceImagePath, typeof(QSize), size, typeof(Plasma.Wallpaper.ResizeMethod), resizeMethod, typeof(QColor), color);
        }
        protected void Render(string sourceImagePath, QSize size, Plasma.Wallpaper.ResizeMethod resizeMethod) {
            interceptor.Invoke("render$#$", "render(const QString&, const QSize&, Plasma::Wallpaper::ResizeMethod)", typeof(void), typeof(string), sourceImagePath, typeof(QSize), size, typeof(Plasma.Wallpaper.ResizeMethod), resizeMethod);
        }
        protected void Render(string sourceImagePath, QSize size) {
            interceptor.Invoke("render$#", "render(const QString&, const QSize&)", typeof(void), typeof(string), sourceImagePath, typeof(QSize), size);
        }
        protected void SetUsingRenderingCache(bool useCache) {
            interceptor.Invoke("setUsingRenderingCache$", "setUsingRenderingCache(bool)", typeof(void), typeof(bool), useCache);
        }
        protected bool FindInCache(string key, QImage image, uint lastModified) {
            return (bool) interceptor.Invoke("findInCache$#$", "findInCache(const QString&, QImage&, unsigned int)", typeof(bool), typeof(string), key, typeof(QImage), image, typeof(uint), lastModified);
        }
        protected bool FindInCache(string key, QImage image) {
            return (bool) interceptor.Invoke("findInCache$#", "findInCache(const QString&, QImage&)", typeof(bool), typeof(string), key, typeof(QImage), image);
        }
        protected void InsertIntoCache(string key, QImage image) {
            interceptor.Invoke("insertIntoCache$#", "insertIntoCache(const QString&, const QImage&)", typeof(void), typeof(string), key, typeof(QImage), image);
        }
        protected void SetContextualActions(List<QAction> actions) {
            interceptor.Invoke("setContextualActions?", "setContextualActions(const QList<QAction*>&)", typeof(void), typeof(List<QAction>), actions);
        }
        protected void Update(QRectF exposedArea) {
            interceptor.Invoke("update#", "update(const QRectF&)", typeof(void), typeof(QRectF), exposedArea);
        }
        protected void ConfigNeedsSaving() {
            interceptor.Invoke("configNeedsSaving", "configNeedsSaving()", typeof(void));
        }
        [Q_SLOT("void renderCompleted(QImage)")]
        [SmokeMethod("renderCompleted(const QImage&)")]
        protected virtual void RenderCompleted(QImage image) {
            interceptor.Invoke("renderCompleted#", "renderCompleted(const QImage&)", typeof(void), typeof(QImage), image);
        }
        [Q_SLOT("void urlDropped(KUrl)")]
        [SmokeMethod("urlDropped(const KUrl&)")]
        protected virtual void UrlDropped(KUrl url) {
            interceptor.Invoke("urlDropped#", "urlDropped(const KUrl&)", typeof(void), typeof(KUrl), url);
        }
        ~WallpaperScript() {
            interceptor.Invoke("~WallpaperScript", "~WallpaperScript()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~WallpaperScript", "~WallpaperScript()", typeof(void));
        }
        protected new IWallpaperScriptSignals Emit {
            get { return (IWallpaperScriptSignals) Q_EMIT; }
        }
    }

    public interface IWallpaperScriptSignals : Plasma.IScriptEngineSignals {
    }
}
