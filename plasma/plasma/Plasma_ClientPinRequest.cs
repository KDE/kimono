//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    /// <remarks>
    ///  @class ClientPinRequest plasma/clientpinrequest.h <Plasma/ClientPinRequest>
    ///  describes an outgoing connection. this is just passed to AuthorizationInterface when a remote
    ///  widget asks to do pin pairing first, so the shell can ask the user for a pin.
    /// </remarks>        <short>    @class ClientPinRequest plasma/clientpinrequest.</short>
    [SmokeClass("Plasma::ClientPinRequest")]
    public class ClientPinRequest : QObject {
        protected ClientPinRequest(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(ClientPinRequest), this);
        }
        /// <remarks>
        /// </remarks>        <return> nice i18n'ed description of this outgoing connection.
        ///          </return>
        ///         <short>   </short>
        public string Description() {
            return (string) interceptor.Invoke("description", "description() const", typeof(string));
        }
        /// <remarks>
        /// <param> name="pin" set a pin for pin pairing.
        ///          </param></remarks>        <short>   </short>
        public void SetPin(string pin) {
            interceptor.Invoke("setPin$", "setPin(const QString&)", typeof(void), typeof(string), pin);
        }
        /// <remarks>
        /// </remarks>        <return> the pin for pin pairing.
        ///          </return>
        ///         <short>   </short>
        public string Pin() {
            return (string) interceptor.Invoke("pin", "pin() const", typeof(string));
        }
        protected new IClientPinRequestSignals Emit {
            get { return (IClientPinRequestSignals) Q_EMIT; }
        }
    }

    public interface IClientPinRequestSignals : IQObjectSignals {
    }
}
