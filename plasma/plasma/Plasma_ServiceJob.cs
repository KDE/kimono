//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  @class ServiceJob plasma/servicejob.h <Plasma/ServiceJob>
    ///  Unlike KJob, you can do the work in start(), since Plasma.Service already
    ///  delays the call to start() until the event loop is reached.
    ///  If the job is quick enough that it is not worth reporting the progress,
    ///  you just need to implement start() to do the task, then call emitResult()
    ///  at the end of it.  If the task does not complete successfully, you should
    ///  set a non-zero error code with setError(int) and an error message with
    ///  setErrorText(string).
    ///  If the job is longer (involving network access, for instance), you should
    ///  report the progress at regular intervals.  See the KJob documentation for
    ///  information on how to do this.
    ///  </remarks>        <short> This class provides jobs for use with Plasma.Service.</short>
    [SmokeClass("Plasma::ServiceJob")]
    public class ServiceJob : KJob, IDisposable {
        protected ServiceJob(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(ServiceJob), this);
        }
        /// <remarks>
        ///  Default constructor
        ///  @arg destination the subject that the job is acting on
        ///  @arg operation   the action that the job is performing on the <code>destination</code>
        ///  @arg parameters  the parameters of the <code>action</code>
        ///  @arg parent      the parent object for this service
        ///      </remarks>        <short>    Default constructor </short>
        public ServiceJob(string destination, string operation, Dictionary<string, QVariant> parameters, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ServiceJob$$?#", "ServiceJob(const QString&, const QString&, const QMap<QString,QVariant>&, QObject*)", typeof(void), typeof(string), destination, typeof(string), operation, typeof(Dictionary<string, QVariant>), parameters, typeof(QObject), parent);
        }
        public ServiceJob(string destination, string operation, Dictionary<string, QVariant> parameters) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ServiceJob$$?", "ServiceJob(const QString&, const QString&, const QMap<QString,QVariant>&)", typeof(void), typeof(string), destination, typeof(string), operation, typeof(Dictionary<string, QVariant>), parameters);
        }
        /// <remarks>
        /// </remarks>        <return> the subject that the job is acting on
        ///      </return>
        ///         <short>   </short>
        public string Destination() {
            return (string) interceptor.Invoke("destination", "destination() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> the operation the job is performing on the destination
        ///      </return>
        ///         <short>   </short>
        public string OperationName() {
            return (string) interceptor.Invoke("operationName", "operationName() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> the parameters for the operation
        ///      </return>
        ///         <short>   </short>
        public Dictionary<string, QVariant> Parameters() {
            return (Dictionary<string, QVariant>) interceptor.Invoke("parameters", "parameters() const", typeof(Dictionary<string, QVariant>));
        }
        /// <remarks>
        ///  Returns the result of the operation
        ///  The result will be invalid if the job has not completed yet, or
        ///  if the job does not have a meaningful result.
        ///  Note that this should not be used to find out whether the operation
        ///  was successful.  Instead, you should check the value of error().
        /// </remarks>        <return> the result of the operation
        ///      </return>
        ///         <short>    Returns the result of the operation </short>
        public QVariant Result() {
            return (QVariant) interceptor.Invoke("result", "result() const", typeof(QVariant));
        }
        /// <remarks>
        ///  Default implementation of start, which simply sets the results to false.
        ///  This makes it easy to create a "failure" job.
        ///      </remarks>        <short>    Default implementation of start, which simply sets the results to false.</short>
        [SmokeMethod("start()")]
        public override void Start() {
            interceptor.Invoke("start", "start()", typeof(void));
        }
        /// <remarks>
        ///  Sets the result for an operation.
        ///      </remarks>        <short>    Sets the result for an operation.</short>
        protected void SetResult(QVariant result) {
            interceptor.Invoke("setResult#", "setResult(const QVariant&)", typeof(void), typeof(QVariant), result);
        }
        ~ServiceJob() {
            interceptor.Invoke("~ServiceJob", "~ServiceJob()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~ServiceJob", "~ServiceJob()", typeof(void));
        }
        protected new IServiceJobSignals Emit {
            get { return (IServiceJobSignals) Q_EMIT; }
        }
    }

    public interface IServiceJobSignals : IKJobSignals {
    }
}
