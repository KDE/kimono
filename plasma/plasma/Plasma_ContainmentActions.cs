//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  @class ContainmentActions plasma/containmentactions.h <Plasma/ContainmentActions>
    ///  "ContainmentActions" are components that provide actions (usually displaying a contextmenu) in
    ///  response to an event with a position (usually a mouse event).
    ///  ContainmentActions plugins are registered using .desktop files. These files should be
    ///  named using the following naming scheme:
    ///      plasma-containmentactions-\<pluginname\>.desktop
    ///  </remarks>        <short> The base ContainmentActions class.</short>
    [SmokeClass("Plasma::ContainmentActions")]
    public class ContainmentActions : QObject, IDisposable {
        protected ContainmentActions(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(ContainmentActions), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static ContainmentActions() {
            staticInterceptor = new SmokeInvocation(typeof(ContainmentActions), null);
        }
        [Q_PROPERTY("QString", "name")]
        public string Name {
            get { return (string) interceptor.Invoke("name", "name()", typeof(string)); }
        }
        [Q_PROPERTY("QString", "pluginName")]
        public string PluginName {
            get { return (string) interceptor.Invoke("pluginName", "pluginName()", typeof(string)); }
        }
        [Q_PROPERTY("QString", "icon")]
        public string icon {
            get { return (string) interceptor.Invoke("icon", "icon()", typeof(string)); }
        }
        /// <remarks>
        ///  Default constructor for an empty or null containmentactions
        ///          </remarks>        <short>    Default constructor for an empty or null containmentactions          </short>
        public ContainmentActions(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ContainmentActions#", "ContainmentActions(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public ContainmentActions() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ContainmentActions", "ContainmentActions()", typeof(void));
        }
        /// <remarks>
        /// </remarks>        <return> true if initialized (usually by calling restore), false otherwise
        ///          </return>
        ///         <short>   </short>
        public bool IsInitialized() {
            return (bool) interceptor.Invoke("isInitialized", "isInitialized() const", typeof(bool));
        }
        /// <remarks>
        ///  This method should be called once the plugin is loaded or settings are changed.
        /// <param> name="config" Config group to load settings
        /// </param></remarks>        <short>    This method should be called once the plugin is loaded or settings are changed.</short>
        ///         <see> init</see>
        public void Restore(KConfigGroup config) {
            interceptor.Invoke("restore#", "restore(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
        }
        /// <remarks>
        ///  This method is called when settings need to be saved.
        /// <param> name="config" Config group to save settings
        /// </param></remarks>        <short>    This method is called when settings need to be saved.</short>
        [SmokeMethod("save(KConfigGroup&)")]
        public virtual void Save(KConfigGroup config) {
            interceptor.Invoke("save#", "save(KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
        }
        /// <remarks>
        ///  Returns the widget used in the configuration dialog.
        ///  Add the configuration interface of the containmentactions to this widget.
        ///          </remarks>        <short>    Returns the widget used in the configuration dialog.</short>
        [SmokeMethod("createConfigurationInterface(QWidget*)")]
        public virtual QWidget CreateConfigurationInterface(QWidget parent) {
            return (QWidget) interceptor.Invoke("createConfigurationInterface#", "createConfigurationInterface(QWidget*)", typeof(QWidget), typeof(QWidget), parent);
        }
        /// <remarks>
        ///  This method is called when the user's configuration changes are accepted
        ///          </remarks>        <short>    This method is called when the user's configuration changes are accepted          </short>
        [SmokeMethod("configurationAccepted()")]
        public virtual void ConfigurationAccepted() {
            interceptor.Invoke("configurationAccepted", "configurationAccepted()", typeof(void));
        }
        /// <remarks>
        ///  Implement this to respond to events.
        ///  The user can configure whatever button and modifier they like, so please don't look at
        ///  those parameters.
        ///  So far the event could be a QGraphicsSceneMouseEvent or a QGraphicsSceneWheelEvent.
        ///          </remarks>        <short>    Implement this to respond to events.</short>
        [SmokeMethod("contextEvent(QEvent*)")]
        public virtual void ContextEvent(QEvent arg1) {
            interceptor.Invoke("contextEvent#", "contextEvent(QEvent*)", typeof(void), typeof(QEvent), arg1);
        }
        /// <remarks>
        ///  Implement this to provide a list of actions that can be added to another menu
        ///  for example, when right-clicking an applet, the "Activity Options" submenu is populated
        ///  with this.
        ///          </remarks>        <short>    Implement this to provide a list of actions that can be added to another menu  for example, when right-clicking an applet, the "Activity Options" submenu is populated  with this.</short>
        [SmokeMethod("contextualActions()")]
        public virtual List<QAction> ContextualActions() {
            return (List<QAction>) interceptor.Invoke("contextualActions", "contextualActions()", typeof(List<QAction>));
        }
        /// <remarks>
        ///  Loads the given DataEngine
        ///  Tries to load the data engine given by <code>name.</code>  Each engine is
        ///  only loaded once, and that instance is re-used on all subsequent
        ///  requests.
        ///  If the data engine was not found, an invalid data engine is returned
        ///  (see DataEngine.IsValid()).
        ///  Note that you should <em>not</em> delete the returned engine.
        /// <param> name="name" Name of the data engine to load
        /// </param>         </remarks>        <return> pointer to the data engine if it was loaded,
        ///          or an invalid data engine if the requested engine
        ///          could not be loaded
        /// </return>
        ///         <short>    Loads the given DataEngine </short>
        public Plasma.DataEngine DataEngine(string name) {
            return (Plasma.DataEngine) interceptor.Invoke("dataEngine$", "dataEngine(const QString&) const", typeof(Plasma.DataEngine), typeof(string), name);
        }
        /// <remarks>
        /// </remarks>        <return> true if the containmentactions currently needs to be configured,
        ///          otherwise, false
        ///          </return>
        ///         <short>   </short>
        public bool ConfigurationRequired() {
            return (bool) interceptor.Invoke("configurationRequired", "configurationRequired() const", typeof(bool));
        }
        [SmokeMethod("event(QEvent*)")]
        public override bool Event(QEvent e) {
            return (bool) interceptor.Invoke("event#", "event(QEvent*)", typeof(bool), typeof(QEvent), e);
        }
        /// <remarks>
        ///  This constructor is to be used with the plugin loading systems
        ///  found in KPluginInfo and KService. The argument list is expected
        ///  to have one element: the KService service ID for the desktop entry.
        /// <param> name="parent" a QObject parent; you probably want to pass in 0
        /// </param><param> name="args" a list of strings containing one entry: the service id
        ///          </param></remarks>        <short>    This constructor is to be used with the plugin loading systems  found in KPluginInfo and KService.</short>
        public ContainmentActions(QObject parent, List<QVariant> args) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ContainmentActions#?", "ContainmentActions(QObject*, const QList<QVariant>&)", typeof(void), typeof(QObject), parent, typeof(List<QVariant>), args);
        }
        /// <remarks>
        ///  This method is called once the containmentactions is loaded or settings are changed.
        /// <param> name="config" Config group to load settings
        /// </param></remarks>        <short>    This method is called once the containmentactions is loaded or settings are changed.</short>
        [SmokeMethod("init(const KConfigGroup&)")]
        protected virtual void Init(KConfigGroup config) {
            interceptor.Invoke("init#", "init(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
        }
        /// <remarks>
        ///  When the containmentactions needs to be configured before being usable, this
        ///  method can be called to denote that action is required
        /// <param> name="needsConfiguring" true if the applet needs to be configured,
        ///                          or false if it doesn't
        ///          </param></remarks>        <short>    When the containmentactions needs to be configured before being usable, this  method can be called to denote that action is required </short>
        protected void SetConfigurationRequired(bool needsConfiguring) {
            interceptor.Invoke("setConfigurationRequired$", "setConfigurationRequired(bool)", typeof(void), typeof(bool), needsConfiguring);
        }
        protected void SetConfigurationRequired() {
            interceptor.Invoke("setConfigurationRequired", "setConfigurationRequired()", typeof(void));
        }
        /// <remarks>
        /// </remarks>        <return> the containment the plugin is associated with.
        ///          </return>
        ///         <short>   </short>
        protected Plasma.Containment Containment() {
            return (Plasma.Containment) interceptor.Invoke("containment", "containment()", typeof(Plasma.Containment));
        }
        /// <remarks>
        ///  pastes the clipboard at a given location
        ///          </remarks>        <short>    pastes the clipboard at a given location          </short>
        protected void Paste(QPointF scenePos, QPoint screenPos) {
            interceptor.Invoke("paste##", "paste(QPointF, QPoint)", typeof(void), typeof(QPointF), scenePos, typeof(QPoint), screenPos);
        }
        ~ContainmentActions() {
            interceptor.Invoke("~ContainmentActions", "~ContainmentActions()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~ContainmentActions", "~ContainmentActions()", typeof(void));
        }
        /// <remarks>
        ///  Returns a list of all known containmentactions plugins.
        /// </remarks>        <return> list of containmentactions plugins
        /// </return>
        ///         <short>    Returns a list of all known containmentactions plugins.</short>
        public static List<KPluginInfo> ListContainmentActionsInfo() {
            return (List<KPluginInfo>) staticInterceptor.Invoke("listContainmentActionsInfo", "listContainmentActionsInfo()", typeof(List<KPluginInfo>));
        }
        /// <remarks>
        ///  Attempts to load a containmentactions
        ///  Returns a pointer to the containmentactions if successful.
        ///  The caller takes responsibility for the containmentactions, including
        ///  deleting it when no longer needed.
        /// <param> name="parent" the parent containment. Required; if you send null you'll get back null.
        /// </param><param> name="name" the plugin name, as returned by KPluginInfo.PluginName()
        /// </param><param> name="args" to send the containmentactions extra arguments
        /// </param></remarks>        <return> a pointer to the loaded containmentactions, or 0 on load failure
        /// </return>
        ///         <short>    Attempts to load a containmentactions </short>
        public static Plasma.ContainmentActions Load(Plasma.Containment parent, string name, List<QVariant> args) {
            return (Plasma.ContainmentActions) staticInterceptor.Invoke("load#$?", "load(Plasma::Containment*, const QString&, const QList<QVariant>&)", typeof(Plasma.ContainmentActions), typeof(Plasma.Containment), parent, typeof(string), name, typeof(List<QVariant>), args);
        }
        public static Plasma.ContainmentActions Load(Plasma.Containment parent, string name) {
            return (Plasma.ContainmentActions) staticInterceptor.Invoke("load#$", "load(Plasma::Containment*, const QString&)", typeof(Plasma.ContainmentActions), typeof(Plasma.Containment), parent, typeof(string), name);
        }
        /// <remarks>
        ///  Attempts to load a containmentactions
        ///  Returns a pointer to the containmentactions if successful.
        ///  The caller takes responsibility for the containmentactions, including
        ///  deleting it when no longer needed.
        /// <param> name="parent" the parent containment. Required; if you send null you'll get back null.
        /// </param><param> name="info" KPluginInfo object for the desired containmentactions
        /// </param><param> name="args" to send the containmentactions extra arguments
        /// </param></remarks>        <return> a pointer to the loaded containmentactions, or 0 on load failure
        /// </return>
        ///         <short>    Attempts to load a containmentactions </short>
        public static Plasma.ContainmentActions Load(Plasma.Containment parent, KPluginInfo info, List<QVariant> args) {
            return (Plasma.ContainmentActions) staticInterceptor.Invoke("load##?", "load(Plasma::Containment*, const KPluginInfo&, const QList<QVariant>&)", typeof(Plasma.ContainmentActions), typeof(Plasma.Containment), parent, typeof(KPluginInfo), info, typeof(List<QVariant>), args);
        }
        public static Plasma.ContainmentActions Load(Plasma.Containment parent, KPluginInfo info) {
            return (Plasma.ContainmentActions) staticInterceptor.Invoke("load##", "load(Plasma::Containment*, const KPluginInfo&)", typeof(Plasma.ContainmentActions), typeof(Plasma.Containment), parent, typeof(KPluginInfo), info);
        }
        /// <remarks>
        ///  Returns the Package specialization for containmentactions.
        ///          </remarks>        <short>    Returns the Package specialization for containmentactions.</short>
        public static Plasma.PackageStructure PackageStructure() {
            return (Plasma.PackageStructure) staticInterceptor.Invoke("packageStructure", "packageStructure()", typeof(Plasma.PackageStructure));
        }
        /// <remarks>
        ///  Turns a mouse or wheel event into a string suitable for a ContainmentActions
        /// </remarks>        <return> the string representation of the event
        ///          </return>
        ///         <short>    Turns a mouse or wheel event into a string suitable for a ContainmentActions </short>
        public static string EventToString(QEvent arg1) {
            return (string) staticInterceptor.Invoke("eventToString#", "eventToString(QEvent*)", typeof(string), typeof(QEvent), arg1);
        }
        protected new IContainmentActionsSignals Emit {
            get { return (IContainmentActionsSignals) Q_EMIT; }
        }
    }

    public interface IContainmentActionsSignals : IQObjectSignals {
    }
}
