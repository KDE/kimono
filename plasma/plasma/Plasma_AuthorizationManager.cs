//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    /// <remarks>
    ///  @class AuthorizationManager plasma/authorizationmanager.h <Plasma/AccessManager>
    ///  This is the class where every message to or from another machine passes through.
    ///  It's responsibilities are:
    ///  - creating/keeping a credentials used for message signing.
    ///  - verifying credentials of incoming messages.
    ///  - testing whether or not the sender is allowed to access the requested resource by testing the
    ///    request to a set of rules.
    ///  - allowing the shell to respond to a remote request that doesn't match any of the rules that
    ///    are in effect.
    ///  Besides internal use in libplasma, the only moment you'll need to access this class is when you
    ///  implement a plasma shell.
    /// </remarks>        <short> Allows authorization of access to plasma services. </short>
    [SmokeClass("Plasma::AuthorizationManager")]
    public class AuthorizationManager : QObject {
        protected AuthorizationManager(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(AuthorizationManager), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static AuthorizationManager() {
            staticInterceptor = new SmokeInvocation(typeof(AuthorizationManager), null);
        }
        public enum AuthorizationPolicy {
            DenyAll = 0,
            TrustedOnly = 1,
            PinPairing = 2,
            Custom = 256,
        }
        /// <remarks>
        ///  Set a policy used for authorizing incoming connections. You can either use one of the
        ///  included policies, Default is to deny all incoming connections. This can only be set
        ///  once to avoid that malicious plugins can change this. This means that you should ALWAYS
        ///  call this function in any plasma shell, even if you like to use the default DenyAll
        ///  policy.
        ///          </remarks>        <short>    Set a policy used for authorizing incoming connections.</short>
        public void SetAuthorizationPolicy(Plasma.AuthorizationManager.AuthorizationPolicy policy) {
            interceptor.Invoke("setAuthorizationPolicy$", "setAuthorizationPolicy(Plasma::AuthorizationManager::AuthorizationPolicy)", typeof(void), typeof(Plasma.AuthorizationManager.AuthorizationPolicy), policy);
        }
        /// <remarks>
        ///  Register an implementation of AuthorizationInterface. Use this to make your shell
        ///  handle authorization requests. This can only be set once to avoid that malicious plugins
        ///  can change this.
        ///          </remarks>        <short>    Register an implementation of AuthorizationInterface.</short>
        public void SetAuthorizationInterface(Plasma.AuthorizationInterface arg1) {
            interceptor.Invoke("setAuthorizationInterface#", "setAuthorizationInterface(Plasma::AuthorizationInterface*)", typeof(void), typeof(Plasma.AuthorizationInterface), arg1);
        }
        /// <remarks>
        ///  Singleton pattern accessor.
        ///          </remarks>        <short>    Singleton pattern accessor.</short>
        public static Plasma.AuthorizationManager Self() {
            return (Plasma.AuthorizationManager) staticInterceptor.Invoke("self", "self()", typeof(Plasma.AuthorizationManager));
        }
        protected new IAuthorizationManagerSignals Emit {
            get { return (IAuthorizationManagerSignals) Q_EMIT; }
        }
    }

    public interface IAuthorizationManagerSignals : IQObjectSignals {
    }
}
