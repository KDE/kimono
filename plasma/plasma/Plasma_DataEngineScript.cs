//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks>
    ///  @class DataEngineScript plasma/scripting/dataenginescript.h <Plasma/Scripting/DataEngineScript>
    /// </remarks>        <short> Provides a restricted interface for scripting a DataEngine.</short>
    [SmokeClass("Plasma::DataEngineScript")]
    public class DataEngineScript : Plasma.ScriptEngine, IDisposable {
        protected DataEngineScript(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(DataEngineScript), this);
        }
        /// <remarks>
        ///  Default constructor for a DataEngineScript.
        ///  Subclasses should not attempt to access the Plasma.DataEngine
        ///  associated with this DataEngineScript in the constructor. All
        ///  such set up that requires the DataEngine itself should be done
        ///  in the init() method.
        ///      </remarks>        <short>    Default constructor for a DataEngineScript.</short>
        public DataEngineScript(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("DataEngineScript#", "DataEngineScript(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public DataEngineScript() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("DataEngineScript", "DataEngineScript()", typeof(void));
        }
        /// <remarks>
        ///  Sets the Plasma.DataEngine associated with this DataEngineScript
        ///      </remarks>        <short>    Sets the Plasma.DataEngine associated with this DataEngineScript      </short>
        public void SetDataEngine(Plasma.DataEngine dataEngine) {
            interceptor.Invoke("setDataEngine#", "setDataEngine(Plasma::DataEngine*)", typeof(void), typeof(Plasma.DataEngine), dataEngine);
        }
        /// <remarks>
        ///  Returns the Plasma.DataEngine associated with this script component
        ///      </remarks>        <short>    Returns the Plasma.DataEngine associated with this script component      </short>
        public Plasma.DataEngine DataEngine() {
            return (Plasma.DataEngine) interceptor.Invoke("dataEngine", "dataEngine() const", typeof(Plasma.DataEngine));
        }
        /// <remarks>
        /// </remarks>        <return> a list of all the data sources available via this DataEngine
        ///          Whether these sources are currently available (which is what
        ///          the default implementation provides) or not is up to the
        ///          DataEngine to decide. By default, this returns dataEngine().Sources()
        ///      </return>
        ///         <short>   </short>
        [SmokeMethod("sources() const")]
        public virtual List<string> Sources() {
            return (List<string>) interceptor.Invoke("sources", "sources() const", typeof(List<string>));
        }
        /// <remarks>
        ///  Called when the script should create a source that does not currently
        ///  exist.
        /// <param> name="name" the name of the source that should be created
        /// </param></remarks>        <return> true if a DataContainer was set up, false otherwise
        ///      </return>
        ///         <short>    Called when the script should create a source that does not currently  exist.</short>
        [SmokeMethod("sourceRequestEvent(const QString&)")]
        public virtual bool SourceRequestEvent(string name) {
            return (bool) interceptor.Invoke("sourceRequestEvent$", "sourceRequestEvent(const QString&)", typeof(bool), typeof(string), name);
        }
        /// <remarks>
        ///  Called when the script should refresh the data contained in a given
        ///  source.
        /// <param> name="source" the name of the source that should be updated
        /// </param></remarks>        <return> true if the data was changed, or false if there was no
        ///          change or if the change will occur later
        /// </return>
        ///         <short>    Called when the script should refresh the data contained in a given  source.</short>
        [SmokeMethod("updateSourceEvent(const QString&)")]
        public virtual bool UpdateSourceEvent(string source) {
            return (bool) interceptor.Invoke("updateSourceEvent$", "updateSourceEvent(const QString&)", typeof(bool), typeof(string), source);
        }
        /// <remarks>
        /// <param> name="source" the source to targe the Service at
        /// </param></remarks>        <return> a Service that has the source as a destination. The service
        ///          is parented to the DataEngine, but may be deleted by the
        ///          caller when finished with it
        ///      </return>
        ///         <short>   </short>
        [SmokeMethod("serviceForSource(const QString&)")]
        public virtual Plasma.Service ServiceForSource(string source) {
            return (Plasma.Service) interceptor.Invoke("serviceForSource$", "serviceForSource(const QString&)", typeof(Plasma.Service), typeof(string), source);
        }
        /// <remarks>
        /// </remarks>        <return> absolute path to the main script file for this plasmoid
        ///      </return>
        ///         <short>   </short>
        [SmokeMethod("mainScript() const")]
        public new virtual string MainScript() {
            return (string) interceptor.Invoke("mainScript", "mainScript() const", typeof(string));
        }
        /// <remarks>
        /// </remarks>        <return> the Package associated with this plasmoid which can
        ///          be used to request resources, such as images and
        ///          interface files.
        ///      </return>
        ///         <short>   </short>
        [SmokeMethod("package() const")]
        public new virtual Plasma.Package Package() {
            return (Plasma.Package) interceptor.Invoke("package", "package() const", typeof(Plasma.Package));
        }
        /// <remarks>
        /// </remarks>        <return> the KPluginInfo associated with this plasmoid
        ///      </return>
        ///         <short>   </short>
        public KPluginInfo Description() {
            return (KPluginInfo) interceptor.Invoke("description", "description() const", typeof(KPluginInfo));
        }
        public void SetData(string source, string key, QVariant value) {
            interceptor.Invoke("setData$$#", "setData(const QString&, const QString&, const QVariant&)", typeof(void), typeof(string), source, typeof(string), key, typeof(QVariant), value);
        }
        public void SetData(string source, QVariant value) {
            interceptor.Invoke("setData$#", "setData(const QString&, const QVariant&)", typeof(void), typeof(string), source, typeof(QVariant), value);
        }
        public void RemoveAllData(string source) {
            interceptor.Invoke("removeAllData$", "removeAllData(const QString&)", typeof(void), typeof(string), source);
        }
        public void RemoveData(string source, string key) {
            interceptor.Invoke("removeData$$", "removeData(const QString&, const QString&)", typeof(void), typeof(string), source, typeof(string), key);
        }
        public void SetMaxSourceCount(uint limit) {
            interceptor.Invoke("setMaxSourceCount$", "setMaxSourceCount(uint)", typeof(void), typeof(uint), limit);
        }
        public void SetMinimumPollingInterval(int minimumMs) {
            interceptor.Invoke("setMinimumPollingInterval$", "setMinimumPollingInterval(int)", typeof(void), typeof(int), minimumMs);
        }
        public int MinimumPollingInterval() {
            return (int) interceptor.Invoke("minimumPollingInterval", "minimumPollingInterval() const", typeof(int));
        }
        public void SetPollingInterval(uint frequency) {
            interceptor.Invoke("setPollingInterval$", "setPollingInterval(uint)", typeof(void), typeof(uint), frequency);
        }
        public void RemoveAllSources() {
            interceptor.Invoke("removeAllSources", "removeAllSources()", typeof(void));
        }
        public void AddSource(Plasma.DataContainer source) {
            interceptor.Invoke("addSource#", "addSource(Plasma::DataContainer*)", typeof(void), typeof(Plasma.DataContainer), source);
        }
        public Dictionary<string, Plasma.DataContainer> ContainerDict() {
            return (Dictionary<string, Plasma.DataContainer>) interceptor.Invoke("containerDict", "containerDict() const", typeof(Dictionary<string, Plasma.DataContainer>));
        }
        public void SetName(string name) {
            interceptor.Invoke("setName$", "setName(const QString&)", typeof(void), typeof(string), name);
        }
        public void SetIcon(string icon) {
            interceptor.Invoke("setIcon$", "setIcon(const QString&)", typeof(void), typeof(string), icon);
        }
        public void ScheduleSourcesUpdated() {
            interceptor.Invoke("scheduleSourcesUpdated", "scheduleSourcesUpdated()", typeof(void));
        }
        public void RemoveSource(string source) {
            interceptor.Invoke("removeSource$", "removeSource(const QString&)", typeof(void), typeof(string), source);
        }
        public void UpdateAllSources() {
            interceptor.Invoke("updateAllSources", "updateAllSources()", typeof(void));
        }
        public void ForceImmediateUpdateOfAllVisualizations() {
            interceptor.Invoke("forceImmediateUpdateOfAllVisualizations", "forceImmediateUpdateOfAllVisualizations()", typeof(void));
        }
        ~DataEngineScript() {
            interceptor.Invoke("~DataEngineScript", "~DataEngineScript()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~DataEngineScript", "~DataEngineScript()", typeof(void));
        }
        protected new IDataEngineScriptSignals Emit {
            get { return (IDataEngineScriptSignals) Q_EMIT; }
        }
    }

    public interface IDataEngineScriptSignals : Plasma.IScriptEngineSignals {
    }
}
