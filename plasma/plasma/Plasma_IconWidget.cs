//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    /// <remarks> See <see cref="IIconWidgetSignals"></see> for signals emitted by IconWidget
    /// </remarks>
    [SmokeClass("Plasma::IconWidget")]
    public class IconWidget : QGraphicsWidget, IDisposable {
        protected IconWidget(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(IconWidget), this);
        }
        [Q_PROPERTY("QString", "text")]
        public string Text {
            get { return (string) interceptor.Invoke("text", "text()", typeof(string)); }
            set { interceptor.Invoke("setText$", "setText(QString)", typeof(void), typeof(string), value); }
        }
        [Q_PROPERTY("QString", "infoText")]
        public string InfoText {
            get { return (string) interceptor.Invoke("infoText", "infoText()", typeof(string)); }
            set { interceptor.Invoke("setInfoText$", "setInfoText(QString)", typeof(void), typeof(string), value); }
        }
        [Q_PROPERTY("QIcon", "icon")]
        public QIcon icon {
            get { return (QIcon) interceptor.Invoke("icon", "icon()", typeof(QIcon)); }
            set { interceptor.Invoke("setIcon#", "setIcon(QIcon)", typeof(void), typeof(QIcon), value); }
        }
        [Q_PROPERTY("QColor", "textBackgroundColor")]
        public QColor TextBackgroundColor {
            get { return (QColor) interceptor.Invoke("textBackgroundColor", "textBackgroundColor()", typeof(QColor)); }
            set { interceptor.Invoke("setTextBackgroundColor#", "setTextBackgroundColor(QColor)", typeof(void), typeof(QColor), value); }
        }
        [Q_PROPERTY("QSizeF", "iconSize")]
        public QSizeF IconSize {
            get { return (QSizeF) interceptor.Invoke("iconSize", "iconSize()", typeof(QSizeF)); }
        }
        [Q_PROPERTY("QString", "svg")]
        public string Svg {
            get { return (string) interceptor.Invoke("svg", "svg()", typeof(string)); }
            set { interceptor.Invoke("setSvg$", "setSvg(QString)", typeof(void), typeof(string), value); }
        }
        [Q_PROPERTY("QAction*", "action")]
        public QAction Action {
            get { return (QAction) interceptor.Invoke("action", "action()", typeof(QAction)); }
            set { interceptor.Invoke("setAction#", "setAction(QAction*)", typeof(void), typeof(QAction), value); }
        }
        [Q_PROPERTY("Qt::Orientation", "orientation")]
        public new Qt.Orientation Orientation {
            get { return (Qt.Orientation) interceptor.Invoke("orientation", "orientation()", typeof(Qt.Orientation)); }
            set { interceptor.Invoke("setOrientation$", "setOrientation(Qt::Orientation)", typeof(void), typeof(Qt.Orientation), value); }
        }
        [Q_PROPERTY("int", "numDisplayLines")]
        public int NumDisplayLines {
            get { return (int) interceptor.Invoke("numDisplayLines", "numDisplayLines()", typeof(int)); }
            set { interceptor.Invoke("setNumDisplayLines$", "setNumDisplayLines(int)", typeof(void), typeof(int), value); }
        }
        /// <remarks>
        ///  Creates a new Plasma.IconWidget.
        /// <param> name="parent" the QGraphicsItem this icon is parented to.
        ///     </param></remarks>        <short>    Creates a new Plasma.IconWidget.</short>
        public IconWidget(IQGraphicsItem parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("IconWidget#", "IconWidget(QGraphicsItem*)", typeof(void), typeof(IQGraphicsItem), parent);
        }
        public IconWidget() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("IconWidget", "IconWidget()", typeof(void));
        }
        /// <remarks>
        ///  Convenience constructor to create a Plasma.IconWidget with text.
        /// <param> name="text" the text that will be displayed with this icon.
        /// </param><param> name="parent" the QGraphicsItem this icon is parented to.
        ///     </param></remarks>        <short>    Convenience constructor to create a Plasma.IconWidget with text.</short>
        public IconWidget(string text, IQGraphicsItem parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("IconWidget$#", "IconWidget(const QString&, QGraphicsItem*)", typeof(void), typeof(string), text, typeof(IQGraphicsItem), parent);
        }
        public IconWidget(string text) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("IconWidget$", "IconWidget(const QString&)", typeof(void), typeof(string), text);
        }
        /// <remarks>
        ///  Creates a new Plasma.IconWidget with text and an icon.
        /// <param> name="icon" the icon that will be displayed with this icon.
        /// </param><param> name="text" the text that will be displayed with this icon.
        /// </param><param> name="parent" The QGraphicsItem this icon is parented to.
        ///     </param></remarks>        <short>    Creates a new Plasma.IconWidget with text and an icon.</short>
        public IconWidget(QIcon icon, string text, IQGraphicsItem parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("IconWidget#$#", "IconWidget(const QIcon&, const QString&, QGraphicsItem*)", typeof(void), typeof(QIcon), icon, typeof(string), text, typeof(IQGraphicsItem), parent);
        }
        public IconWidget(QIcon icon, string text) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("IconWidget#$", "IconWidget(const QIcon&, const QString&)", typeof(void), typeof(QIcon), icon, typeof(string), text);
        }
        /// <remarks>
        ///  Convenience method to set the svg image to use when given the filepath and name of svg.
        /// <param> name="svgFilePath" the svg filepath including name of the svg.
        /// </param><param> name="svgIconElement" the svg element to use when displaying the svg. Defaults to all of them.
        ///     </param></remarks>        <short>    Convenience method to set the svg image to use when given the filepath and name of svg.</short>
        public void SetSvg(string svgFilePath, string svgIconElement) {
            interceptor.Invoke("setSvg$$", "setSvg(const QString&, const QString&)", typeof(void), typeof(string), svgFilePath, typeof(string), svgIconElement);
        }
        public void SetSvg(string svgFilePath) {
            interceptor.Invoke("setSvg$", "setSvg(const QString&)", typeof(void), typeof(string), svgFilePath);
        }
        /// <remarks>
        ///  Plasma.IconWidget allows the user to specify a number of actions
        ///  (currently four) to be displayed around the widget. This method
        ///  allows for a created QAction to be added to the Plasma.IconWidget.
        /// <param> name="action" the QAction to associate with this icon.
        ///     </param></remarks>        <short>    Plasma.IconWidget allows the user to specify a number of actions  (currently four) to be displayed around the widget.</short>
        public void AddIconAction(QAction action) {
            interceptor.Invoke("addIconAction#", "addIconAction(QAction*)", typeof(void), typeof(QAction), action);
        }
        /// <remarks>
        ///  Removes a previously set iconAction. The action will be removed from the widget
        ///  but will not be deleted.
        ///      </remarks>        <short>    Removes a previously set iconAction.</short>
        public void RemoveIconAction(QAction action) {
            interceptor.Invoke("removeIconAction#", "removeIconAction(QAction*)", typeof(void), typeof(QAction), action);
        }
        /// <remarks>
        ///  inverts the layout of the icons if the orientation is horizontal,
        ///  normally we get icon on the left with left-to-right languages
        /// <param> name="invert" if we want to invert the layout of icons
        ///     </param></remarks>        <short>    inverts the layout of the icons if the orientation is horizontal,  normally we get icon on the left with left-to-right languages </short>
        public void InvertLayout(bool invert) {
            interceptor.Invoke("invertLayout$", "invertLayout(bool)", typeof(void), typeof(bool), invert);
        }
        /// <remarks>
        /// </remarks>        <return> if the layout of the icons should appear inverted or not
        ///     </return>
        ///         <short>   </short>
        public bool InvertedLayout() {
            return (bool) interceptor.Invoke("invertedLayout", "invertedLayout() const", typeof(bool));
        }
        /// <remarks>
        /// <param> name="iconWidth" desired width of the icon
        ///     </param></remarks>        <return> optimal size given a size for the icon
        /// </return>
        ///         <short>   </short>
        public QSizeF SizeFromIconSize(double iconWidth) {
            return (QSizeF) interceptor.Invoke("sizeFromIconSize$", "sizeFromIconSize(const qreal) const", typeof(QSizeF), typeof(double), iconWidth);
        }
        /// <remarks>
        ///  Sets whether or not to draw a background area for the icon
        ///  @arg draw true if a background should be drawn or not
        ///      </remarks>        <short>    Sets whether or not to draw a background area for the icon </short>
        public void SetDrawBackground(bool draw) {
            interceptor.Invoke("setDrawBackground$", "setDrawBackground(bool)", typeof(void), typeof(bool), draw);
        }
        /// <remarks>
        /// </remarks>        <return> true if a background area is to be drawn for the icon
        ///      </return>
        ///         <short>   </short>
        public bool DrawBackground() {
            return (bool) interceptor.Invoke("drawBackground", "drawBackground() const", typeof(bool));
        }
        /// <remarks>
        ///  reimplemented from QGraphicsItem
        ///      </remarks>        <short>    reimplemented from QGraphicsItem      </short>
        [SmokeMethod("shape() const")]
        public override QPainterPath Shape() {
            return (QPainterPath) interceptor.Invoke("shape", "shape() const", typeof(QPainterPath));
        }
        /// <remarks>
        /// </remarks>        <short>   </short>
        public void DrawActionButtonBase(QPainter painter, QSize size, int element) {
            interceptor.Invoke("drawActionButtonBase##$", "drawActionButtonBase(QPainter*, const QSize&, int)", typeof(void), typeof(QPainter), painter, typeof(QSize), size, typeof(int), element);
        }
        /// <remarks>
        ///  Sets the appearance of the icon to pressed or restores the appearance
        ///  to normal. This does not simulate a mouse button press.
        /// <param> name="pressed" whether to appear as pressed (true) or as normal (false)
        ///     </param></remarks>        <short>    Sets the appearance of the icon to pressed or restores the appearance  to normal.</short>
        [Q_SLOT("void setPressed(bool)")]
        public void SetPressed(bool pressed) {
            interceptor.Invoke("setPressed$", "setPressed(bool)", typeof(void), typeof(bool), pressed);
        }
        [Q_SLOT("void setPressed()")]
        public void SetPressed() {
            interceptor.Invoke("setPressed", "setPressed()", typeof(void));
        }
        /// <remarks>
        ///  Shortcut for setPressed(false)
        ///     </remarks>        <short>    Shortcut for setPressed(false)     </short>
        [Q_SLOT("void setUnpressed()")]
        public void SetUnpressed() {
            interceptor.Invoke("setUnpressed", "setUnpressed()", typeof(void));
        }
        [SmokeMethod("paint(QPainter*, const QStyleOptionGraphicsItem*, QWidget*)")]
        protected new virtual void Paint(QPainter painter, QStyleOptionGraphicsItem option, QWidget widget) {
            interceptor.Invoke("paint###", "paint(QPainter*, const QStyleOptionGraphicsItem*, QWidget*)", typeof(void), typeof(QPainter), painter, typeof(QStyleOptionGraphicsItem), option, typeof(QWidget), widget);
        }
        [SmokeMethod("paint(QPainter*, const QStyleOptionGraphicsItem*)")]
        protected new virtual void Paint(QPainter painter, QStyleOptionGraphicsItem option) {
            interceptor.Invoke("paint##", "paint(QPainter*, const QStyleOptionGraphicsItem*)", typeof(void), typeof(QPainter), painter, typeof(QStyleOptionGraphicsItem), option);
        }
        protected bool IsDown() {
            return (bool) interceptor.Invoke("isDown", "isDown()", typeof(bool));
        }
        [SmokeMethod("mousePressEvent(QGraphicsSceneMouseEvent*)")]
        protected override void MousePressEvent(QGraphicsSceneMouseEvent arg1) {
            interceptor.Invoke("mousePressEvent#", "mousePressEvent(QGraphicsSceneMouseEvent*)", typeof(void), typeof(QGraphicsSceneMouseEvent), arg1);
        }
        [SmokeMethod("mouseMoveEvent(QGraphicsSceneMouseEvent*)")]
        protected override void MouseMoveEvent(QGraphicsSceneMouseEvent arg1) {
            interceptor.Invoke("mouseMoveEvent#", "mouseMoveEvent(QGraphicsSceneMouseEvent*)", typeof(void), typeof(QGraphicsSceneMouseEvent), arg1);
        }
        [SmokeMethod("mouseReleaseEvent(QGraphicsSceneMouseEvent*)")]
        protected override void MouseReleaseEvent(QGraphicsSceneMouseEvent arg1) {
            interceptor.Invoke("mouseReleaseEvent#", "mouseReleaseEvent(QGraphicsSceneMouseEvent*)", typeof(void), typeof(QGraphicsSceneMouseEvent), arg1);
        }
        [SmokeMethod("mouseDoubleClickEvent(QGraphicsSceneMouseEvent*)")]
        protected override void MouseDoubleClickEvent(QGraphicsSceneMouseEvent arg1) {
            interceptor.Invoke("mouseDoubleClickEvent#", "mouseDoubleClickEvent(QGraphicsSceneMouseEvent*)", typeof(void), typeof(QGraphicsSceneMouseEvent), arg1);
        }
        [SmokeMethod("hoverEnterEvent(QGraphicsSceneHoverEvent*)")]
        protected override void HoverEnterEvent(QGraphicsSceneHoverEvent arg1) {
            interceptor.Invoke("hoverEnterEvent#", "hoverEnterEvent(QGraphicsSceneHoverEvent*)", typeof(void), typeof(QGraphicsSceneHoverEvent), arg1);
        }
        [SmokeMethod("hoverLeaveEvent(QGraphicsSceneHoverEvent*)")]
        protected override void HoverLeaveEvent(QGraphicsSceneHoverEvent arg1) {
            interceptor.Invoke("hoverLeaveEvent#", "hoverLeaveEvent(QGraphicsSceneHoverEvent*)", typeof(void), typeof(QGraphicsSceneHoverEvent), arg1);
        }
        [SmokeMethod("sceneEventFilter(QGraphicsItem*, QEvent*)")]
        protected override bool SceneEventFilter(IQGraphicsItem watched, QEvent arg2) {
            return (bool) interceptor.Invoke("sceneEventFilter##", "sceneEventFilter(QGraphicsItem*, QEvent*)", typeof(bool), typeof(IQGraphicsItem), watched, typeof(QEvent), arg2);
        }
        ~IconWidget() {
            interceptor.Invoke("~IconWidget", "~IconWidget()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~IconWidget", "~IconWidget()", typeof(void));
        }
        protected new IIconWidgetSignals Emit {
            get { return (IIconWidgetSignals) Q_EMIT; }
        }
    }

    public interface IIconWidgetSignals : IQGraphicsWidgetSignals {
        /// <remarks>
        ///  Indicates when the icon has been pressed.
        ///     </remarks>        <short>    Indicates when the icon has been pressed.</short>
        [Q_SIGNAL("void pressed(bool)")]
        void Pressed(bool down);
        /// <remarks>
        ///  Indicates when the icon has been clicked.
        ///     </remarks>        <short>    Indicates when the icon has been clicked.</short>
        [Q_SIGNAL("void clicked()")]
        void Clicked();
        /// <remarks>
        ///  Indicates when the icon has been double-clicked
        ///     </remarks>        <short>    Indicates when the icon has been double-clicked     </short>
        [Q_SIGNAL("void doubleClicked()")]
        void DoubleClicked();
        /// <remarks>
        ///  Indicates when the icon has been activated following the single
        ///  or doubleclick settings
        ///     </remarks>        <short>    Indicates when the icon has been activated following the single  or doubleclick settings     </short>
        [Q_SIGNAL("void activated()")]
        void Activated();
        /// <remarks>
        ///  Indicates that something about the icon may have changed (image, text, etc)
        ///  only actually works for icons associated with an action
        ///      </remarks>        <short>    Indicates that something about the icon may have changed (image, text, etc)  only actually works for icons associated with an action      </short>
        [Q_SIGNAL("void changed()")]
        void Changed();
    }
}
